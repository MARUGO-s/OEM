<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ編集 — Recipe Box</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../assets/css/style.css?v=20250115m">
  <link rel="stylesheet" href="../assets/css/components.css?v=20250115m">
  <style>
    /* モーダル内ボタンの文字切れ防止 - 完全版 */
    #category-modal .category-option,
    #tag-modal .tag-option {
      white-space: nowrap !important;
      overflow: visible !important;
      text-overflow: unset !important;
      min-width: 100px !important;
      width: auto !important;
      max-width: none !important;
      word-wrap: normal !important;
      word-break: normal !important;
      overflow-wrap: normal !important;
      flex-shrink: 0 !important;
      font-size: 0.875rem !important;
      padding: 0.75rem 1rem !important;
      text-align: center !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    #category-modal .modal-footer .btn,
    #tag-modal .modal-footer .btn {
      white-space: nowrap !important;
      overflow: visible !important;
      text-overflow: unset !important;
      min-width: auto !important;
      width: auto !important;
      max-width: none !important;
      word-wrap: normal !important;
      word-break: normal !important;
      overflow-wrap: normal !important;
      flex-shrink: 0 !important;
      font-size: 0.875rem !important;
      padding: 0.5rem 1rem !important;
    }
    
    #category-modal .category-options,
    #tag-modal .tag-options {
      display: flex !important;
      flex-wrap: wrap !important;
      gap: 0.5rem !important;
      justify-content: flex-start !important;
      align-items: flex-start !important;
    }
    
    /* モーダル全体の幅を拡大 */
    #category-modal .modal-content,
    #tag-modal .modal-content {
      width: 90vw !important;
      max-width: 800px !important;
      min-width: 600px !important;
    }
    
    /* モーダルボディのパディング調整 */
    #category-modal .modal-body,
    #tag-modal .modal-body {
      padding: 1.5rem !important;
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      #category-modal .modal-content,
      #tag-modal .modal-content {
        width: 95vw !important;
        min-width: 320px !important;
        max-width: none !important;
      }
      
      #category-modal .category-option,
      #tag-modal .tag-option {
        min-width: 80px !important;
        font-size: 0.8rem !important;
        padding: 0.6rem 0.8rem !important;
      }
    }
    
    @media (max-width: 480px) {
      #category-modal .category-option,
      #tag-modal .tag-option {
        min-width: 70px !important;
        font-size: 0.75rem !important;
        padding: 0.5rem 0.6rem !important;
      }
    }
    
    /* カテゴリーとタグのレイアウト調整 - 1列レイアウト */
    .category-tags-field {
      margin-bottom: 1rem;
    }
    
    .category-tags-row {
      display: flex;
      flex-direction: row;
      gap: 0.1rem;
      align-items: stretch;
    }
    
    .category-section,
    .tags-section {
      flex: 1;
      min-width: 0;
    }
    
    .category-input-wrapper,
    .tag-input-wrapper {
      margin-bottom: 0.1rem;
      height: 44px !important;
      min-height: 44px !important;
      max-height: 44px !important;
      overflow: hidden;
    }
    
    .custom-categories,
    .custom-tags {
      margin-top: 0.1rem;
      min-height: 1rem;
    }
    
    /* ボタンの完全統一 - 最高詳細度で強制 */
    .category-tags-field .category-section .category-input-wrapper .category-select-btn,
    .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn {
      width: 100% !important;
      height: 44px !important;
      min-height: 44px !important;
      max-height: 44px !important;
      display: flex !important;
      align-items: center !important;
      justify-content: space-between !important;
      padding: 0 12px !important;
      margin: 0 !important;
      border: 2px solid var(--border-medium) !important;
      border-radius: var(--radius-md) !important;
      background: var(--bg-secondary) !important;
      color: var(--text-primary) !important;
      cursor: pointer !important;
      transition: all var(--transition-normal) !important;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2) !important;
      box-sizing: border-box !important;
      font-size: var(--font-size-base) !important;
      line-height: 1 !important;
      vertical-align: top !important;
      overflow: hidden !important;
      white-space: nowrap !important;
      text-overflow: ellipsis !important;
    }
    
    .category-tags-field .category-section .category-input-wrapper .category-select-btn:hover,
    .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn:hover {
      border-color: var(--accent-primary) !important;
      box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1) !important;
    }
    
    .category-tags-field .category-section .category-input-wrapper .category-select-btn span,
    .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn span {
      flex: 1 !important;
      text-align: left !important;
      color: var(--text-primary) !important;
      line-height: 1 !important;
      margin: 0 !important;
      padding: 0 !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      word-wrap: normal !important;
      word-break: normal !important;
      overflow-wrap: normal !important;
      min-width: 0 !important;
    }
    
    .category-tags-field .category-section .category-input-wrapper .category-select-btn i,
    .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn i {
      color: var(--text-muted) !important;
      transition: transform 0.2s !important;
      line-height: 1 !important;
      margin: 0 !important;
      padding: 0 !important;
      flex-shrink: 0 !important;
      width: 16px !important;
      text-align: center !important;
    }
    
    .category-tags-field .category-section .category-input-wrapper .category-select-btn.open i,
    .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn.open i {
      transform: rotate(180deg) !important;
    }
    
    /* レスポンシブ対応 - 常に一行表示 */
    @media (max-width: 768px) {
      .category-tags-row {
        gap: 0.1rem;
      }
      
      .category-input-wrapper,
      .tag-input-wrapper {
        height: 40px !important;
        min-height: 40px !important;
        max-height: 40px !important;
      }
      
      .category-tags-field .category-section .category-input-wrapper .category-select-btn,
      .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn {
        height: 40px !important;
        min-height: 40px !important;
        max-height: 40px !important;
        padding: 0 10px !important;
        font-size: 0.9em !important;
      }
      
      .category-tags-field .category-section .category-input-wrapper .category-select-btn span,
      .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn span {
        font-size: 0.85em !important;
      }
    }
    
    @media (max-width: 480px) {
      .category-tags-row {
        gap: 0.1rem;
      }
      
      .category-input-wrapper,
      .tag-input-wrapper {
        height: 36px !important;
        min-height: 36px !important;
        max-height: 36px !important;
      }
      
      .category-tags-field .category-section .category-input-wrapper .category-select-btn,
      .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn {
        height: 36px !important;
        min-height: 36px !important;
        max-height: 36px !important;
        padding: 0 8px !important;
        font-size: 0.8em !important;
      }
      
      .category-tags-field .category-section .category-input-wrapper .category-select-btn span,
      .category-tags-field .tags-section .tag-input-wrapper .tag-select-btn span {
        font-size: 0.8em !important;
      }
    }

    /* 画像解析モーダル専用スタイル */
    #image-import-modal .image-upload-section {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 2px dashed var(--border-medium);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
      text-align: center;
      transition: all var(--transition-normal);
    }
    #image-import-modal .image-upload-section:hover {
      border-color: var(--accent-primary);
      background: var(--bg-tertiary);
    }
    #image-import-modal p {
      color: var(--text-primary);
      margin: 0.5rem 0;
    }
    #image-import-modal #previewArea {
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      border-radius: var(--radius-md);
      padding: var(--space-3);
      margin-top: var(--space-4);
    }
    #image-import-modal #previewImage {
      max-width: 100%;
      height: auto;
      border-radius: var(--radius-sm);
    }
    #image-import-modal #analyzeButton {
      margin-top: var(--space-3);
    }
    #image-import-modal #imageMessageArea {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-radius: var(--radius-sm);
      padding: var(--space-2);
    }
    
    /* カスタムカテゴリー削除ボタンのスタイル */
    .custom-category {
      padding-right: 8px !important;
    }
    
    .category-delete-btn {
      opacity: 0.7;
      transition: opacity 0.2s ease;
      min-width: auto !important;
      width: auto !important;
      height: 20px !important;
      line-height: 1 !important;
    }
    
    .category-delete-btn:hover {
      opacity: 1;
      background: #dc3545 !important;
      color: white !important;
    }
    
    .custom-category:hover .category-delete-btn {
      opacity: 0.9;
    }
    
    /* 読み込みポップアップ */
    #loadingPopup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(4px);
    }
    
    #loadingContent {
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: var(--space-6);
      border-radius: var(--radius-xl);
      text-align: center;
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border-medium);
      min-width: 300px;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--border-light);
      border-top: 4px solid var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-size: var(--font-size-lg);
      font-weight: 600;
      margin-bottom: var(--space-2);
    }
    
    .loading-subtext {
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
      opacity: 0.8;
    }
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    .image-upload-section {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      margin: 20px 0;
      background: #f9f9f9;
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }
    .image-upload-section.dragover {
      border-color: #007bff;
      background: #f0f8ff;
    }
    .image-preview {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      margin: 10px 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .loading-message {
      color: #007bff;
      font-style: italic;
      margin: 10px 0;
    }
    .error-message {
      color: #dc3545;
      background: #f8d7da;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .success-message {
      color: #155724;
      background: #d4edda;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    
    /* 画像解析メッセージスタイル */
    .error-message {
      background-color: #fee;
      color: #c33;
      border: 1px solid #fcc;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    
    .success-message {
      background-color: #efe;
      color: #363;
      border: 1px solid #cfc;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    
    .loading-message {
      background-color: #eef;
      color: #336;
      border: 1px solid #ccf;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }

    .ai-provider-selector.ai-provider-selector--compact {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid var(--border-medium);
      border-radius: var(--radius-md);
      background: var(--bg-secondary);
    }

    .ai-provider-selector--compact .ai-provider-toggle {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .ai-provider-selector--compact .ai-provider-btn {
      flex: 1 1 140px;
      min-width: 120px;
      border: 2px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.15rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .ai-provider-selector--compact .ai-provider-btn.selected {
      border-color: var(--accent-primary);
      background: rgba(255, 107, 53, 0.08);
      box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.1);
    }

    .ai-provider-selector--compact .ai-provider-btn:hover {
      border-color: var(--accent-primary);
    }

    .ai-provider-selector--compact .ai-provider-name {
      font-weight: 600;
    }

    .ai-provider-selector--compact .ai-provider-meta {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .ai-provider-selector--compact .ai-provider-hint {
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .image-message-with-icon {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .image-message-icon {
      width: 28px;
      height: 28px;
      object-fit: contain;
    }
    
    /* 画像プレビュースタイル */
    .image-preview {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    /* アップロードエリアスタイル */
    .image-upload-section {
      text-align: center;
      padding: 2rem;
      border: 2px dashed #ccc;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    
    .image-upload-section:hover {
      border-color: #999;
      background-color: #f5f5f5;
    }
    
    /* AI Modal Styles */
    .genre-btn {
      margin: 5px;
      padding: 8px 16px;
      border: 1px solid #ddd;
      background: white;
      cursor: pointer;
      border-radius: 4px;
    }
    .genre-btn.selected {
      background: #007bff;
      color: white;
    }
    .menu-suggestion {
      border: 1px solid #ddd;
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .menu-suggestion:hover {
      border-color: #007bff;
      background: #f8f9ff;
    }
    .menu-suggestion.selected {
      border-color: #007bff;
      background: #e3f2fd;
    }
    .menu-suggestion h4 {
      margin: 0 0 8px 0;
      color: #333;
    }
    .menu-suggestion p {
      margin: 0;
      color: #666;
      font-size: 0.9em;
    }
    .loading-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007bff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Recipe preview background fix */
    #recipe-preview {
      background: #f8f9fa;
      color: #333;
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      position: relative;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .azure-usage-display {
      font-size: 0.75rem;
      color: #fff;
      text-align: right;
      line-height: 1.3;
      min-width: 150px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
    }

    .azure-usage-display small {
      color: inherit;
      font-size: 0.75rem;
    }
  </style>
</head>
<body>

  <header class="app-header">
    <h1 class="brand">レシピ編集</h1>
    <div class="header-actions">
      <div id="azure-usage-display" class="azure-usage-display"></div>
      <a href="../index.html" class="btn ghost">ホーム</a>
      <button class="btn secondary js-ai-save-options" style="display: none;">AI創作完了</button>
      <button class="btn primary js-save">保存する</button>
    </div>
  </header>

  <main class="container">
    <form id="editForm" class="panel">
      
      <div class="field">
        <!-- URL読み込み/画像解析/画像アップロードボタンを料理名の上に配置 -->
        <div class="recipe-action-buttons">
          <button type="button" class="btn secondary small" id="urlImportBtn" title="URLからレシピを読み込み">
            <i class="fas fa-link"></i> URL読み込み
          </button>
          <button type="button" class="btn secondary small" id="imageImportBtn" title="画像からレシピを抽出">
            <i class="fas fa-camera"></i> 画像解析
          </button>
          <button type="button" class="btn secondary small" id="imageUploadBtn" title="画像をアップロード">
            <i class="fas fa-image"></i> 画像アップロード
          </button>
          <input type="file" id="recipeImageFile" accept="image/*" style="display:none;">
        </div>
        
        <label for="title">料理名</label>
        <input id="title" name="title" class="input" required />
        
        <!-- 翻訳入力テーブル -->
        <div class="translation-section" style="margin-top: 1rem;">
          <label style="font-size: 0.9em; margin-bottom: 0.5rem; display: block; color: var(--text-primary);">翻訳名（任意）</label>
          <div class="translation-table-container" style="background: var(--bg-secondary); border: 1px solid var(--border-medium); border-radius: 6px; padding: 1rem;">
            <table class="translation-table" style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr style="background: var(--bg-tertiary);">
                  <th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-medium); font-size: 0.85em; color: var(--text-primary);">言語</th>
                  <th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-medium); font-size: 0.85em; color: var(--text-primary);">翻訳名</th>
                  <th style="padding: 0.5rem; text-align: center; border-bottom: 1px solid var(--border-medium); font-size: 0.85em; width: 60px; color: var(--text-primary);">操作</th>
                </tr>
              </thead>
              <tbody id="translationTableBody">
                <!-- 翻訳行は動的に追加 -->
              </tbody>
            </table>
            <button type="button" id="addTranslationBtn" class="btn ghost small" style="margin-top: 0.5rem;">＋ 翻訳を追加</button>
          </div>
        </div>
      </div>
      <div class="field category-tags-field">
        <div class="category-tags-row">
          <div class="category-section">
            <div class="category-input-wrapper">
              <button type="button" id="categorySelectBtn" class="category-select-btn">
                <span id="selectedCategoryText">カテゴリーを選択</span>
                <i class="fas fa-chevron-down"></i>
              </button>
            </div>
            <div id="selectedCategories" class="selected-categories"></div>
            <div id="customCategories" class="custom-categories"></div>
          </div>
          <div class="tags-section">
            <div class="tag-input-wrapper">
              <button type="button" id="tagSelectBtn" class="tag-select-btn">
                <span id="selectedTagsText">タグを選択</span>
                <i class="fas fa-chevron-down"></i>
              </button>
            </div>
            <div id="selectedTags" class="selected-tags"></div>
            <div id="customTags" class="custom-tags"></div>
          </div>
        </div>
      </div>
      <div class="field servings-field">
        <label for="servings">出来上がり人数</label>
        <div class="servings-input-wrapper">
          <input id="servings" name="servings" class="input" type="number" min="1" max="20" placeholder="例: 4" />
          <span class="servings-unit">人前</span>
          <div id="inlineRecipeImageContainer" style="position: relative; margin-left: 12px; display: inline-block;">
            <div id="noImagePlaceholder" style="height: 64px; width: 64px; border: 2px dashed #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; background: #f8f9fa; color: #6c757d; font-size: 12px; text-align: center; line-height: 1.2;">
              No image
            </div>
            <img id="inlineRecipeImageImg" src="" alt="レシピ画像" style="height: 64px; border-radius: 6px; display: none;" />
            <button id="deleteInlineImageBtn" type="button" class="btn ghost" style="position: absolute; top: -8px; right: -8px; background: rgba(220,53,69,0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; display: none; align-items: center; justify-content: center; font-size: 12px; cursor: pointer;" title="画像を削除">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <div class="servings-actions">
          <button type="button" class="btn ghost small" id="adjustServingsBtn">人数に応じて材料量を調整</button>
        </div>
      </div>
      <div class="field source-url-field">
        <label for="sourceUrl">参考URL</label>
        <div class="url-input-container">
          <input id="sourceUrl" name="sourceUrl" type="url" class="input" placeholder="https://example.com/recipe/..." />
          <button type="button" id="urlImportFromFieldBtn" class="btn primary small" style="margin-left: 0.5rem;">
            <i class="fas fa-download"></i> URLから取り込み
          </button>
        </div>
        <small style="color: #666; font-size: 0.9em;">URL取り込みで自動入力されます（手動編集も可能）</small>
      </div>
      <div class="field notes-field">
        <label for="notes">メモ・コツ</label>
        <textarea id="notes" name="notes" class="input" rows="3"></textarea>
      </div>
       <div class="field">
        <label>材料</label>
        <div id="ingredientsEditor"></div>
        <div style="margin-top: 1rem; display: flex; gap: 0.75rem;">
            <button type="button" class="btn ghost small" id="addIng">＋ 材料を追加</button>
            <button type="button" class="btn primary small" id="ai-wizard-btn">✨ AIで創作</button>
        </div>
      </div>
      <div class="field">
        <label>作り方</label>
        <div id="stepsEditor"></div>
        <button type="button" class="btn ghost small" id="addStep" style="margin-top: 1rem;">＋ 手順を追加</button>
      </div>
      
      <!-- フォーム下部の保存ボタン -->
      <div class="field" style="margin-top: 2rem; padding-top: 2rem; border-top: 2px solid var(--border-medium);">
        <div style="display: flex; gap: 1rem; justify-content: center; align-items: center;">
          <a href="../index.html" class="btn ghost" style="min-width: 150px;">
            <i class="fas fa-arrow-left"></i> キャンセル
          </a>
          <button type="button" class="btn primary js-save-bottom" style="min-width: 200px; font-size: 1.1rem; padding: 0.75rem 2rem;">
            <i class="fas fa-save"></i> 保存する
          </button>
        </div>
      </div>
    </form>
  </main>
  
  <!-- フローティング保存ボタン（常に表示） -->
  <button type="button" class="floating-save-btn js-save-floating" title="レシピを保存">
    <i class="fas fa-save"></i>
    <span>保存</span>
  </button>
  
  <style>
    /* フローティング保存ボタン */
    .floating-save-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, #ff6b35, #ff5722);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 15px 30px;
      font-size: 1.1rem;
      font-weight: 600;
      box-shadow: 0 4px 20px rgba(255, 107, 53, 0.5);
      cursor: pointer;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.3s ease;
      animation: pulse 2s infinite;
    }
    
    .floating-save-btn:hover {
      background: linear-gradient(135deg, #ff5722, #f4511e);
      transform: translateY(-3px);
      box-shadow: 0 6px 25px rgba(255, 107, 53, 0.7);
    }
    
    .floating-save-btn:active {
      transform: translateY(-1px);
    }
    
    .floating-save-btn i {
      font-size: 1.3rem;
    }
    
    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 4px 20px rgba(255, 107, 53, 0.5);
      }
      50% {
        box-shadow: 0 4px 30px rgba(255, 107, 53, 0.8);
      }
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .floating-save-btn {
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        font-size: 0.95rem;
      }
      
      .floating-save-btn i {
        font-size: 1.1rem;
      }
    }
    
    @media (max-width: 480px) {
      .floating-save-btn {
        bottom: 15px;
        right: 15px;
        padding: 10px 15px;
        font-size: 0.9rem;
      }
      
      .floating-save-btn span {
        display: none;
      }
      
      .floating-save-btn {
        border-radius: 50%;
        width: 60px;
        height: 60px;
        padding: 0;
        justify-content: center;
      }
      
      .floating-save-btn i {
        font-size: 1.5rem;
        margin: 0;
      }
    }
  </style>
  
  <!-- URL読み込みモーダル -->
  <div id="url-import-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">URLからレシピを読み込み</h2>
        <button id="url-import-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="field">
          <label for="urlInput">レシピサイトのURL</label>
          <input id="urlInput" type="url" class="input" placeholder="https://example.com/recipe/..." />
        </div>

      </div>
      <div class="modal-footer">
        <button id="urlImportCancelBtn" class="btn ghost">キャンセル</button>
        <button id="urlImportConfirmBtn" class="btn primary">読み込み開始</button>
      </div>
    </div>
  </div>

  <!-- 画像解析モーダル -->
  <div id="image-import-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">画像からレシピを抽出</h2>
        <button id="image-import-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="image-upload-section" id="uploadArea">
          <i class="fas fa-cloud-upload-alt" style="font-size: 3rem; color: #666; margin-bottom: 1rem;"></i>
          <p>レシピ画像をアップロードしてください</p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button type="button" id="fileSelectBtn" class="btn primary">
              <i class="fas fa-folder-open"></i> ファイルから選択
            </button>
            <button type="button" id="cameraBtn" class="btn secondary">
              <i class="fas fa-camera"></i> カメラで撮影
            </button>
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <input type="file" id="cameraInput" accept="image/*" capture="user" style="display: none;">
        </div>
        
        <div id="previewArea" style="display: none; text-align: center; margin-top: 1rem;">
          <img id="previewImage" class="image-preview" alt="プレビュー" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
          <div style="margin-top: 1rem;">
            <button type="button" id="analyzeButton" class="btn" type="button">
              <i class="fas fa-search"></i> 解析してレシピを抽出
            </button>
            <button type="button" id="clearImageButton" class="btn ghost">
              <i class="fas fa-trash"></i> クリア
            </button>
          </div>
        </div>
        
        <div id="imageMessageArea" style="margin-top: 1rem;"></div>
      </div>
      <div class="modal-footer">
        <button id="imageImportCancelBtn" class="btn ghost" type="button">閉じる</button>
      </div>
    </div>
  </div>

  <!-- ローディングポップアップ -->
  <div id="loadingPopup">
    <div id="loadingContent">
      <div class="loading-spinner"></div>
      <div class="loading-text">画像を解析中...</div>
      <div class="loading-subtext">AIがレシピを抽出しています。しばらくお待ちください。</div>
    </div>
  </div>
  
  <!-- カテゴリー選択モーダル -->
  <div id="category-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">カテゴリーを選択（複数選択可能）</h2>
        <button id="category-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="selected-categories-preview" id="selected-categories-preview" style="margin-bottom: 1rem; padding: 0.75rem; background: #e3f2fd; border: 1px solid #bbdefb; border-radius: 6px; min-height: 2.5rem;">
          <div class="selected-categories-list" id="selected-categories-list" style="color: #1565c0; font-weight: 500;"></div>
        </div>
        <div class="category-list">
          <div class="category-group">
            <h3 class="category-group-title">基本カテゴリー</h3>
            <div class="category-options" id="category-options">
              <!-- データベースから動的に読み込み -->
            </div>
          </div>
          <div class="category-group" id="custom-category-group" style="display: none;">
            <h3 class="category-group-title">カスタムカテゴリー</h3>
            <div class="category-options" id="custom-category-options">
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button id="add-new-category-btn" class="btn ghost">
            <i class="fas fa-plus"></i>
            新しいカテゴリーを追加
          </button>
          <div class="modal-footer-actions">
            <button id="category-ok-btn" class="btn primary">OK</button>
            <button id="category-cancel-btn" class="btn ghost">キャンセル</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- タグ選択モーダル -->
  <div id="tag-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">タグを選択</h2>
        <button id="tag-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="tag-list">
          <div class="tag-group">
            <h3 class="tag-group-title">利用可能なタグ</h3>
            <div class="tag-options" id="tag-options">
              <!-- データベースから動的に読み込み -->
            </div>
          </div>
          <div class="tag-group" id="custom-tag-group" style="display: none;">
            <h3 class="tag-group-title">カスタムタグ</h3>
            <div class="tag-options" id="custom-tag-options">
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button id="add-new-tag-btn" class="btn ghost">
            <i class="fas fa-plus"></i>
            新しいタグを追加
          </button>
          <div class="modal-footer-actions">
            <button id="tag-ok-btn" class="btn primary">OK</button>
            <button id="tag-cancel-btn" class="btn ghost">キャンセル</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- タグ削除ボタンのスタイル -->
  <style>
    .custom-tag {
      position: relative;
      padding-right: 30px !important;
    }
    
    .tag-delete-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #ff4757;
      cursor: pointer;
      font-size: 12px;
      padding: 2px;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }
    
    .tag-delete-btn:hover {
      background-color: #ff4757;
      color: white;
    }
  </style>

  <!-- URL読み込み中アニメーション用スタイル -->
  <style>
    .loading-popup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .loading-content {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      max-width: 300px;
      width: 90%;
    }

    .loading-content h3 {
      margin: 1rem 0 0.5rem 0;
      color: #333;
      font-size: 1.2rem;
    }

    .loading-content p {
      margin: 0;
      color: #666;
      font-size: 0.9rem;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--accent-primary, #ff6b35);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* AI ルセット創作アシスタント モーダルスタイル */
    #ai-modal .modal-content {
      background: #2c3e50;
      color: #ecf0f1;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    #ai-modal .modal-header {
      background: #34495e;
      border-bottom: 1px solid #4a5f7a;
      padding: 1rem;
    }
    
    #ai-modal .modal-title {
      color: #ecf0f1;
      margin: 0;
      font-size: 1.2rem;
    }
    
    #ai-modal .modal-body {
      padding: 1.5rem;
      background: #2c3e50;
    }
    
    #ai-modal .step-title {
      color: #ecf0f1;
      font-weight: bold;
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }
    
    #ai-modal .genre-selection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }
    
    #ai-modal .genre-btn {
      background: #5a6f8a;
      border: 2px solid #6c7b95;
      color: #ecf0f1;
      padding: 0.75rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }
    
    #ai-modal .genre-btn:hover {
      background: #6c7b95;
      border-color: #7d8ba0;
    }
    
    #ai-modal .genre-btn.selected {
      background: #3498db;
      border-color: #3498db;
      color: white;
    }
    
    #ai-modal .field label {
      color: #ecf0f1;
      font-weight: 500;
    }
    
    #ai-modal .input {
      background: #34495e;
      border: 1px solid #4a5f7a;
      color: #ecf0f1;
    }
    
    #ai-modal .input:focus {
      border-color: #3498db;
      box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25);
    }
    
    #ai-modal .input::placeholder {
      color: #bdc3c7;
    }
    
    #ai-modal .modal-footer {
      background: #34495e;
      border-top: 1px solid #4a5f7a;
      padding: 1rem;
      text-align: right;
    }
    
    #ai-modal .btn {
      background: #3498db;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    #ai-modal .btn:hover {
      background: #2980b9;
    }
    
    #ai-modal .btn:disabled {
      background: #7f8c8d;
      cursor: not-allowed;
    }
    
    #ai-modal .btn.ghost {
      background: transparent;
      color: #bdc3c7;
      border: 1px solid #7f8c8d;
    }
    
    #ai-modal .btn.ghost:hover {
      background: #7f8c8d;
      color: white;
    }
    
    #ai-modal .menu-suggestions {
      max-height: 300px;
      overflow-y: auto;
    }
    
    #ai-modal .menu-item {
      background: #ffffff;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    #ai-modal .menu-item:not(.selected) {
      background: #ffffff;
    }
    
    #ai-modal .menu-item:hover {
      background: #f8f9fa;
      border-color: #ced4da;
    }
    
    #ai-modal .menu-item.selected {
      background: #27ae60;
      border-color: #2ecc71;
    }
    
    #ai-modal .menu-item h4 {
      color: #2c3e50;
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
      font-weight: bold;
    }
    
    #ai-modal .menu-item p {
      color: #34495e;
      margin: 0;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    
    #ai-modal .menu-item.selected h4 {
      color: #ffffff;
    }
    
    #ai-modal .menu-item.selected p {
      color: #ffffff;
    }
    
    /* 例ボタンのスタイル */
    #ai-modal .example-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }
    
    #ai-modal .example-btn {
      background: #34495e;
      border: 1px solid #4a5f7a;
      color: #ecf0f1;
      padding: 0.3rem 0.6rem;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.75rem;
      white-space: nowrap;
      min-width: fit-content;
    }
    
    #ai-modal .example-btn:hover {
      background: #4a5f7a;
      border-color: #5a6f8a;
    }
    
    #ai-modal .example-btn:active {
      background: #3498db;
      border-color: #3498db;
    }
    
    #ai-modal .example-btn.selected {
      background: #3498db !important;
      border-color: #3498db !important;
      color: #ffffff !important;
    }
    
    /* 翻訳メニュー名のスタイル */
    #ai-modal .translated-menu-name {
      font-size: 0.8em;
      color: #b0b0b0;
      font-style: italic;
      margin-top: 0.25rem;
      margin-bottom: 0.5rem;
    }

    /* 翻訳表示モードのスタイル */
    .translation-display-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      border-radius: 8px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .translation-mode-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-medium);
    }

    .mode-label {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.9rem;
    }

    .edit-mode-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .translation-display {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--bg-primary);
      border-radius: 6px;
      border-left: 4px solid var(--primary-color);
    }

    .translation-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .language-label {
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .language-code {
      font-size: 0.7rem;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }

    .translated-title {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      line-height: 1.3;
    }

    /* スクリーンショット通りの2言語レイアウト */
    .bilingual-mode {
      max-width: none;
    }

    .bilingual-recipe-layout {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* メインタイトル部分 */
    .main-title-section {
      margin-bottom: 2rem;
    }

    .translated-main-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0 0 0.5rem 0;
      line-height: 1.2;
    }

    .original-subtitle {
      font-size: 1rem;
      color: var(--text-secondary);
      font-weight: 400;
    }

    /* 材料セクション */
    .ingredients-section {
      background: var(--bg-primary);
      border-radius: 12px;
      padding: 2rem;
      border: 1px solid var(--border-medium);
      margin-bottom: 2rem;
    }

    /* セクションヘッダー（青いライン付き） */
    .section-header-with-line {
      border-left: 4px solid #007bff;
      padding-left: 1rem;
      margin-bottom: 1.5rem;
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    /* オリジナルセクション見出し */
    .original-section-header {
      margin: 2rem 0 1rem 0;
    }

    .original-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 0;
    }

    /* テーブルスタイル */
    .ingredients-table-container {
      margin: 1rem 0;
    }

    .ingredients-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-secondary);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .ingredients-table thead {
      background: #495057;
      color: white;
    }

    .ingredients-table th {
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .ingredients-table th:first-child {
      width: 60px;
      text-align: center;
    }

    .ingredients-table th:nth-child(3) {
      width: 120px;
      text-align: right;
    }

    .ingredients-table th:last-child {
      width: 80px;
      text-align: center;
    }

    .ingredients-table tbody tr {
      border-bottom: 1px solid var(--border-medium);
    }

    .ingredients-table tbody tr:hover {
      background: rgba(0,123,255,0.05);
    }

    .ingredients-table td {
      padding: 0.8rem 1rem;
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .ingredients-table td:first-child {
      text-align: center;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .ingredients-table td:nth-child(3) {
      text-align: right;
      font-weight: 600;
    }

    .ingredients-table td:last-child {
      text-align: center;
      font-weight: 500;
      color: var(--text-secondary);
    }

    /* 翻訳テーブルと原文テーブルの区別 */
    .translated-ingredients thead {
      background: #007bff;
    }

    .original-ingredients thead {
      background: #6c757d;
    }

    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .translated-main-title {
        font-size: 1.5rem;
      }

      .ingredients-section {
        padding: 1rem;
      }

      .ingredients-table th,
      .ingredients-table td {
        padding: 0.6rem 0.5rem;
        font-size: 0.8rem;
      }
    }

    /* API選択ポップアップのスタイル */
    .api-options {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .api-option {
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      background-color: #ffffff;
    }

    .api-option:hover {
      border-color: #007bff;
      background-color: #f8f9fa;
    }

    .api-option.selected {
      border-color: #007bff;
      background-color: #e3f2fd;
    }

    .api-option-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .api-option-header input[type="radio"] {
      margin: 0;
    }

    .api-option-header label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      margin: 0;
      flex: 1;
      color: #333;
      font-weight: 500;
    }

    .api-status {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .api-status.available {
      background-color: #d4edda;
      color: #155724;
    }

    .api-status.unavailable {
      background-color: #f8d7da;
      color: #721c24;
    }

    .api-status.checking {
      background-color: #fff3cd;
      color: #856404;
    }

    .api-description {
      margin-left: 1.5rem;
    }

    .api-description p {
      margin: 0 0 0.25rem 0;
      color: #444;
      font-weight: 400;
    }

    .api-description small {
      color: #666;
      font-size: 0.85rem;
      font-weight: 400;
    }

    .url-input-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
  </style>

  <div id="ai-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">✨ AI ルセット創作アシスタント</h2>
        <button id="modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div id="modal-body" class="modal-body">
        <div id="ai-step-1" style="display: block;">
          <p class="step-title">1. 料理のジャンルを選択</p>
          <div class="genre-selection">
            <button class="genre-btn" data-genre="フレンチ">フレンチ</button>
            <button class="genre-btn" data-genre="イタリアン">イタリアン</button>
            <button class="genre-btn" data-genre="和食">和食</button>
            <button class="genre-btn" data-genre="中華">中華</button>
            <button class="genre-btn" data-genre="スパニッシュ">スパニッシュ</button>
            <button class="genre-btn" data-genre="ドイツ">ドイツ</button>
            <button class="genre-btn" data-genre="創作料理">創作料理</button>
            <button class="genre-btn" data-genre="デザート">デザート</button>
            <button class="genre-btn" data-genre="パン">パン</button>
          </div>
          <div class="field">
            <label for="ai-custom-request" style="font-size: 0.8em; margin-bottom: 0.5rem;">追加の希望 (任意)</label>
            <div class="example-buttons" style="margin-bottom: 0.5rem;">
              <button type="button" class="example-btn" data-example="プロ向けの高度な技術">高度な技術</button>
              <button type="button" class="example-btn" data-example="繊細な味のバランス">味のバランス</button>
              <button type="button" class="example-btn" data-example="プレゼンテーション重視">プレゼンテーション</button>
              <button type="button" class="example-btn" data-example="季節感を活かした食材">季節感</button>
              <button type="button" class="example-btn" data-example="伝統的な技法とモダンなアレンジ">伝統技法</button>
              <button type="button" class="example-btn" data-example="モダンなメニューを考えてもらう">モダン</button>
              <button type="button" class="example-btn" data-example="ワインとのペアリングを考慮">ワインペアリング</button>
              <button type="button" class="example-btn" data-example="複雑な味の層を作る">味の層</button>
              <button type="button" class="example-btn" data-example="分子ガストロノミー要素">分子ガストロノミー</button>
              <button type="button" class="example-btn" data-example="テクスチャーの対比">テクスチャー</button>
              <button type="button" class="example-btn" data-example="地元食材を最大限活用">地元食材</button>
              <button type="button" class="example-btn" data-example="サステナブルな調理法">サステナブル</button>
            </div>
            <textarea id="ai-custom-request" class="input" rows="2" placeholder="カスタムの希望を入力するか、上記の例から選択してください"></textarea>
          </div>
          <div class="modal-footer">
            <button id="get-suggestions-btn" class="btn primary" disabled>メニュー案を創作</button>
          </div>
        </div>
        <div id="ai-step-2" style="display: none;">
          <p class="step-title">2. メニューを選択</p>
          <div id="menu-suggestions" class="menu-suggestions"></div>
          <div class="modal-footer">
            <button id="generate-full-recipe-btn" class="btn primary" disabled>このメニューでルセットを生成</button>
          </div>
        </div>
        <div id="ai-step-3" style="display: none;">
            <p class="step-title">3. 内容を確認して反映</p>
            <div id="recipe-preview" style="white-space: pre-wrap; background: var(--bg-secondary); padding: 1rem; border-radius: 0.5rem; max-height: 40vh; overflow-y: auto; border: 1px solid var(--border-medium); color: var(--text-primary); font-size: var(--font-size-sm); line-height: 1.5;"></div>
            <div class="modal-footer">
              <button id="apply-recipe-btn" class="btn primary">フォームに反映する</button>
            </div>
        </div>
        <div id="ai-loading" style="display: none;">
          <div class="loading-spinner"></div>
        </div>
      </div>
    </div>
  </div>


  <!-- URL読み込み中ポップアップ -->
  <div id="urlLoadingPopup" class="loading-popup" style="display: none;">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <h3 class="loading-title">レシピを読み込み中...</h3>
      <p class="loading-message">ウェブサイトからレシピ情報を取得しています</p>
      <div class="loading-details" style="margin-top: 1rem; font-size: 0.9rem; color: #666;">
        <p class="loading-status">準備中...</p>
      </div>
    </div>
  </div>

  <!-- AI創作完了保存選択モーダル -->
  <div id="ai-save-options-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2 class="modal-title">AI創作が完了しました！</h2>
      </div>
      <div class="modal-body" style="text-align: center; padding: 2rem;">
        <p style="margin-bottom: 2rem; font-size: 1.1rem; color: var(--text-secondary);">
          レシピの保存方法を選択してください
        </p>
        <div style="display: flex; gap: 1rem; justify-content: center;">
          <button id="ai-save-overwrite" class="btn primary" style="min-width: 150px;">
            <i class="fas fa-save"></i>
            上書きする
          </button>
          <button id="ai-save-new" class="btn secondary" style="min-width: 150px;">
            <i class="fas fa-plus"></i>
            新規で登録
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 追加要望入力モーダル -->
  <div id="additional-request-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2 class="modal-title">追加の要望</h2>
      </div>
      <div class="modal-body" style="padding: 2rem;">
        <p style="margin-bottom: 1rem; font-size: 1rem; color: var(--text-secondary);">
          追加の要望があれば入力してください（空欄でもOK）
        </p>
        <div style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
          <strong>例：</strong><br>
          ・もっとヘルシーな料理<br>
          ・簡単に作れるもの<br>
          ・見た目が美しい料理<br>
          ・スパイシーな味付け<br>
          ・和風のアレンジ
        </div>
        <textarea id="additional-request-input" placeholder="追加の要望を入力してください..." style="width: 100%; min-height: 100px; padding: 1rem; border: 1px solid var(--border-color); border-radius: 8px; font-family: inherit; font-size: 1rem; resize: vertical; background: var(--bg-primary); color: var(--text-primary);"></textarea>
      </div>
      <div class="modal-footer" style="display: flex; gap: 1rem; justify-content: flex-end;">
        <button id="additional-request-cancel" class="btn secondary">キャンセル</button>
        <button id="additional-request-confirm" class="btn primary">提案を生成</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../config.js"></script>
  <script src="../assets/js/settings-manager.js"></script>
  
  <!-- 外部JavaScriptファイル -->
  <script src="../assets/js/utils.js?v=20250115"></script>
  <script src="../assets/js/database.js?v=20250115"></script>
  <script src="../assets/js/ui-components.js?v=20250115"></script>
    <script src="../assets/js/proxy-manager.js?v=20250115"></script>
    <script src="../assets/js/recipe-edit.js?v=20250115"></script>
    <script src="../assets/js/ai-config.js?v=20250923"></script>
    <script src="../assets/js/groq-analyzer.js?v=20250923"></script>
    <script src="../assets/js/chatgpt-analyzer.js?v=20250930"></script>
    <script src="../assets/js/ai-analyzer-manager.js?v=20250923"></script>
    <script src="../assets/js/translation.js?v=20250116dual"></script>
    <script src="../assets/js/app-edit.js?v=20250917save-fix" defer></script>

  <script>

  function setupApiUsageHooks() {
    if (typeof window === 'undefined') {
      return;
    }

    if (typeof window.__apiUsageInvokeInProgress === 'undefined') {
      window.__apiUsageInvokeInProgress = false;
    }

    if (window.sb?.functions?.invoke && !window.__apiUsageInvokePatched) {
      const originalInvoke = window.sb.functions.invoke.bind(window.sb.functions);
      window.sb.functions.invoke = async function(functionName, invokeOptions) {
        const previousFlag = window.__apiUsageInvokeInProgress;
        window.__apiUsageInvokeInProgress = true;
        try {
          const result = await originalInvoke(functionName, invokeOptions);
          if (!result?.error) {
            if (functionName === 'call-groq-api') {
              window.ApiUsageManager?.increment('groq');
            } else if (functionName === 'call-openai-api') {
              window.ApiUsageManager?.increment('chatgpt');
            }
          }
          return result;
        } finally {
          window.__apiUsageInvokeInProgress = previousFlag;
        }
      };
      window.__apiUsageInvokePatched = true;
    }

    if (!window.__apiUsageFetchPatched && typeof window.fetch === 'function') {
      const originalFetch = window.fetch.bind(window);
      window.fetch = async (...args) => {
        const response = await originalFetch(...args);
        try {
          if (!window.__apiUsageInvokeInProgress && response && response.ok) {
            const request = args[0];
            const url = typeof request === 'string' ? request : request?.url || '';
            if (url.includes('/functions/v1/call-groq-api')) {
              window.ApiUsageManager?.increment('groq');
            } else if (url.includes('/functions/v1/call-openai-api')) {
              window.ApiUsageManager?.increment('chatgpt');
            }
          }
        } catch (hookError) {
          console.warn('⚠️ API使用数の追跡に失敗しました:', hookError);
        }
        return response;
      };
      window.__apiUsageFetchPatched = true;
    }
  }

  if (typeof window !== 'undefined') {
    window.setupApiUsageHooks = setupApiUsageHooks;
  }

  // 画像解析機能を独立して実行
  document.addEventListener('DOMContentLoaded', function() {
    if (window.AzureUsageManager && typeof window.AzureUsageManager.updateDisplay === 'function') {
      try {
        window.AzureUsageManager.updateDisplay();
      } catch (usageInitError) {
        console.warn('⚠️ Azure使用状況の初期化に失敗しました:', usageInitError);
      }
    }
    // AI解析プロバイダー選択UIを初期化
    if (window.aiConfig) {
      console.log('🔧 AI解析システムを初期化');
      
      // プロバイダー選択UIを表示
      setTimeout(() => {
        addAIProviderSelector();
      }, 300);
    }
    'use strict';
    
    const PROJECT_URL = 'https://nnbdzwrndqtsfzobknmj.supabase.co';
    const ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5uYmR6d3JuZHF0c2Z6b2Jrbm1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyMTkxNTQsImV4cCI6MjA3NTc5NTE1NH0.srlNmVFzw4w2d1tnp6gwZsBtXMJurpGDpFLe0bD0IYs';

    if (typeof supabase === 'undefined') {
      return;
    }
    // Reuse global client to avoid multiple GoTrueClient instances
    if (!window.sb) {
      window.sb = supabase.createClient(PROJECT_URL, ANON, {
        auth: {
          storageKey: 'app-main-11-edit',
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: false
        }
      });
    }
    const sb = window.sb;

    setupApiUsageHooks();


    async function runImport(url) {
        try {
            // URL取り込み元を記録してフィールドに表示
            const sourceUrlEl = document.getElementById('sourceUrl');
            if (sourceUrlEl) sourceUrlEl.value = url;
            
            // 直接Groq APIを使用してレシピ抽出
            const html = await fetchHTMLViaProxy(url);
            const recipeData = await callGroqAPI(html, url);
            const r = recipeData || {};
            const titleEl = document.getElementById('title');
            if (titleEl) titleEl.value = r.title || '';
            const notesEl = document.getElementById('notes');
            if (notesEl) notesEl.value = r.description || '';
            const ingredientsEditor = document.getElementById('ingredientsEditor');
            const addIngBtn = document.getElementById('addIng');
            if (ingredientsEditor) ingredientsEditor.innerHTML = '';
            (r.ingredientLines || []).forEach(line => {
                addIngBtn?.dispatchEvent(new Event('click'));
                const rows = ingredientsEditor?.querySelectorAll('.ingredient-row');
                const row  = rows?.[rows.length-1];
                const itemInput = row?.querySelector('.ingredient-item');
                if (itemInput) itemInput.value = line;
            });
            const stepsEditor = document.getElementById('stepsEditor');
            const addStepBtn = document.getElementById('addStep');
            if (stepsEditor) stepsEditor.innerHTML = '';
            (r.steps || []).forEach(text => {
                addStepBtn?.dispatchEvent(new Event('click'));
                const rows = stepsEditor?.querySelectorAll('.step-row .step-text');
                const el = rows?.[rows.length-1];
                if (el) el.value = text;
            });
        } catch (e) {
            // Error handling without debug logging
        }
    }
    // ===== 材料解析ユーティリティ =====
    function parseIngredientString(ingredientStr) {
      if (!ingredientStr) return { item: '', quantity: '', unit: '', price: '' };
      
      const str = ingredientStr.toString().trim();
      console.log(`🔍 OCR解析開始: "${str}"`);
      
      // パターン1: "材料名 分量単位 価格円" (例: "コンデンスミルク 1kg 1320円")
      const pattern1 = str.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s+(\d+)円$/);
      if (pattern1) {
        const result = {
          item: pattern1[1].trim(),
          quantity: pattern1[2].trim(),
          unit: pattern1[3].trim(),
          price: pattern1[4].trim()
        };
        console.log(`✅ OCRパターン1解析成功:`, result);
        return result;
      }
      
      // パターン2: "材料名 価格円" (例: "グラニュー糖 290円")
      const pattern2 = str.match(/^(.+?)\s+(\d+)円$/);
      if (pattern2) {
        const result = {
          item: pattern2[1].trim(),
          quantity: '',
          unit: '',
          price: pattern2[2].trim()
        };
        console.log(`✅ OCRパターン2解析成功:`, result);
        return result;
      }
      
      // 日本語の単位をチェック（大さじ、小さじ、カップ）
      const japaneseUnits = str.match(/^(.+?)\s+(大さじ|小さじ|カップ)([0-9\/\.]+)$/);
      if (japaneseUnits) {
        const result = {
          item: japaneseUnits[1].trim(),
          quantity: japaneseUnits[3].trim(),
          unit: japaneseUnits[2].trim(),
          price: ''
        };
        console.log(`✅ OCR日本語単位解析成功:`, result);
        return result;
      }
      
      // 分量フィールドに「大さじ2」のような形式が入った場合の処理
      const spoonUnits = str.match(/^(大さじ|小さじ|tbsp|tsp)([0-9\/\.]+)$/);
      if (spoonUnits) {
        const result = {
          item: '',
          quantity: spoonUnits[2].trim(),
          unit: spoonUnits[1].trim(),
          price: ''
        };
        console.log(`✅ OCRスプーン単位解析成功:`, result);
        return result;
      }
      
      // 分量フィールドに「大さじ2 材料名」のような形式が入った場合の処理
      const spoonWithItem = str.match(/^(大さじ|小さじ|tbsp|tsp)([0-9\/\.]+)\s+(.+)$/);
      if (spoonWithItem) {
        const result = {
          item: spoonWithItem[3].trim(),
          quantity: spoonWithItem[2].trim(),
          unit: spoonWithItem[1].trim(),
          price: ''
        };
        console.log(`✅ OCRスプーン+材料解析成功:`, result);
        return result;
      }
      
      // 数値 + 単位 + 材料名の形式
      const numUnitItem = str.match(/^([0-9\/\.]+)\s*([a-zA-Z]+|ml|g|mg|kg|個|本|枚|匙|杯|滴)\s+(.+)$/);
      if (numUnitItem) {
        const result = {
          item: numUnitItem[3].trim(),
          quantity: numUnitItem[1].trim(),
          unit: numUnitItem[2].trim(),
          price: ''
        };
        console.log(`✅ OCR数値+単位+材料解析成功:`, result);
        return result;
      }
      
      // 材料名 + 数値 + 単位の形式
      const itemNumUnit = str.match(/^(.+?)\s+([0-9\/\.]+)\s*([a-zA-Z]+|ml|g|mg|kg|個|本|枚|匙|杯|滴)$/);
      if (itemNumUnit) {
        const result = {
          item: itemNumUnit[1].trim(),
          quantity: itemNumUnit[2].trim(),
          unit: itemNumUnit[3].trim(),
          price: ''
        };
        console.log(`✅ OCR材料+数値+単位解析成功:`, result);
        return result;
      }
      
      // 曖昧な表現
      const vague = str.match(/^(.+?)\s+(適量|少々|お好みで|ひとつまみ|少し|ひとかけ)$/);
      if (vague) {
        const result = {
          item: vague[1].trim(),
          quantity: vague[2].trim(),
          unit: '',
          price: ''
        };
        console.log(`✅ OCR曖昧表現解析成功:`, result);
        return result;
      }
      
      // 分離できない場合は材料名としてそのまま返す
      const result = { item: str, quantity: '', unit: '', price: '' };
      console.log(`❌ OCR解析失敗、材料名のみ:`, result);
      return result;
    }

    // ===== 単位変換ユーティリティ =====
    function convertUnits(quantity, unit, itemName = '') {
      if (!quantity || !unit) return { quantity, unit };
      
      // 分数を処理（例: 1/2, 3/4など）
      let qty = 0;
      const quantityStr = quantity.toString().trim();
      if (quantityStr.includes('/')) {
        const fractionMatch = quantityStr.match(/(\d+)\/(\d+)/);
        if (fractionMatch) {
          const numerator = parseInt(fractionMatch[1]);
          const denominator = parseInt(fractionMatch[2]);
          qty = numerator / denominator;
          console.log(`📏 OCR分数変換: ${quantityStr} → ${qty}`);
        }
      } else {
        qty = parseFloat(quantityStr.replace(/[^\d\.]/g, '')) || 0;
      }
      const unitLower = unit.toString().toLowerCase().trim();
      const itemLower = itemName.toString().toLowerCase();
      
      // 液体系の材料判定（材料名と単位の両方で判断）
      const liquidItems = ['水', '油', '醤油', 'しょうゆ', '酒', '酢', 'みりん', '牛乳', 'だし', 'スープ', 'ソース', '出汁', 'だし汁', 'ワイン', 'ビール', 'ココナッツミルク', 'オリーブオイル', 'ごま油', 'サラダ油'];
      const isLiquid = liquidItems.some(liquid => itemLower.includes(liquid)) || 
                       unitLower.includes('ml') || unitLower.includes('リットル') || unitLower.includes('cc');
      
      // 大さじの変換（15ml/15g）
      if (unitLower.includes('大さじ') || unitLower.includes('おおさじ') || unitLower.includes('tbsp')) {
        return {
          quantity: (qty * 15).toString(),
          unit: isLiquid ? 'ml' : 'g'
        };
      }
      
      // 小さじの変換（5ml/5g）
      if (unitLower.includes('小さじ') || unitLower.includes('こさじ') || unitLower.includes('tsp')) {
        return {
          quantity: (qty * 5).toString(),
          unit: isLiquid ? 'ml' : 'g'
        };
      }
      
      // カップの変換（200ml）
      if (unitLower.includes('カップ') || unitLower.includes('cup')) {
        return {
          quantity: (qty * 200).toString(),
          unit: 'ml'
        };
      }
      
      // 1/2カップ、1/4カップなどの分数対応
      if (quantity.toString().includes('/') && (unitLower.includes('カップ') || unitLower.includes('cup'))) {
        const fractionMatch = quantity.toString().match(/(\d+)\/(\d+)/);
        if (fractionMatch) {
          const numerator = parseInt(fractionMatch[1]);
          const denominator = parseInt(fractionMatch[2]);
          const cupValue = (numerator / denominator) * 200;
          return {
            quantity: cupValue.toString(),
            unit: 'ml'
          };
        }
      }
      
      return { quantity, unit };
    }

    // ===== Vision API からの受け取り（ローカルストレージ / URLパラメータ） =====
    (async () => {
      try {
        // URLパラメータ優先（file:// や別オリジン対策）
        const params = new URLSearchParams(location.search);
        const paramData = params.get('data');
        if (paramData) {
          const json = decodeURIComponent(escape(atob(paramData)));
          const data = JSON.parse(json);
          await applyRecipeData(data);
          history.replaceState(null, '', location.pathname); // URLクリーン
        }

        const raw = localStorage.getItem('recipe_from_vision');
        if (raw) {
          const data = JSON.parse(raw);
          await applyRecipeData(data);
          // 1回だけ使う
          localStorage.removeItem('recipe_from_vision');
        }
      } catch (_) {}
    })();

    // ヘルパ: Vision APIのJSONをフォームに反映
    async function applyRecipeData(r) {
      console.log('📝 レシピデータをフォームに適用中:', r);
      
      try {
        const providerKey = (r.aiProvider || r.ai_provider || '').toString().toLowerCase();
        const providerCategoryMap = {
          groq: 'AI-Groq解析',
          chatgpt: 'AI-ChatGPT解析'
        };

        if (providerKey && providerCategoryMap[providerKey]) {
          const categoryLabel = providerCategoryMap[providerKey];
          window.selectedCategory = categoryLabel;
          const categoryText = document.getElementById('selectedCategoryText');
          if (categoryText) {
            categoryText.textContent = categoryLabel;
          }

          document.querySelectorAll('.category-option').forEach(option => {
            if (option.textContent.trim() === categoryLabel) {
              option.classList.add('selected');
            } else {
              option.classList.remove('selected');
            }
          });

          console.log('✅ カテゴリーをAIプロバイダーに基づき設定:', {
            provider: providerKey,
            category: categoryLabel
          });
        }
      } catch (categoryError) {
        console.warn('⚠️ AIプロバイダーカテゴリー設定に失敗:', categoryError);
      }
      
      // タイトル・説明・人数
      const titleEl = document.getElementById('title');
      if (titleEl) {
        titleEl.value = (r.title || '').toString();
        console.log('✅ タイトル設定完了:', r.title);
      }
      const notesEl = document.getElementById('notes');
      if (notesEl) {
        notesEl.value = (r.description || r.notes || '').toString();
        console.log('✅ 説明設定完了:', (r.description || r.notes || '').substring(0, 50) + '...');
      }
      const servingsEl = document.getElementById('servings');
      const srv = r.servings; 
      if (servingsEl && (srv || srv === 0)) {
        servingsEl.value = parseInt(srv || 0, 10) || '';
        console.log('✅ 人数設定完了:', srv);
      }

      // 材料
      const ingredientsEditor = document.getElementById('ingredientsEditor');
      const addIngBtn = document.getElementById('addIng');
      if (ingredientsEditor) ingredientsEditor.innerHTML = '';
      // 受け取るフォーマットのゆらぎを吸収
      let ingredients = [];
      if (Array.isArray(r.ingredients)) {
        ingredients = r.ingredients.map(x => {
          if (typeof x === 'string') return { item: x };
          return { 
            item: x.item || '', 
            quantity: x.quantity || '', 
            unit: x.unit || '',
            price: x.price || ''
          };
        });
      } else if (Array.isArray(r.ingredientLines)) {
        ingredients = r.ingredientLines.map(line => ({ item: line }));
      }

      console.log('🥗 材料処理開始:', ingredients);

      for (let i = 0; i < ingredients.length; i++) {
        const ing = ingredients[i];
        let parsedIng = { item: '', quantity: '', unit: '', price: '' };
        
        // 材料データの形式を確認
        if (ing.item && ing.quantity && ing.unit) {
          // 既に分離されている場合
          parsedIng = {
            item: ing.item,
            quantity: ing.quantity,
            unit: ing.unit,
            price: ing.price || ''
          };
        } else if (ing.item && !ing.quantity && !ing.unit) {
          // 材料名だけの場合、文字列解析を試行
          parsedIng = parseIngredientString(ing.item);
          console.log(`🔍 OCR材料解析: "${ing.item}" → ${JSON.stringify(parsedIng)}`);
        } else {
          // その他の場合
          parsedIng = {
            item: ing.item || '',
            quantity: ing.quantity || '',
            unit: ing.unit || '',
            price: ing.price || ''
          };
        }
        
        // 単位変換を適用（材料名も考慮）
        const converted = convertUnits(parsedIng.quantity, parsedIng.unit, parsedIng.item);
        
        // 変換が行われた場合はコンソールに記録
        if (converted.quantity !== parsedIng.quantity || converted.unit !== parsedIng.unit) {
          console.log(`🔄 OCR単位変換: ${parsedIng.item} ${parsedIng.quantity}${parsedIng.unit} → ${converted.quantity}${converted.unit}`);
        }
        
        const convertedIng = {
          item: parsedIng.item,
          quantity: converted.quantity,
          unit: converted.unit,
          price: parsedIng.price
        };
        
        addIngBtn?.dispatchEvent(new Event('click'));
        // 追加完了を待つ（エディタが行を挿入するのを待機）
        await new Promise(resolve => setTimeout(resolve, 50));
        const rows = ingredientsEditor?.querySelectorAll('.ingredient-row');
        const row  = rows?.[rows.length-1];
        // エディタのフィールド仕様に合わせて、存在すれば個別に代入
        const itemInput = row?.querySelector('.ingredient-item');
        const qtyInput  = row?.querySelector('.ingredient-quantity');
        const unitInput = row?.querySelector('.ingredient-unit');
        const priceInput = row?.querySelector('.ingredient-price');
        
        console.log(`🔍 材料${i + 1}フィールド検索結果:`, {
          hasRow: !!row,
          hasItemInput: !!itemInput,
          hasQtyInput: !!qtyInput,
          hasUnitInput: !!unitInput,
          hasPriceInput: !!priceInput,
          rowHTML: row ? row.outerHTML.substring(0, 200) + '...' : 'null'
        });
        
        const line = [convertedIng.item, convertedIng.quantity, convertedIng.unit].filter(Boolean).join(' ');
        if (itemInput && (qtyInput || unitInput)) {
          if (itemInput) {
            itemInput.value = (convertedIng.item || '').toString();
            console.log(`✅ 材料名設定: "${convertedIng.item}"`);
          }
          if (qtyInput) {
            qtyInput.value = (convertedIng.quantity || '').toString();
            console.log(`✅ 分量設定: "${convertedIng.quantity}"`);
          }
          if (unitInput) {
            unitInput.value = (convertedIng.unit || '').toString();
            console.log(`✅ 単位設定: "${convertedIng.unit}"`);
          }
          if (priceInput) {
            priceInput.value = (convertedIng.price || '').toString();
            console.log(`✅ 単価設定: "${convertedIng.price}"`);
          }
          
          // 変換が行われた場合はログに記録
          if (converted.quantity !== ing.quantity || converted.unit !== ing.unit) {
            console.log(`🔄 単位変換: ${convertedIng.item} ${ing.quantity}${ing.unit} → ${converted.quantity}${converted.unit}`);
          }
          console.log(`✅ 材料${i + 1}設定完了:`, convertedIng.item, convertedIng.quantity, convertedIng.unit, convertedIng.price);
        } else if (itemInput) {
          itemInput.value = line;
          console.log(`✅ 材料${i + 1}設定完了(統合):`, line);
        } else {
          console.error(`❌ 材料${i + 1}フィールドが見つかりません:`, {
            hasRow: !!row,
            hasItemInput: !!itemInput,
            hasQtyInput: !!qtyInput,
            hasUnitInput: !!unitInput,
            hasPriceInput: !!priceInput
          });
        }
      }
      console.log('✅ 材料設定完了:', ingredients.length + '個の材料');

      // 手順
      const stepsEditor = document.getElementById('stepsEditor');
      const addStepBtn = document.getElementById('addStep');
      if (stepsEditor) stepsEditor.innerHTML = '';
      const steps = Array.isArray(r.steps) ? r.steps : Array.isArray(r.directions) ? r.directions : [];
      console.log('👩‍🍳 手順処理開始:', steps);
      
      for (let i = 0; i < steps.length; i++) {
        const text = steps[i];
        addStepBtn?.dispatchEvent(new Event('click'));
        await new Promise(resolve => setTimeout(resolve, 50));
        const rows = stepsEditor?.querySelectorAll('.step-row .step-text');
        const el = rows?.[rows.length-1];
        if (el) {
          el.value = (text || '').toString();
          console.log(`✅ 手順${i + 1}設定完了:`, text.substring(0, 30) + '...');
        }
      }
      console.log('✅ 手順設定完了:', steps.length + '個の手順');
      console.log('🎉 レシピデータの適用が完了しました！');
    }

    // ===== 画像解析機能 =====
    let currentFile = null;
    window.__ocrCurrentFile = window.__ocrCurrentFile || null;
    if (!Array.isArray(window.currentImageFiles)) {
      window.currentImageFiles = [];
    }

    // 画像解析ボタンのイベントリスナー
    const imageImportBtn = document.getElementById('imageImportBtn');
    const imageImportModal = document.getElementById('image-import-modal');
    const imageImportModalCloseBtn = document.getElementById('image-import-modal-close-btn');
    const imageImportCancelBtn = document.getElementById('imageImportCancelBtn');
    const fileSelectBtn = document.getElementById('fileSelectBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const imageInput = document.getElementById('imageInput');
    const cameraInput = document.getElementById('cameraInput');
    const analyzeButton = document.getElementById('analyzeButton');
    const clearImageButton = document.getElementById('clearImageButton');
    const sendImageButton = document.getElementById('sendImageButton');

    // デバッグ: 要素の存在確認
    console.log('🔍 Image analysis elements check:', {
      imageImportBtn: !!imageImportBtn,
      imageImportModal: !!imageImportModal,
      fileSelectBtn: !!fileSelectBtn,
      cameraBtn: !!cameraBtn,
      imageInput: !!imageInput,
      cameraInput: !!cameraInput,
      analyzeButton: !!analyzeButton,
      clearImageButton: !!clearImageButton,
      sendImageButton: !!sendImageButton
    });

    if (imageImportBtn && imageImportModal) {
      // シンプルなクリックイベント
      imageImportBtn.onclick = function() {
        imageImportModal.style.display = 'flex';
      };
    }

    // モーダルを閉じる
    const closeImageModal = () => {
      imageImportModal.style.display = 'none';
      
      // ローディングポップアップも非表示にする
      const loadingPopup = document.getElementById('loadingPopup');
      if (loadingPopup) {
        loadingPopup.style.display = 'none';
      }
      
      clearImage();
    };

    // モーダルを閉じるボタン
    if (imageImportModalCloseBtn) {
      imageImportModalCloseBtn.onclick = closeImageModal;
    }
    if (imageImportCancelBtn) {
      imageImportCancelBtn.onclick = closeImageModal;
    }

    // iOS Safari 対策: hidden input の click が無視される場合があるため、一時的な input を使用
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    function openTempImagePicker(capture) {
      const temp = document.createElement('input');
      temp.type = 'file';
      temp.accept = 'image/*';
      if (capture) temp.setAttribute('capture', capture);
      temp.addEventListener('change', (e) => {
        try {
          const f = e.target && e.target.files && e.target.files[0];
          if (f) {
            handleFile(f);
          }
        } finally {
          try { document.body.removeChild(temp); } catch(_){}
        }
      });
      document.body.appendChild(temp);
      temp.click();
    }

    // ファイル選択ボタン（完全新規アプローチ）
    if (fileSelectBtn) {
      console.log('✅ fileSelectBtn found, adding event listener');
      fileSelectBtn.addEventListener('click', function(e) {
        console.log('🖱️ fileSelectBtn clicked');
        e.preventDefault(); e.stopPropagation();

        try {
          console.log('🆕 Creating completely new input element...');

          // 毎回完全に新しいinput要素を作成
          const newInput = document.createElement('input');
          newInput.type = 'file';
          newInput.accept = 'image/*';
          newInput.style.position = 'absolute';
          newInput.style.left = '-9999px';
          newInput.style.top = '-9999px';
          newInput.style.opacity = '0';

          // より確実なイベントリスナー
          const handleNewInputChange = (event) => {
            console.log('🎯 New input change event fired!');
            console.log('📂 Selected files:', event.target.files);

            if (event.target.files && event.target.files.length > 0) {
              const file = event.target.files[0];
              console.log('📂 Processing selected file:', file);
              handleFile(file);
            } else {
              console.log('❌ No files in change event');
            }

            // クリーンアップ
            setTimeout(() => {
              if (document.body.contains(newInput)) {
                document.body.removeChild(newInput);
                console.log('🗑️ Cleaned up input element');
              }
            }, 100);
          };

          // 複数のイベントタイプでリスナーを設定
          newInput.addEventListener('change', handleNewInputChange);
          newInput.addEventListener('input', handleNewInputChange);

          // DOMに追加してクリック
          document.body.appendChild(newInput);
          console.log('🔗 New input added to DOM');

          // 少し遅延させてからクリック
          setTimeout(() => {
            console.log('🖱️ Clicking new input...');
            newInput.click();

            // ユーザーに通知
            showImageMessage('ファイル選択ダイアログが開きました。画像を選択してください。', 'info');

            // バックアップポーリング（change イベントが発火しない場合）
            let pollCount = 0;
            const pollInterval = setInterval(() => {
              pollCount++;
              const fileCount = newInput.files ? newInput.files.length : 0;
              console.log(`🔍 Backup polling ${pollCount}: ${fileCount} files`);

              if (fileCount > 0) {
                console.log('✅ Files detected via backup polling!');
                clearInterval(pollInterval);
                handleNewInputChange({ target: newInput });
              } else if (pollCount >= 20) {
                console.log('⏰ Backup polling timeout');
                clearInterval(pollInterval);

                // 最終クリーンアップ
                if (document.body.contains(newInput)) {
                  document.body.removeChild(newInput);
                }
              }
            }, 250);

          }, 50);

        } catch (error) {
          console.error('❌ Error in new file selection approach:', error);
          showImageMessage('ファイル選択に失敗しました', 'error');
        }
      });
    } else {
      console.error('❌ fileSelectBtn not found');
    }

    // カメラボタン（背面カメラ希望なら 'environment'）
    if (cameraBtn) {
      cameraBtn.addEventListener('click', function(e) {
        e.preventDefault(); e.stopPropagation();
        try {
          if (isIOS) {
            openTempImagePicker('environment');
          } else if (cameraInput) {
            cameraInput.value = '';
            cameraInput.click();
          }
        } catch (e) {
          showImageMessage('カメラ起動に失敗しました', 'error');
        }
      });
    }

    // ファイル選択のイベント（重複バインド防止・Safari対策）
    function onFileChange(event){
      console.log('📂 onFileChange triggered with event:', event);
      try {
        event.preventDefault();
        event.stopPropagation();
        if (typeof event.stopImmediatePropagation === 'function') event.stopImmediatePropagation();
      } catch(_){ }
      handleFileSelect(event);
    }

    // 重複バインド防止を一時的に無効化してテスト
    console.log('🔧 Current __imageHandlersBound state:', window.__imageHandlersBound);

    // 既存のイベントリスナーを削除してから再バインド
    if (imageInput) {
      console.log('🔄 Removing existing event listeners and re-binding...');
      imageInput.removeEventListener('change', onFileChange);
      imageInput.addEventListener('change', onFileChange);

      // 追加: input イベントも監視
      imageInput.addEventListener('input', onFileChange);

      // 追加のデバッグイベント
      imageInput.addEventListener('click', () => {
        console.log('🖱️ imageInput clicked');
      });

      imageInput.addEventListener('focus', () => {
        console.log('🎯 imageInput focused');
      });

      console.log('✅ imageInput event listener re-bound');
    }
    if (cameraInput) {
      cameraInput.removeEventListener('change', onFileChange);
      cameraInput.addEventListener('change', onFileChange);
      console.log('✅ cameraInput event listener re-bound');
    }

    function handleFileSelect(event) {
      console.log('📁 handleFileSelect called with event:', event);
      console.log('📁 Event target:', event?.target);
      console.log('📁 Files array:', event?.target?.files);

      const file = event && event.target && event.target.files ? event.target.files[0] : null;
      console.log('📁 Selected file:', file);

      if (file) {
        handleFile(file);
      } else {
        console.error('❌ No file selected');
      }
    }

    function handleFile(file) {
      console.log('🖼️ handleFile called with:', file);

      if (!file || !file.type.startsWith('image/')) {
        console.error('❌ Invalid file type:', file);
        showImageMessage('画像ファイルを選択してください', 'error');
        return;
      }

      console.log('✅ Valid image file:', {
        name: file.name,
        type: file.type,
        size: file.size
      });

      currentFile = file;
      window.__ocrCurrentFile = file;
      window.currentImageFiles = [file];
      console.log('📁 currentFile set:', currentFile);
      
      // プレビュー表示（JPEGでも稀にFileReaderが発火しないSafari対策でフォールバックあり）
      const previewImage = document.getElementById('previewImage');
      const previewArea = document.getElementById('previewArea');

      console.log('🖼️ Preview elements:', {
        previewImage: !!previewImage,
        previewArea: !!previewArea
      });
      const isHeic = /\.hei[cf]$/i.test(file.name || '') || /image\/(heic|heif)/i.test(file.type || '');
      let previewShown = false;
      if (isHeic && previewImage && previewArea) {
        try {
          const objUrl = URL.createObjectURL(file);
          previewImage.src = objUrl;
          previewArea.style.display = 'block';
          showImageMessage(`画像読み込み(HEIC/HEIF): ${file.name}`, 'success');
          previewShown = true;
        } catch(_) {
          showImageMessage('HEICプレビューに失敗（解析は可能です）', 'error');
        }
      }
      if (!previewShown) {
        console.log('🔄 Starting FileReader process...');
        const reader = new FileReader();
        reader.onload = (e) => {
          console.log('✅ FileReader onload triggered');
          if (previewImage && previewArea) {
            previewImage.src = e.target.result;
            previewArea.style.display = 'block';
            showImageMessage(`画像読み込み完了: ${file.name}`, 'success');
            previewShown = true;
            console.log('✅ Preview image set and area displayed');
          } else {
            console.error('❌ Preview elements not found in onload');
          }
        };
        reader.onerror = (error) => {
          console.error('❌ FileReader error:', error);
          showImageMessage('ファイルの読み込みに失敗しました（解析は可能です）', 'error');
        };
        // iOS / Safari 安定化: 非同期に遅延させてUIスレッドとの競合を避ける
        console.log('🔄 Starting FileReader.readAsDataURL...');
        setTimeout(() => reader.readAsDataURL(file), 0);
        // フォールバック: 一定時間でプレビューが出なければ ObjectURL で表示を試行
        setTimeout(() => {
          if (!previewShown && previewImage && previewArea) {
            try {
              const objUrl = URL.createObjectURL(file);
              previewImage.src = objUrl;
              previewArea.style.display = 'block';
              showImageMessage(`画像読み込み(フォールバック): ${file.name}`, 'success');
            } catch(_) { /* ignore */ }
          }
        }, 600);
      }
      
      // 選択後に解析ボタンとアップロードボタンを有効化
      if (analyzeButton) {
        analyzeButton.disabled = false;
        console.log('✅ analyzeButton enabled after file selection');
      } else {
        console.error('❌ analyzeButton not found when trying to enable');
      }
      
      // アップロードボタンも有効化
      const sendImageButton = document.getElementById('sendImageBtn');
      if (sendImageButton) {
        sendImageButton.disabled = false;
        console.log('✅ sendImageButton enabled after file selection');
      } else {
        console.error('❌ sendImageButton not found when trying to enable');
      }
    }

    // AI解析プロバイダー選択UIを追加
    function addAIProviderSelector() {
      if (!window.aiConfig) {
        return;
      }

      const modalBody = document.querySelector('#image-import-modal .modal-body');
      const uploadArea = document.getElementById('uploadArea');
      const container = (uploadArea && uploadArea.parentElement) || modalBody;

      if (!container) {
        console.warn('⚠️ AI解析プロバイダー選択UIの追加先が見つかりません');
        return;
      }

      const existingSelector = container.querySelector('.ai-provider-selector');
      if (existingSelector) {
        return;
      }

      const renderProviderSelector = (root) => {
        const providers = window.aiConfig.getAvailableProviders();
        const currentProvider = window.aiConfig.getCurrentProvider();
        const current = currentProvider?.key || 'groq';
        window.latestAIProvider = current;
        window.latestAIProviderModel = currentProvider?.model || null;
        root.innerHTML = `
          <div class="ai-provider-toggle">
            ${providers.map(p => `
              <button type="button" class="ai-provider-btn ${p.key === current ? 'selected' : ''}" data-provider="${p.key}">
                <span class="ai-provider-name">${p.name}</span>
                <span class="ai-provider-meta">${p.model}</span>
              </button>
            `).join('')}
          </div>
          <p class="ai-provider-hint">OCR後のレシピ構造化に利用するAIを選択してください。</p>
        `;

        root.querySelectorAll('.ai-provider-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const provider = btn.dataset.provider;
            window.aiConfig.setProvider(provider);
            renderProviderSelector(root);
            window.latestAIProvider = provider;
            window.latestAIProviderModel = window.aiConfig.getCurrentProvider()?.model || null;
            showImageMessage(`${window.aiConfig.providers[provider].name} を選択しました。`, 'info');
          });
        });
      };

      const selector = document.createElement('div');
      selector.className = 'ai-provider-selector ai-provider-selector--compact';
      renderProviderSelector(selector);

      if (uploadArea && uploadArea.nextElementSibling) {
        container.insertBefore(selector, uploadArea.nextElementSibling);
      } else {
        container.appendChild(selector);
      }

      console.log('✅ AI解析プロバイダー選択UIを追加');
    }

    // 解析ボタン
    if (analyzeButton) {
      console.log('✅ analyzeButton found, setting up event listener');
      analyzeButton.disabled = true;
      
      // AI解析プロバイダー選択UIを追加
      addAIProviderSelector();
      
      analyzeButton.addEventListener('click', function(e){
        console.log('🖱️ analyzeButton clicked!');
        e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();

        console.log('🔄 Calling analyzeImage function...');
        analyzeImage();
      });
    } else {
      console.error('❌ analyzeButton not found');
    }

    // 画像送信（アップロードのみ）
    if (sendImageButton) {
      sendImageButton.disabled = true;
      sendImageButton.addEventListener('click', async function(e){
        e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
        try {
          if (!currentFile) { 
            showImageMessage('画像を選択してください', 'error'); 
            return; 
          }
          
          const f = currentFile;
          const ext = (f.name?.split('.')?.pop() || 'jpg').toLowerCase();
          const name = `${(crypto && crypto.randomUUID) ? crypto.randomUUID() : Date.now()}.${ext}`;
          const path = `ocr/${name}`;
          
          if (!window.sb) { 
            showImageMessage('Supabaseが初期化されていません', 'error'); 
            return; 
          }
          
          console.log('🔄 ストレージアップロードを開始:', { path, size: f.size, type: f.type });
          showImageMessage('画像をアップロード中...', 'loading');
          
          const { error } = await window.sb.storage.from('images').upload(path, f, {
            upsert: true,
            cacheControl: '3600',
            contentType: f.type || 'image/jpeg'
          });
          
          if (error) {
            console.error('❌ ストレージアップロードエラー:', error);
            
            // RLSポリシーエラーの場合は特別なメッセージを表示
            if (error.message && error.message.includes('row-level security policy')) {
              showImageMessage('ストレージ設定エラー: 管理者に連絡してください', 'error');
            } else {
              showImageMessage('画像送信に失敗: ' + (error.message || error), 'error');
            }
            return;
          }
          
          const { data } = window.sb.storage.from('images').getPublicUrl(path);
          const url = data?.publicUrl;
          if (url) {
            console.log('✅ ストレージアップロード成功:', url);
            showImageMessage('画像を送信しました: ' + url, 'success');
          } else {
            showImageMessage('画像の公開URL取得に失敗しました', 'error');
          }
        } catch (e) {
          console.error('❌ ストレージアップロード例外:', e);
          showImageMessage('画像送信に失敗: ' + (e.message || e), 'error');
        }
      });
    }

    // クリアボタン
    if (clearImageButton) {
      clearImageButton.addEventListener('click', function(e){
        e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
        clearImage();
      });
    }

    // フォームのEnter送信を抑止（解析モーダル操作中の誤送信防止）
    document.getElementById('editForm')?.addEventListener('submit', function(e){ e.preventDefault(); });

    function getActiveOcrFile() {
      if (currentFile instanceof File) {
        return currentFile;
      }
      if (window.__ocrCurrentFile instanceof File) {
        return window.__ocrCurrentFile;
      }
      if (Array.isArray(window.currentImageFiles) && window.currentImageFiles.length > 0) {
        const candidate = window.currentImageFiles.find(f => f instanceof File);
        if (candidate) {
          window.__ocrCurrentFile = candidate;
          currentFile = candidate;
          return candidate;
        }
      }
      return null;
    }

    async function analyzeWithAzureDocumentIntelligence(base64Payload, selectedProvider, providerInfo) {
      console.log('🛰️ Azure Document Intelligence呼び出し準備', { selectedProvider });

      const { data: docResult, error: docError } = await sb.functions.invoke('call-document-intelligence', {
        body: {
          image: base64Payload,
          processorType: 'RECIPE_PROCESSOR',
          aiProvider: selectedProvider
        }
      });
      try {
        if (window.AzureUsageManager && typeof window.AzureUsageManager.incrementUsage === 'function') {
          window.AzureUsageManager.incrementUsage();
        }
        if (window.ApiUsageManager && typeof window.ApiUsageManager.increment === 'function') {
          const providerKey = (selectedProvider || '').toLowerCase();
          if (providerKey === 'groq' || providerKey === 'chatgpt') {
            window.ApiUsageManager.increment(providerKey);
          }
        }
      } catch (usageError) {
        console.warn('⚠️ API使用回数の更新に失敗しました:', usageError);
      }

      if (docError) {
        console.error('❌ call-document-intelligence error:', docError);
        if (docError?.context?.response) {
          try {
            const clone = docError.context.response.clone();
            const errorText = await clone.text();
            console.error('❌ Edge function response body:', errorText);
            throw new Error(errorText || docError.message || 'Azure Document Intelligence呼び出しに失敗しました');
          } catch (parseErr) {
            console.warn('⚠️ Failed to read error response body:', parseErr);
          }
        }
        throw new Error(docError.message || docError.error || 'Azure Document Intelligence呼び出しに失敗しました');
      }

      if (!docResult?.success) {
        console.error('❌ call-document-intelligence response error:', docResult);
        throw new Error(docResult?.error || '画像解析に失敗しました');
      }

      try {
        if (window.ApiUsageManager && typeof window.ApiUsageManager.increment === 'function') {
          window.ApiUsageManager.increment(selectedProvider);
        }
      } catch (providerUsageError) {
        console.warn('⚠️ AI使用回数の更新に失敗しました:', providerUsageError);
      }

      const recipeData = docResult.data;
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('レシピデータが取得できませんでした');
      }

      recipeData.aiProvider = selectedProvider;
      recipeData.aiProviderModel = providerInfo?.model || null;

      console.log('📄 Azure + AI解析結果:', recipeData);
      return recipeData;
    }

    async function ensureAzureCompatibleImage(file) {
      const limits = {
        minDimension: 50,
        maxDimension: 4200,
        maxPixels: 4200 * 4200,
        maxFileSize: 4 * 1024 * 1024
      };

      const isWithinLimits = (w, h, size) => {
        const pixels = w * h;
        return (
          w >= limits.minDimension &&
          h >= limits.minDimension &&
          w <= limits.maxDimension &&
          h <= limits.maxDimension &&
          pixels <= limits.maxPixels &&
          size <= limits.maxFileSize
        );
      };

      const readAsDataURL = (f) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('画像データの読み込みに失敗しました'));
        reader.readAsDataURL(f);
      });

      const createImage = (src) => new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('画像の解析に失敗しました'));
        img.src = src;
      });

      const canvasToSizedBlob = async (canvas, preferredType, maxSize) => {
        const toBlob = (type, quality) => new Promise((resolve) => {
          canvas.toBlob((blob) => resolve(blob), type, quality);
        });

        let mimeType = preferredType === 'image/png' || preferredType === 'image/jpeg'
          ? preferredType
          : 'image/jpeg';

        // まずは元の形式で試す（PNGはqualityを指定できない）
        let blob = await toBlob(mimeType, 0.92);
        if (blob && blob.size <= maxSize) {
          return blob;
        }

        // PNGなどでサイズが大きい場合はJPEGにフォールバック
        if (mimeType !== 'image/jpeg') {
          mimeType = 'image/jpeg';
        }

        let quality = 0.92;
        while (quality >= 0.5) {
          blob = await toBlob(mimeType, quality);
          if (blob && blob.size <= maxSize) {
            return blob;
          }
          quality -= 0.1;
        }

        // 最終手段でさらに圧縮
        blob = await toBlob(mimeType, 0.4);
        return blob || new Blob();
      };

      try {
        const dataUrl = await readAsDataURL(file);
        const image = await createImage(dataUrl);
        const originalWidth = image.naturalWidth || image.width;
        const originalHeight = image.naturalHeight || image.height;

        if (isWithinLimits(originalWidth, originalHeight, file.size)) {
          return { file, resized: false, width: originalWidth, height: originalHeight };
        }

        let targetWidth = originalWidth;
        let targetHeight = originalHeight;
        let scale = 1;

        const needDownscale = (
          originalWidth > limits.maxDimension ||
          originalHeight > limits.maxDimension ||
          (originalWidth * originalHeight) > limits.maxPixels
        );

        const needUpscale = (
          originalWidth < limits.minDimension ||
          originalHeight < limits.minDimension
        );

        if (needDownscale) {
          const scaleToMax = Math.min(
            limits.maxDimension / originalWidth,
            limits.maxDimension / originalHeight,
            Math.sqrt(limits.maxPixels / (originalWidth * originalHeight))
          );
          scale = Math.min(1, scaleToMax);
        } else if (needUpscale) {
          const scaleToMin = Math.max(
            limits.minDimension / originalWidth,
            limits.minDimension / originalHeight
          );
          scale = Math.max(1, scaleToMin);
        }

        targetWidth = Math.max(1, Math.round(originalWidth * scale));
        targetHeight = Math.max(1, Math.round(originalHeight * scale));

        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          throw new Error('画像のリサイズ用コンテキストを確保できませんでした');
        }
        ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

        const outputBlob = await canvasToSizedBlob(canvas, file.type || 'image/png', limits.maxFileSize);
        if (!outputBlob || outputBlob.size === 0) {
          throw new Error('画像のリサイズに失敗しました');
        }

        const normalizedFile = new File([outputBlob], file.name.replace(/\.(\w+)$/, '') + '-azure.' + (outputBlob.type === 'image/png' ? 'png' : 'jpg'), {
          type: outputBlob.type,
          lastModified: Date.now()
        });

        return {
          file: normalizedFile,
          resized: true,
          width: targetWidth,
          height: targetHeight,
          originalWidth,
          originalHeight
        };
      } catch (resizeError) {
        console.error('❌ Azure互換リサイズ失敗:', resizeError);
        throw resizeError;
      }
    }

    async function analyzeWithVisionFallback(base64Payload, fileType, selectedProvider, providerInfo) {
      const analyzerManager = window.aiAnalyzerManager;
      if (!analyzerManager) {
        throw new Error('AI解析マネージャーが初期化されていません');
      }

      if (selectedProvider) {
        try {
          if (analyzerManager.currentAnalyzer?.provider !== selectedProvider) {
            analyzerManager.setAnalyzer(selectedProvider);
          }
        } catch (switchError) {
          console.warn('⚠️ 解析器の切り替えに失敗しました:', switchError);
        }
      }

      const mimeType = fileType || 'image/png';
      console.log('🛰️ Gemini Visionフォールバック開始', { selectedProvider, mimeType });

      const { data: visionResult, error: visionError } = await sb.functions.invoke('call-vision-api', {
        body: {
          contents: [{
            parts: [
              {
                text: 'Extract all text from this recipe image. Preserve Japanese characters, numbers, and line breaks as they appear.'
              },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Payload
                }
              }
            ]
          }]
        }
      });

      if (visionError) {
        console.error('❌ call-vision-api error:', visionError);
        if (visionError?.context?.response) {
          try {
            const clone = visionError.context.response.clone();
            const errorText = await clone.text();
            console.error('❌ Vision function response body:', errorText);
            throw new Error(errorText || visionError.message || 'Gemini Vision呼び出しに失敗しました');
          } catch (parseErr) {
            console.warn('⚠️ Failed to read vision error body:', parseErr);
          }
        }
        throw new Error(visionError.message || visionError.error || 'Gemini Vision呼び出しに失敗しました');
      }

      const extractedTextParts = visionResult?.candidates?.[0]?.content?.parts || [];
      const extractedText = extractedTextParts
        .map(part => part?.text || '')
        .filter(Boolean)
        .join('\n')
        .trim();

      if (!extractedText) {
        console.error('❌ Gemini Visionから有効なテキストが取得できませんでした:', visionResult);
        throw new Error('Gemini Visionからテキストを取得できませんでした');
      }

      console.log('📝 Gemini Vision抽出テキスト(冒頭):', extractedText.substring(0, 200));

      try {
        const recipeData = await analyzerManager.analyzeRecipe(extractedText, sb);
        if (!recipeData || typeof recipeData !== 'object') {
          throw new Error('AI解析結果が無効です');
        }
        recipeData.aiProvider = recipeData.aiProvider || selectedProvider;
        recipeData.aiProviderModel = recipeData.aiProviderModel || providerInfo?.model || null;
        console.log('✅ Gemini Vision + AI解析成功:', {
          provider: recipeData.aiProvider,
          ingredients: recipeData.ingredients?.length || 0,
          steps: recipeData.steps?.length || 0
        });
        return recipeData;
      } catch (analysisError) {
        console.error('❌ Gemini Visionフォールバック解析エラー:', analysisError);
        throw analysisError;
      }
    }

    async function analyzeImage() {
      console.log('🔍 analyzeImage function called');
      const activeFile = getActiveOcrFile();
      if (activeFile) {
        currentFile = activeFile;
        window.__ocrCurrentFile = activeFile;
      }
      console.log('📁 activeFile status:', activeFile);

      if (!activeFile) {
        console.error('❌ No currentFile available');
        showImageMessage('画像を選択してください', 'error');
        return;
      }

      const loadingPopup = document.getElementById('loadingPopup');
      if (loadingPopup) {
        loadingPopup.style.display = 'flex';
      }

      showImageMessage('AzureでOCR解析を開始しました...', 'loading');
      if (typeof showStatusPopup === 'function') {
        showStatusPopup('画像解析中...', 'Azure Document IntelligenceでOCR、AIで構造化しています', 'loading');
      }

      if (analyzeButton) {
        analyzeButton.disabled = true;
      }

      try {
        let azureReadyFile = activeFile;
        try {
          const normalization = await ensureAzureCompatibleImage(activeFile);
          azureReadyFile = normalization.file;
          const before = `${normalization.originalWidth || activeFile.width || '?'}x${normalization.originalHeight || activeFile.height || '?'}`;
          const after = `${normalization.width}x${normalization.height}`;
          if (normalization.resized) {
            showImageMessage(`Azure制限に合わせて画像をリサイズしました (${before} → ${after})`, 'info');
          }
          window.__ocrCurrentFile = azureReadyFile;
          currentFile = azureReadyFile;
        } catch (resizeError) {
          console.warn('⚠️ Azure互換リサイズをスキップします:', resizeError);
          showImageMessage('Azure用の画像調整に失敗したため、元の画像で解析を試みます。', 'error');
        }

        const base64 = await fileToBase64(azureReadyFile);
        console.log('✅ Base64 conversion completed, size:', base64.length);
        const base64Payload = base64.includes(',') ? base64.split(',')[1] : base64;

        // オプション: 画像をストレージに保存して後で参照できるようにする
        try {
          if (window.sb) {
            const f = azureReadyFile;
            const ext = (f.name?.split('.')?.pop() || 'jpg').toLowerCase();
            const name = `${(crypto && crypto.randomUUID) ? crypto.randomUUID() : Date.now()}.${ext}`;
            const path = `ocr/${name}`;

            console.log('🔄 ストレージアップロードを開始:', { path, size: f.size, type: f.type });

            const { error: uploadError } = await window.sb.storage.from('images').upload(path, f, {
              upsert: true,
              cacheControl: '3600',
              contentType: f.type || 'image/jpeg'
            });

            if (uploadError) {
              console.warn('⚠️ ストレージアップロードエラー:', uploadError);
              showImageMessage('画像の送信に失敗しました（解析は続行します）', 'error');
            } else {
              const { data } = window.sb.storage.from('images').getPublicUrl(path);
              if (data?.publicUrl) {
                window.currentImageData = data.publicUrl;
                console.log('✅ ストレージアップロード成功:', data.publicUrl);
              }
            }
          }
        } catch (storageError) {
          console.warn('⚠️ ストレージアップロード例外:', storageError);
        }
        const providerInfo = window.aiConfig?.getCurrentProvider();
        const selectedProvider = providerInfo?.key || 'groq';
        console.log('🤖 Selected AI provider:', selectedProvider);

        let recipeData = null;
        let analysisSource = '';

        try {
          showImageMessage(`AzureでOCR後、${selectedProvider.toUpperCase()}で解析中...`, 'loading');
          recipeData = await analyzeWithAzureDocumentIntelligence(base64Payload, selectedProvider, providerInfo);
          analysisSource = `Azure Document Intelligence + ${selectedProvider.toUpperCase()}`;
        } catch (azureError) {
          console.warn('⚠️ Azure Document Intelligence解析に失敗しました。Gemini Visionフォールバックを試みます。', azureError);
          showImageMessage('Azure解析に失敗したため、Gemini Visionに切り替えています...', 'info');
          if (typeof updateStatusPopup === 'function') {
            updateStatusPopup('再解析中', 'Gemini Visionで再解析しています...', 'loading');
          }

          try {
            recipeData = await analyzeWithVisionFallback(base64Payload, activeFile.type, selectedProvider, providerInfo);
            analysisSource = `Gemini Vision + ${selectedProvider.toUpperCase()}`;
          } catch (fallbackError) {
            console.error('❌ Gemini Visionフォールバックも失敗しました', fallbackError);
            if (azureError && fallbackError && typeof fallbackError === 'object') {
              fallbackError.originalError = azureError;
            }
            throw fallbackError;
          }
        }

        if (!recipeData || typeof recipeData !== 'object') {
          throw new Error('レシピデータが取得できませんでした');
        }

        console.log(`📄 解析結果 (${analysisSource}):`, recipeData);
        await applyRecipeData(recipeData);
        showImageMessage('画像解析が完了しました！', 'success');

        if (typeof updateStatusPopup === 'function') {
          updateStatusPopup('完了', '画像解析が完了しました！', 'success');
          setTimeout(() => {
            if (typeof hideStatusPopup === 'function') {
              hideStatusPopup();
            }
          }, 2000);
        }

        closeImageModal();
      } catch (error) {
        console.error('❌ 画像解析エラー:', error);
        showImageMessage('画像解析に失敗しました: ' + (error.message || error), 'error');

        if (typeof updateStatusPopup === 'function') {
          updateStatusPopup('エラー', '画像解析に失敗しました', 'error');
          setTimeout(() => {
            if (typeof hideStatusPopup === 'function') {
              hideStatusPopup();
            }
          }, 3000);
        }
      } finally {
        if (loadingPopup) {
          loadingPopup.style.display = 'none';
        }
        if (analyzeButton) {
          analyzeButton.disabled = !currentFile;
        }
      }
    }

    function parseTextToRecipe(text) {
      const lines = text.split('\n').filter(line => line.trim());
      
      // タイトルを探す（最初の行または料理名らしい行）
      let title = 'OCRで抽出したレシピ';
      const titleCandidates = lines.filter(line => 
        !line.includes('材料') && 
        !line.includes('作り方') && 
        !line.includes('手順') &&
        !line.includes('人前') &&
        !line.includes('人分') &&
        line.length > 2 && line.length < 50
      );
      if (titleCandidates.length > 0) {
        title = titleCandidates[0].trim();
      }
      
      // 人数を抽出
      let servings = 2;
      const servingLine = lines.find(line => 
        line.includes('人前') || line.includes('人分') || line.match(/\d+人/)
      );
      if (servingLine) {
        const match = servingLine.match(/(\d+)/);
        if (match) servings = parseInt(match[1]);
      }
      
      // 材料部分を抽出（改善版）
      const ingredients = [];
      console.log('🔍 材料抽出開始:', text.substring(0, 200) + '...');
      
      // 材料セクションを探す
      const ingredientStartIndex = lines.findIndex(line => 
        line.includes('材料') || line.includes('材料名') || line.includes('ingredient')
      );
      
      const normalizeQuantityInfo = (qtyRaw, unitRaw) => {
        let quantityNorm = (qtyRaw || '').toString().trim();
        let unitNorm = (unitRaw || '').toString().trim();
        let priceNorm = '';

        // 価格を抽出（単位側に含まれるケース）
        const priceInUnit = unitNorm.match(/(\d+(?:\.\d+)?)円/);
        if (priceInUnit) {
          priceNorm = `${priceInUnit[1]}円`;
          unitNorm = unitNorm.replace(/(\d+(?:\.\d+)?)円/g, '').trim();
        }

        // 価格が数量側に含まれるケース
        const priceInQty = quantityNorm.match(/(\d+(?:\.\d+)?)円/);
        if (priceInQty) {
          priceNorm = `${priceInQty[1]}円`;
          quantityNorm = quantityNorm.replace(/(\d+(?:\.\d+)?)円/g, '').trim();
        }

        // 数量に単位がくっついているケース（例: 1kg, 200ml）
        if (!unitNorm) {
          const qtyUnitMatch = quantityNorm.match(/^(\d+(?:\.\d+)?)([a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/);
          if (qtyUnitMatch) {
            quantityNorm = qtyUnitMatch[1];
            unitNorm = qtyUnitMatch[2];
          }
        }

        return {
          quantity: quantityNorm,
          unit: unitNorm,
          price: priceNorm
        };
      };

      if (ingredientStartIndex >= 0) {
        console.log('📋 材料セクションが見つかりました:', ingredientStartIndex);
        const stepsStartIndex = lines.findIndex(line => 
          line.includes('作り方') || line.includes('手順') || line.includes('調理方法') || line.includes('step')
        );
        
        const endIndex = stepsStartIndex >= 0 ? stepsStartIndex : Math.min(ingredientStartIndex + 15, lines.length);
        
        for (let i = ingredientStartIndex + 1; i < endIndex; i++) {
          const line = lines[i].trim();
          if (line && line.length > 1 && !line.includes('作り方') && !line.includes('手順')) {
            // 材料名、分量、単位を分離（改善版）
            let item = line;
            let quantity = '';
            let unit = '';
            let price = '';
            
            // 数字が含まれている場合は分量と単位を分離
            if (line.match(/\d/)) {
              const match = line.match(/^(.+?)\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(.*)$/);
              if (match) {
                item = match[1].trim();
                quantity = match[2].trim();
                unit = match[3].trim();
              }
            }
            
            const normalized = normalizeQuantityInfo(quantity, unit);
            quantity = normalized.quantity;
            unit = normalized.unit;
            price = normalized.price;
            
            ingredients.push({ 
              item: item, 
              quantity: quantity, 
              unit: unit,
              price: price
            });
          }
        }
      } else {
        // 材料セクションが見つからない場合、材料らしい行を探す
        console.log('🔍 材料セクションが見つからないため、材料らしい行を探します...');
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // 材料らしい行の判定（数字と単位が含まれ、料理名や手順でない）
          if (line && line.length > 1 && 
              line.match(/\d/) && 
              (line.match(/[gml個本枚大さじ小さじ]/) || line.match(/\d+円/)) &&
              !line.includes('作り方') && 
              !line.includes('手順') &&
              !line.includes('調理方法') &&
              !line.includes('人前') &&
              !line.includes('人分') &&
              line.length < 100) {
            
            console.log(`🔍 材料候補: "${line}"`);
            
            // 材料名、分量、単位、価格を分離（改善版）
            let item = line;
            let quantity = '';
            let unit = '';
            let price = '';
            
            console.log(`🔍 材料解析: "${line}"`);
            
            // パターン1: "材料名 分量単位 価格円" (例: "コンデンスミルク 1kg 1320円")
            const pattern1 = line.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s+(\d+)円$/);
            if (pattern1) {
              item = pattern1[1].trim();
              quantity = pattern1[2].trim();
              unit = pattern1[3].trim();
              price = pattern1[4].trim();
              console.log(`✅ パターン1解析成功:`, { item, quantity, unit, price });
            }
            // パターン2: "材料名 価格円" (例: "グラニュー糖 290円")
            else if (line.match(/^(.+?)\s+(\d+)円$/)) {
              const priceMatch = line.match(/^(.+?)\s+(\d+)円$/);
              if (priceMatch) {
                item = priceMatch[1].trim();
                quantity = '';
                unit = '';
                price = priceMatch[2].trim();
                console.log(`✅ パターン2解析成功:`, { item, quantity, unit, price });
              }
            }
            // パターン3: "材料名 分量単位" (例: "牛乳 200ml")
            else if (line.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/)) {
              const match = line.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/);
              if (match) {
                item = match[1].trim();
                quantity = match[2].trim();
                unit = match[3].trim();
                console.log(`✅ パターン3解析成功:`, { item, quantity, unit, price });
              }
            }
            // パターン4: "材料名 分量" (例: "塩 小さじ1")
            else if (line.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)$/)) {
              const match = line.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)$/);
              if (match) {
                item = match[1].trim();
                quantity = match[2].trim();
                unit = '';
                console.log(`✅ パターン4解析成功:`, { item, quantity, unit, price });
              }
            }
            // パターン5: その他（材料名のみ）
            else {
              item = line;
              console.log(`✅ パターン5解析成功（材料名のみ）:`, { item, quantity, unit, price });
            }

            const normalized = normalizeQuantityInfo(quantity, unit);
            if (!price) {
              price = normalized.price;
            }
            quantity = normalized.quantity;
            unit = normalized.unit;
            
            ingredients.push({ 
              item: item, 
              quantity: quantity, 
              unit: unit,
              price: price
            });
          }
        }
      }
      
      console.log('📦 抽出された材料:', ingredients);
      
      // 手順部分を抽出
      const steps = [];
      const stepsStartIndex = lines.findIndex(line => 
        line.includes('作り方') || line.includes('手順') || line.includes('調理方法') || line.includes('step')
      );
      
      if (stepsStartIndex >= 0) {
        for (let i = stepsStartIndex + 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line && line.length > 2) {
            // 番号を除去
            const cleanStep = line.replace(/^\d+[\.\)]\s*/, '').trim();
            if (cleanStep) {
              steps.push(cleanStep);
            }
          }
        }
      }
      
      return {
        title: title,
        description: `OCRで抽出されたレシピです。\n\n${text.substring(0, 200)}...`,
        servings: servings,
        ingredients: ingredients.length > 0 ? ingredients : [{ item: '材料情報が見つかりませんでした', quantity: '', unit: '' }],
        steps: steps.length > 0 ? steps : ['手順情報が見つかりませんでした']
      };
    }

    function clearImage() {
      currentFile = null;
      window.__ocrCurrentFile = null;
      if (Array.isArray(window.currentImageFiles)) {
        window.currentImageFiles = [];
      }
      const previewArea = document.getElementById('previewArea');
      const imageInput = document.getElementById('imageInput');
      const cameraInput = document.getElementById('cameraInput');
      const messageArea = document.getElementById('imageMessageArea');
      
      if (previewArea) previewArea.style.display = 'none';
      if (imageInput) imageInput.value = '';
      if (cameraInput) cameraInput.value = '';
      if (messageArea) messageArea.innerHTML = '';
      if (analyzeButton) analyzeButton.disabled = true;
      if (sendImageButton) sendImageButton.disabled = true;
    }

    function showImageMessage(message, type = 'info') {
      const messageArea = document.getElementById('imageMessageArea');
      if (!messageArea) return;
      
      const className = type === 'error' ? 'error-message' : 
                      type === 'success' ? 'success-message' : 'loading-message';
      const provider = (window.latestAIProvider || '').toString().toLowerCase();
      const providerIconMap = {
        groq: '../assets/icons/URL-groq.svg',
        chatgpt: '../assets/icons/openai.svg'
      };

      let contentHtml = `<div class="${className}">${message}</div>`;

      if (type === 'success' && provider && providerIconMap[provider]) {
        const iconPath = providerIconMap[provider];
        contentHtml = `
          <div class="${className} image-message-with-icon">
            <img src="${iconPath}" alt="${provider}" class="image-message-icon" loading="lazy">
            <span>${message}</span>
          </div>`;
      }

      messageArea.innerHTML = contentHtml;
      
      if (type === 'success') {
        setTimeout(() => {
          messageArea.innerHTML = '';
        }, 3000);
      }
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
        reader.readAsDataURL(file);
      });
    }

    // (duplicate listeners removed)
    
    // レシピ編集の初期化はapp-edit.jsで実行されるため、ここでは不要

  });
  </script>
</body>
</html>
