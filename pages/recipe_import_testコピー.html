<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ãƒ¬ã‚·ãƒ”å–å¾—ãƒ†ã‚¹ãƒˆ â€” Recipe Box</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../assets/css/style.css?v=20250116ai">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GitHub Pagesç”¨è¨­å®šï¼ˆç›´æ¥åŸ‹ã‚è¾¼ã¿ï¼‰ -->
  <script>
    window.APP_CONFIG = {
      // Supabaseè¨­å®šï¼ˆæœ¬ç•ªç’°å¢ƒï¼‰
      SUPABASE_URL: 'https://nnbdzwrndqtsfzobknmj.supabase.co',
      SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q',
      
      // APIè¨­å®š
      API_BASE_URL: 'https://nnbdzwrndqtsfzobknmj.supabase.co/functions/v1',
      
      // ã‚¢ãƒ—ãƒªè¨­å®š
      APP_NAME: 'Recipe Keeper',
      VERSION: '1.0.0',
      
      // GitHub Pagesç”¨è¨­å®š
      IS_GITHUB_PAGES: true,
      BASE_PATH: '/recipes'
    };
    
    console.log('âœ… GitHub Pagesè¨­å®šãƒ­ãƒ¼ãƒ‰å®Œäº†:', window.APP_CONFIG);
  </script>
  <script src="../assets/js/utils.js"></script>
  <script src="../assets/js/proxy-manager.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      /* ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ */
      --bg-primary: #f6f8fa;
      --bg-surface: #ffffff;
      --text-primary: #1f2933;
      --text-secondary: #64748b;
      --border-color: rgba(148, 163, 184, 0.25);
      --accent-primary: #6366f1;
      --success-color: #059669;
      --warning-color: #d97706;
      --error-color: #dc2626;
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ */
        --bg-primary: #0f172a;
        --bg-surface: #1e293b;
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --border-color: rgba(148, 163, 184, 0.2);
        --accent-primary: #818cf8;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }

    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    main {
      flex: 1;
      padding: 2rem 1.5rem 4rem;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
    }
    
    @media (max-width: 768px) {
      main {
        padding: 1.5rem 1rem 3rem;
      }
    }
    
    .import-card {
      background: var(--bg-surface);
      border-radius: 20px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.12);
      padding: clamp(2rem, 4vw, 3rem);
      border: 1px solid var(--border-color);
      margin-bottom: 3rem;
      transition: box-shadow 0.3s ease;
    }
    
    .import-card:hover {
      box-shadow: 0 25px 55px rgba(15, 23, 42, 0.15);
    }
    
    .import-card header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .import-card h1 {
      font-size: clamp(1.6rem, 4vw, 2.2rem);
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }
    
    .import-card h1 i {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .import-card p {
      margin: 0 auto;
      color: var(--text-secondary);
      line-height: 1.6;
      font-size: 1rem;
      max-width: 600px;
    }
    
    form {
      display: grid;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    label {
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.95rem;
    }
    
    input[type="url"] {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    
    input[type="url"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
    }
    
    .api-selector {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .api-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-surface);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .api-option:hover {
      border-color: var(--accent-primary);
    }
    
    .api-option input[type="radio"] {
      margin: 0;
    }
    
    .api-option.selected {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
    }
    
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.85rem 1.6rem;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }
    
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 15px 35px rgba(99, 102, 241, 0.25);
    }
    
    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .button-group button {
      flex: 1;
      min-width: 140px;
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #64748b, #475569);
      color: white;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, #475569, #334155);
      box-shadow: 0 15px 35px rgba(100, 116, 139, 0.25);
    }
    
    /* ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: var(--bg-surface);
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
      max-width: 600px;
      width: 95%;
      max-height: 90vh;
      overflow-y: auto;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    .modal-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.25rem;
      border-radius: 4px;
      transition: color 0.2s ease;
    }
    
    .modal-close:hover {
      color: var(--text-primary);
    }
    
    .modal-body {
      padding: 1.5rem;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
    }
    
    .image-upload-section {
      text-align: center;
      padding: 2rem 1rem;
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      background: var(--bg-primary);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    .image-upload-section:hover {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.05);
    }
    
    .image-upload-section.drag-over {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
      border-style: solid;
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.15);
    }
    
    .image-upload-section.drag-over::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 10px;
      pointer-events: none;
    }
    
    .drag-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.9);
      border-radius: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      z-index: 10;
    }
    
    .image-upload-section.drag-over .drag-overlay {
      display: flex;
    }
    
    .btn.ghost {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }
    
    .btn.ghost:hover:not(:disabled) {
      background: var(--bg-primary);
      color: var(--text-primary);
      box-shadow: none;
    }
    
    .btn.primary {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      color: white;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: var(--text-secondary);
      min-height: 1.2rem;
      margin: 1rem 0;
    }
    
    .status i {
      color: var(--accent-primary);
    }
    
    .status.success {
      color: var(--success-color);
    }
    
    .status.warning {
      color: var(--warning-color);
    }
    
    .status.error {
      color: var(--error-color);
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
      min-width: 0;
      overflow: hidden;
    }
    
    @media (max-width: 768px) {
      .results-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .result-section {
      background: var(--bg-surface);
      border-radius: 16px;
      border: 1px solid var(--border-color);
      padding: 2rem;
      min-width: 0;
      overflow: hidden;
      word-wrap: break-word;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
      transition: box-shadow 0.2s ease;
    }
    
    .result-section:hover {
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.12);
    }
    
    .result-section h3 {
      margin: 0 0 1.5rem 0;
      font-size: 1.25rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: var(--text-primary);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 0.75rem;
    }
    
    .result-section h3 i {
      color: var(--accent-primary);
    }
    
    .recipe-preview {
      display: grid;
      gap: 1rem;
    }
    
    .recipe-field {
      display: grid;
      gap: 0.25rem;
    }
    
    .recipe-field label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 0;
    }
    
    .recipe-field .value {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-height: 1.2rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    .ingredients-list, .steps-list {
      display: grid;
      gap: 0.5rem;
    }
    
    .ingredient-item, .step-item {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    /* ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«æ”¹å–„ */
    .table {
      width: 100%;
      max-width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border-spacing: 0;
      margin: 1rem 0;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .table th,
    .table td {
      padding: 0.75rem 0.5rem;
      text-align: left;
      vertical-align: top;
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.4;
      border-bottom: 1px solid var(--border-color);
      max-width: 0;
    }
    
    .table th {
      background: var(--accent-primary);
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .table td {
      font-size: 0.9rem;
      color: var(--text-primary);
    }
    
    /* åˆ—å¹…ã®èª¿æ•´ */
    .table th:nth-child(1),
    .table td:nth-child(1) {
      width: 8%;
      text-align: center;
    }
    
    .table th:nth-child(2),
    .table td:nth-child(2) {
      width: 45%;
    }
    
    .table th:nth-child(3),
    .table td:nth-child(3) {
      width: 25%;
      text-align: right;
    }
    
    .table th:nth-child(4),
    .table td:nth-child(4) {
      width: 22%;
      text-align: center;
    }
    
    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
    @media (max-width: 768px) {
      .table th,
      .table td {
        padding: 0.5rem 0.25rem;
        font-size: 0.8rem;
      }
      
      .table th:nth-child(2),
      .table td:nth-child(2) {
        width: 40%;
      }
      
      .table th:nth-child(3),
      .table td:nth-child(3) {
        width: 30%;
      }
    }
    
    
    /* æ–‡å­—åˆ—è¦‹åˆ‡ã‚Œé˜²æ­¢ã®åŒ…æ‹¬çš„è¨­å®š */
    * {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      box-sizing: border-box !important;
    }
    
    p, span, div, label, button, input, textarea, select {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.5 !important;
    }
    
    .example-urls {
      display: grid;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .example-url {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    
    .example-url:hover {
      border-color: var(--accent-primary);
    }
    
    .example-url .url {
      flex: 1;
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .example-url .label {
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .translate-btn {
      appearance: none;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.6rem 1.2rem;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      width: 100%;
    }
    
    .translate-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(16, 185, 129, 0.25);
    }
    
    .translate-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .translation-selector {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    .translation-selector label {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.9rem;
      min-width: max-content;
    }
    
    .language-select {
      appearance: none;
      background: var(--bg-surface);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.9rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 0.5rem center;
      background-repeat: no-repeat;
      background-size: 1.5em 1.5em;
      min-width: 200px;
    }
    
    .language-select:hover {
      border-color: var(--accent-primary);
    }
    
    .language-select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    @media (max-width: 768px) {
      .translation-selector {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }
      
      .language-select {
        min-width: unset;
        width: 100%;
      }
    }
    
    .results-grid.with-translation {
      grid-template-columns: 1fr 1fr 1fr;
    }
    
    @media (max-width: 1024px) {
      .results-grid.with-translation {
        grid-template-columns: 1fr;
      }
    }
    
    /* ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«ãƒ¬ã‚·ãƒ”è¡¨ç¤º */
    .recipe-section {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--bg-surface);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      word-wrap: break-word;
    }
    
    .recipe-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent-primary);
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      line-height: 1.3;
    }
    
    .recipe-section-weight {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-style: italic;
      margin-bottom: 0.5rem;
      word-wrap: break-word;
    }
    
    .recipe-ingredients-grid {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 0.5rem;
      align-items: start;
      margin-bottom: 0.75rem;
      min-width: 0;
    }
    
    .ingredient-name {
      font-weight: 500;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      min-width: 0;
      line-height: 1.4;
    }
    
    .ingredient-quantity {
      text-align: right;
      font-weight: 600;
      color: var(--accent-primary);
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .ingredient-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
      min-width: 40px;
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .recipe-instructions {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .recipe-instructions p {
      margin-bottom: 0.5rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    @media (max-width: 768px) {
      .recipe-ingredients-grid {
        grid-template-columns: 1fr;
        gap: 0.25rem;
        align-items: stretch;
      }
      
      .ingredient-name {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      
      .ingredient-quantity,
      .ingredient-unit {
        text-align: left;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }
      
      .ingredient-quantity::after {
        content: " ";
      }
      
      .recipe-section-title {
        font-size: 1rem;
        line-height: 1.2;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="import-card">
      <header>
        <h1><i class="fa-solid fa-robot"></i> ãƒ¬ã‚·ãƒ”è‡ªå‹•å–å¾—ãƒ†ã‚¹ãƒˆ</h1>
        <p>Recipe Keeper.appã®ãƒ¬ã‚·ãƒ”å–å¾—ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚URLã‚’å…¥åŠ›ã™ã‚‹ã¨ã€AIï¼ˆGroq/ChatGPTï¼‰ãŒWebã‚µã‚¤ãƒˆã‹ã‚‰ãƒ¬ã‚·ãƒ”æƒ…å ±ã‚’è‡ªå‹•æŠ½å‡ºã—ã¾ã™ã€‚</p>
      </header>

      <!-- å…ƒãƒšãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæŠ½å‡ºçµæœã®å‚ç…§ãƒ»ä¿®æ­£ç”¨ï¼‰ -->
      <section id="sourcePreviewSection" style="margin: 1rem 0;">
        <div style="display:flex; align-items:center; gap: .5rem; flex-wrap: wrap;">
          <input id="sourcePreviewUrl" type="text" placeholder="å…ƒãƒšãƒ¼ã‚¸URLã‚’å…¥åŠ› (ä¾‹: https://cookpad.com/...)" style="flex:1; min-width:240px; padding:.5rem .75rem; border:1px solid #ddd; border-radius:8px; box-sizing:border-box;">
          <button id="loadSourcePreviewBtn" type="button" class="btn secondary">
            <i class="fas fa-eye"></i>
            å…ƒãƒšãƒ¼ã‚¸ã‚’è¡¨ç¤º
          </button>
          <label style="display:flex; align-items:center; gap:.35rem; cursor:pointer;">
            <input id="dockPreviewRight" type="checkbox" checked>
            å³ã«ãƒ‰ãƒƒã‚¯è¡¨ç¤º
          </label>
        </div>
        <div id="sourcePreviewPane" style="margin-top:.75rem; display:none; border:1px solid #e5e7eb; border-radius:10px; overflow:hidden;">
          <div style="padding:.5rem .75rem; background:#f8f9fa; border-bottom:1px solid #e5e7eb; display:flex; justify-content:space-between; align-items:center;">
            <strong style="font-size:.95rem;">å…ƒãƒšãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</strong>
            <small id="sourcePreviewInfo" style="color:#666;">æœªèª­ã¿è¾¼ã¿</small>
          </div>
          <div id="sourcePreviewSplit" style="display:flex; flex-direction:row; gap:0;">
            <iframe id="sourcePreviewFrame" title="source preview" style="width:50%; min-height:60vh; border:0; background:white;"></iframe>
            <div id="sourcePreviewHelp" style="width:50%; min-height:60vh; padding:1rem; box-sizing:border-box; overflow:auto;">
              <p style="margin:0 0 .75rem 0; line-height:1.5; word-wrap:break-word; word-break:break-word; overflow-wrap:break-word; white-space:normal;">æŠ½å‡ºã—ãŸææ–™ãƒ»æ‰‹é †ã‚’å³å´ã®ç·¨é›†æ¬„ã¨è¦‹æ¯”ã¹ãªãŒã‚‰ä¿®æ­£ã§ãã¾ã™ã€‚ã‚µã‚¤ãƒˆãŒiframeã‚’æ‹’å¦ã™ã‚‹å ´åˆã¯ã€ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§HTMLã‚’èª­ã¿è¾¼ã¿ã€<code>srcdoc</code>ã§è¡¨ç¤ºã—ã¾ã™ã€‚</p>
            </div>
          </div>
        </div>
      </section>

      <form id="importForm">
        <label>
          ãƒ¬ã‚·ãƒ”ã‚µã‚¤ãƒˆURL
          <input type="url" id="urlInput" name="url" placeholder="https://cookpad.com/recipe/123456" required>
          <small style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.25rem;">
            å¯¾å¿œã‚µã‚¤ãƒˆ: ã‚¯ãƒƒã‚¯ãƒ‘ãƒƒãƒ‰ã€ã‚¯ãƒ©ã‚·ãƒ«ã€Marmitonã€DelishKitchenã€æ–™ç†ç‹å›½ãªã©
          </small>
        </label>

        <label>
          AI APIé¸æŠ
          <div class="api-selector">
            <div class="api-option selected" data-api="groq">
              <input type="radio" name="api" value="groq" checked>
              <span>Groq (æ¨å¥¨)</span>
            </div>
            <div class="api-option" data-api="chatgpt">
              <input type="radio" name="api" value="chatgpt">
              <span>ChatGPT</span>
            </div>
            <div class="api-option" data-api="gemini">
              <input type="radio" name="api" value="gemini">
              <span>Gemini</span>
            </div>
          </div>
        </label>

        <div class="button-group">
          <button type="submit" id="importButton">
            <i class="fa-solid fa-download"></i> ãƒ¬ã‚·ãƒ”ã‚’å–å¾—
          </button>
          <button type="button" id="imageImportBtn" class="btn secondary">
            <i class="fas fa-camera"></i> ç”»åƒè§£æ
          </button>
        </div>
      </form>

      <div class="status" id="statusRow"></div>

      <div class="example-urls">
        <h3>ãƒ†ã‚¹ãƒˆç”¨URLä¾‹</h3>
        <div class="example-url" data-url="https://cookpad.com/recipe/2798655">
          <span class="label">ã‚¯ãƒƒã‚¯ãƒ‘ãƒƒãƒ‰:</span>
          <span class="url">https://cookpad.com/recipe/2798655</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.kurashiru.com/recipes/c2b1c7c0-1234-5678-9abc-def012345678">
          <span class="label">ã‚¯ãƒ©ã‚·ãƒ«:</span>
          <span class="url">https://www.kurashiru.com/recipes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.marmiton.org/recettes/recette_quiche-lorraine_11242.aspx">
          <span class="label">Marmiton (ä»):</span>
          <span class="url">https://www.marmiton.org/recettes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
      </div>
    </section>

    <div class="results-grid" id="resultsGrid" hidden>
      <div class="result-section">
        <h3><i class="fa-solid fa-utensils"></i> æŠ½å‡ºã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ï¼ˆå…ƒè¨€èªï¼‰</h3>
        <div class="recipe-field" id="recipeImageContainer" style="display: none; margin-bottom: 1rem;">
          <label>æŠ½å‡ºã•ã‚ŒãŸç”»åƒ</label>
          <img id="recipeImage" src="" alt="Recipe Image" style="max-width: 100%; border-radius: 12px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
          <input type="text" id="recipeImageUrlInput" placeholder="ç”»åƒURLã‚’ç·¨é›†ãƒ»å…¥åŠ›" style="width: 100%; margin-top: 0.75rem; padding: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color);">
        </div>
        <div class="recipe-preview" id="recipePreview">
          <div class="recipe-field">
            <label>ã‚¿ã‚¤ãƒˆãƒ«</label>
            <div class="value" id="recipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>èª¬æ˜</label>
            <div class="value" id="recipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>äººæ•°</label>
            <div class="value" id="recipeServings">-</div>
          </div>
          <div class="recipe-field">
            <label>ææ–™</label>
            <div id="flexibleIngredientsDisplay">
              <div class="ingredient-item">ææ–™ãªã—</div>
            </div>
            <div class="inline-actions" style="margin-top:.5rem; display:flex; justify-content:flex-end;">
              <button type="button" id="btnAddCategoryInline" class="btn secondary">ã‚«ãƒ†ã‚´ãƒªã‚’è¿½åŠ </button>
              <button type="button" id="btnAddIngredientInline" class="btn secondary">ææ–™ã‚’è¿½åŠ </button>
            </div>
          </div>
          <div class="recipe-field">
            <label>æ‰‹é †</label>
            <div class="steps-list" id="stepsList">
              <div class="step-item">æ‰‹é †ãªã—</div>
            </div>
            <div class="inline-actions" style="margin-top:.5rem; display:flex; justify-content:flex-end;">
              <button type="button" id="btnAddStepInline" class="btn secondary">æ‰‹é †ã‚’è¿½åŠ </button>
            </div>
          </div>
        </div>
        
        <div class="translation-controls" id="translationControls" style="margin-top: 1rem; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
          <div class="translation-selector">
            <label for="targetLanguage">ç¿»è¨³å…ˆè¨€èª:</label>
            <select id="targetLanguage" class="language-select">
              <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª (Japanese)</option>
              <option value="en">ğŸ‡ºğŸ‡¸ è‹±èª (English)</option>
              <option value="fr">ğŸ‡«ğŸ‡· ãƒ•ãƒ©ãƒ³ã‚¹èª (FranÃ§ais)</option>
              <option value="it">ğŸ‡®ğŸ‡¹ ã‚¤ã‚¿ãƒªã‚¢èª (Italiano)</option>
              <option value="de">ğŸ‡©ğŸ‡ª ãƒ‰ã‚¤ãƒ„èª (Deutsch)</option>
              <option value="es">ğŸ‡ªğŸ‡¸ ã‚¹ãƒšã‚¤ãƒ³èª (EspaÃ±ol)</option>
              <option value="ko">ğŸ‡°ğŸ‡· éŸ“å›½èª (í•œêµ­ì–´)</option>
              <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­å›½èª (ä¸­æ–‡)</option>
            </select>
          </div>
          <button type="button" id="translateButton" class="translate-btn">
            <i class="fa-solid fa-language"></i> <span id="translateButtonText">ç¿»è¨³ã™ã‚‹</span>
          </button>
          <button type="button" id="btnApplyOriginalEdits" class="btn">
            ç·¨é›†å†…å®¹ã‚’é©ç”¨
          </button>
        </div>
      </div>

      

      <div class="result-section" id="translationSection" style="display: none;">
        <h3><i class="fa-solid fa-language"></i> <span id="translationSectionTitle">ç¿»è¨³çµæœ</span></h3>
        <div class="recipe-field" id="translatedRecipeImageContainer" style="display: none; margin-bottom: 1rem;">
          <label>ç”»åƒ</label>
          <img id="translatedRecipeImage" src="" alt="Translated Recipe Image" style="max-width: 100%; border-radius: 12px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
        </div>
        <div class="recipe-preview" id="translatedRecipePreview">
          <div class="recipe-field">
            <label>ã‚¿ã‚¤ãƒˆãƒ«</label>
            <div class="value" id="translatedRecipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>èª¬æ˜</label>
            <div class="value" id="translatedRecipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>äººæ•°</label>
            <div class="value" id="translatedRecipeServings">-</div>
          </div>
          <div class="recipe-field">
        <label>ææ–™</label>
            <div id="flexibleTranslatedIngredientsDisplay">
              <div class="ingredient-item">ç¿»è¨³ãªã—</div>
            </div>
          </div>
          <div class="recipe-field">
            <label>æ‰‹é †</label>
            <div class="steps-list" id="translatedStepsList">
              <div class="step-item">ç¿»è¨³ãªã—</div>
            </div>
          </div>
        </div>
      </div>

      <!-- ä¿å­˜ãƒ¢ãƒ¼ãƒ‰é¸æŠï¼†ä¿å­˜ã‚¨ãƒªã‚¢ï¼ˆiframeä¸»ä½“ã®ãƒ†ãƒ¼ãƒ–ãƒ«UIï¼‰ -->
      <div class="result-section" id="saveSection" style="display: none;">
        <h3><i class="fa-solid fa-save"></i> ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜</h3>
        <table class="save-preview-table" style="width:100%; border-collapse:collapse; background: var(--bg-surface);">
          <thead>
            <tr>
              <th style="text-align:left; padding:.5rem; border-bottom:1px solid var(--border-color);">å…ƒãƒšãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå³ã®ãƒ•ã‚©ãƒ¼ãƒ ã§å³æ™‚ä¿®æ­£â†’ä¿å­˜ï¼‰</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding:.5rem;">
                <div style="display:flex; gap:.5rem; align-items:center;">
                  <input id="savePaneUrl" type="text" placeholder="URL (ç©ºãªã‚‰ä¸Šã®URLæ¬„ã‚’ä½¿ç”¨)" style="flex:1; min-width:220px; padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <button id="savePaneLoadBtn" type="button" class="btn">è¡¨ç¤º</button>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.25rem;">
                <iframe id="savePaneFrame" title="save pane preview" style="width:100%; height:420px; border:1px solid var(--border-color); display:block; background:white;"></iframe>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem;">
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.5rem;">
                  <input id="quickTitle" type="text" placeholder="ã‚¿ã‚¤ãƒˆãƒ«ã‚’ä¿®æ­£" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickServings" type="text" placeholder="äººæ•°ï¼ˆä¾‹: 4ï¼‰" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickNotes" type="text" placeholder="ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                </div>
                <div style="display:grid; grid-template-columns: 2fr 1fr 1fr auto; gap:.5rem; align-items:center; margin-top:.5rem;">
                  <input id="quickIngName" type="text" placeholder="ææ–™å" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickIngQty" type="text" placeholder="åˆ†é‡" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickIngUnit" type="text" placeholder="å˜ä½" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <button id="quickAddIng" type="button" class="btn">ææ–™ã‚’è¿½åŠ </button>
                </div>
                <div style="margin-top:.5rem;">
                  <table id="quickIngTable" style="width:100%; border-collapse:collapse;">
                    <thead>
                      <tr>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">ææ–™å</th>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">åˆ†é‡</th>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">å˜ä½</th>
                        <th style="width:72px; padding:.4rem; border-bottom:1px solid var(--border-color);"></th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem;">
                <div id="saveModeGroup" style="display:flex; gap:.5rem; flex-wrap:wrap;">
                  <label style="display:flex; align-items:center; gap:.35rem; cursor:pointer;">
                    <input type="radio" name="saveMode" value="original" checked>
                    <span>åŸèªã®ã¿</span>
                  </label>
                  <label id="saveModeBothLabel" style="display:flex; align-items:center; gap:.35rem; opacity:.7; cursor:pointer;">
                    <input type="radio" name="saveMode" value="both" disabled>
                    <span>åŸèªï¼‹ç¿»è¨³ï¼ˆä¸¡æ–¹ï¼‰</span>
                  </label>
                  <label id="saveModeTranslatedLabel" style="display:flex; align-items:center; gap:.35rem; opacity:.7; cursor:pointer;">
                    <input type="radio" name="saveMode" value="translated" disabled>
                    <span>ç¿»è¨³ã®ã¿</span>
                  </label>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem; text-align:right;">
                <button type="button" id="saveByModeButton" class="btn primary">
                  <i class="fa-solid fa-circle-check"></i> é¸æŠã—ã¦ä¿å­˜
                </button>
              </td>
            </tr>
          </tbody>
        </table>
        <div style="margin-top:.5rem; color: var(--text-secondary); font-size:.9rem;">
          <span id="saveModeHint">ä¿å­˜ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ã€Œé¸æŠã—ã¦ä¿å­˜ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</span>
        </div>
      </div>

    </div>
  </main>

  <!-- ç”»åƒè§£æãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="image-import-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">ç”»åƒã‹ã‚‰ãƒ¬ã‚·ãƒ”ã‚’æŠ½å‡º</h2>
        <button id="image-import-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="image-upload-section" id="uploadArea">
          <div class="drag-overlay">
            <div>
              <i class="fas fa-download" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
              <div>ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„</div>
            </div>
          </div>
          <i class="fas fa-cloud-upload-alt" style="font-size: 3rem; color: #666; margin-bottom: 1rem;"></i>
          <p style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%;">ãƒ¬ã‚·ãƒ”ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„</p>
          <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%; line-height: 1.5;">
            ç”»åƒã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button type="button" id="fileSelectBtn" class="btn primary">
              <i class="fas fa-folder-open"></i> ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¸æŠ
            </button>
            <button type="button" id="cameraBtn" class="btn secondary">
              <i class="fas fa-camera"></i> ã‚«ãƒ¡ãƒ©ã§æ’®å½±
            </button>
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <input type="file" id="cameraInput" accept="image/*" capture="user" style="display: none;">
        </div>
        
        <div id="previewArea" style="display: none; text-align: center; margin-top: 1rem;">
          <img id="previewImage" class="image-preview" alt="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
          <div style="margin-top: 1rem;">
            <button type="button" id="analyzeButton" class="btn" type="button">
              <i class="fas fa-search"></i> è§£æã—ã¦ãƒ¬ã‚·ãƒ”ã‚’æŠ½å‡º
            </button>
            <button type="button" id="clearImageButton" class="btn ghost">
              <i class="fas fa-trash"></i> ã‚¯ãƒªã‚¢
            </button>
          </div>
        </div>
        
        <div id="imageMessageArea" style="margin-top: 1rem;"></div>
      </div>
      <div class="modal-footer">
        <button id="imageImportCancelBtn" class="btn ghost" type="button">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <script>
    const statusRow = document.getElementById('statusRow');
    const resultsGrid = document.getElementById('resultsGrid');
    const importButton = document.getElementById('importButton');
    const urlInput = document.getElementById('urlInput');
    const translateButton = document.getElementById('translateButton');
    const translationSection = document.getElementById('translationSection');
    const translationControls = document.getElementById('translationControls');
    const targetLanguageSelect = document.getElementById('targetLanguage');
    const translateButtonText = document.getElementById('translateButtonText');
    const translationSectionTitle = document.getElementById('translationSectionTitle');

    const LANGUAGE_METADATA = {
      ja: { label: 'æ—¥æœ¬èª', prompt: 'Japanese' },
      en: { label: 'è‹±èª', prompt: 'English' },
      fr: { label: 'ãƒ•ãƒ©ãƒ³ã‚¹èª', prompt: 'French' },
      it: { label: 'ã‚¤ã‚¿ãƒªã‚¢èª', prompt: 'Italian' },
      de: { label: 'ãƒ‰ã‚¤ãƒ„èª', prompt: 'German' },
      es: { label: 'ã‚¹ãƒšã‚¤ãƒ³èª', prompt: 'Spanish' },
      ko: { label: 'éŸ“å›½èª', prompt: 'Korean' },
      zh: { label: 'ä¸­å›½èª', prompt: 'Chinese' }
    };

    const DEFAULT_TRANSLATION_LANGUAGE = 'en';

    const getLanguageLabel = (code) => LANGUAGE_METADATA[code]?.label || 'é¸æŠè¨€èª';
    const getLanguagePromptName = (code) => LANGUAGE_METADATA[code]?.prompt || code;
    
    // ç”»åƒè§£æç”¨ã®å¤‰æ•°
    let currentFile = null;
    const imageImportBtn = document.getElementById('imageImportBtn');
    const imageModal = document.getElementById('image-import-modal');
    const imageModalCloseBtn = document.getElementById('image-import-modal-close-btn');
    const imageImportCancelBtn = document.getElementById('imageImportCancelBtn');
    const fileSelectBtn = document.getElementById('fileSelectBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const imageInput = document.getElementById('imageInput');
    const cameraInput = document.getElementById('cameraInput');
    const previewArea = document.getElementById('previewArea');
    const previewImage = document.getElementById('previewImage');
    const analyzeButton = document.getElementById('analyzeButton');
    const clearImageButton = document.getElementById('clearImageButton');
    const imageMessageArea = document.getElementById('imageMessageArea');
    
    let currentRecipeData = null;
    let isJapaneseContent = false;
    
    let sb;
    
    // Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–
    const initSupabase = () => {
      try {
        if (typeof supabase !== 'undefined' && window.APP_CONFIG) {
          sb = supabase.createClient(
            window.APP_CONFIG.SUPABASE_URL,
            window.APP_CONFIG.SUPABASE_ANON_KEY
          );
          console.log('âœ… Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–æˆåŠŸ');
          return true;
        } else {
          console.error('âŒ Supabase ã¾ãŸã¯ APP_CONFIG ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
          return false;
        }
      } catch (error) {
        console.error('âŒ Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        return false;
      }
    };

    function extractMainImageUrl(html, baseUrl) {
      try {
          const doc = new DOMParser().parseFromString(html, 'text/html');

          // 1. Check for Open Graph image
          const ogImage = doc.querySelector('meta[property="og:image"]');
          if (ogImage && ogImage.content) {
              return new URL(ogImage.content, baseUrl).href;
          }

          // 2. Check for Twitter Card image
          const twitterImage = doc.querySelector('meta[name="twitter:image"]');
          if (twitterImage && twitterImage.content) {
              return new URL(twitterImage.content, baseUrl).href;
          }

          // 3. Check for JSON-LD Recipe schema
          const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
          for (const script of jsonLdScripts) {
              try {
                  const jsonData = JSON.parse(script.textContent);
                  const findImage = (node) => {
                      if (node && (node['@type'] === 'Recipe' || (Array.isArray(node['@type']) && node['@type'].includes('Recipe')))) {
                          if (node.image) {
                              const image = Array.isArray(node.image) ? node.image[0] : node.image;
                              if (typeof image === 'string') return image;
                              if (image && image.url) return image.url;
                          }
                      }
                      return null;
                  };

                  let imageUrl = findImage(jsonData);
                  if (imageUrl) return new URL(imageUrl, baseUrl).href;

                  if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                      for (const node of jsonData['@graph']) {
                          imageUrl = findImage(node);
                          if (imageUrl) return new URL(imageUrl, baseUrl).href;
                      }
                  }
              } catch (e) {
                  console.warn('Error parsing JSON-LD', e);
              }
          }

          // 4. Fallback: Find the largest image in the body (heuristic)
          let largestImage = null;
          let maxDim = 0;
          const images = doc.body.getElementsByTagName('img');
          for (const img of images) {
              const width = parseInt(img.width || img.getAttribute('width') || '0', 10);
              const height = parseInt(img.height || img.getAttribute('height') || '0', 10);
              const dim = width * height;
              if (dim > maxDim) {
                  maxDim = dim;
                  largestImage = img;
              }
          }
          if (largestImage && largestImage.src) {
              // Ignore tiny images
              if (maxDim > 20000) { // e.g., > 200x100
                    return new URL(largestImage.src, baseUrl).href;
              }
          }

      } catch (error) {
          console.error('Error extracting main image:', error);
      }

      return null;
    }

    const setStatus = (message, type = 'info', icon = 'fa-spinner fa-spin') => {
      if (!message) {
        statusRow.textContent = '';
        statusRow.className = 'status';
        return;
      }
      
      statusRow.className = `status ${type}`;
      statusRow.innerHTML = `<i class="fa-solid ${icon}"></i><span>${message}</span>`;
    };

    // APIé¸æŠã®å‡¦ç†
    document.querySelectorAll('.api-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.api-option').forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        option.querySelector('input[type="radio"]').checked = true;
      });
    });

    // ä¾‹URLé¸æŠã®å‡¦ç†
    document.querySelectorAll('.example-url').forEach(example => {
      example.addEventListener('click', () => {
        const url = example.dataset.url;
        urlInput.value = url;
        urlInput.focus();
      });
    });

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«Supabaseã‚’åˆæœŸåŒ–
    window.addEventListener('load', () => {
      if (!initSupabase()) {
        setStatus('Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error', 'fa-triangle-exclamation');
      }
    });

    // ç”»åƒè§£æãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    imageImportBtn.addEventListener('click', () => {
      imageModal.style.display = 'flex';
    });

    imageModalCloseBtn.addEventListener('click', closeImageModal);
    imageImportCancelBtn.addEventListener('click', closeImageModal);

    imageModal.addEventListener('click', (e) => {
      if (e.target === imageModal) {
        closeImageModal();
      }
    });

    fileSelectBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleNewInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleNewInputChange);
      newInput.addEventListener('input', handleNewInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    cameraBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.setAttribute('capture', 'user');
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleCameraInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleCameraInputChange);
      newInput.addEventListener('input', handleCameraInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    analyzeButton.addEventListener('click', analyzeImage);
    clearImageButton.addEventListener('click', clearImage);

    // è¨€èªé¸æŠã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
    targetLanguageSelect.addEventListener('change', updateTranslationUI);

    // ãƒšãƒ¼ã‚¸å…¨ä½“ã§ã®ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚’é˜²æ­¢
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    const uploadArea = document.getElementById('uploadArea');
    
    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('dragenter', handleDragEnter);
    uploadArea.addEventListener('dragleave', handleDragLeave);
    uploadArea.addEventListener('drop', handleDrop);
    
    // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
    uploadArea.addEventListener('click', (e) => {
      // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯é™¤å¤–
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
      }
      fileSelectBtn.click();
    });

    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ãƒãƒ³ãƒ‰ãƒ©ãƒ¼é–¢æ•°
    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function handleDragEnter(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // å­è¦ç´ ã‹ã‚‰å‡ºãŸå ´åˆã¯ç„¡è¦–
      if (!uploadArea.contains(e.relatedTarget)) {
        uploadArea.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        
        // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
        if (file.type.startsWith('image/')) {
          handleFile(file);
        } else {
          showImageMessage('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„', 'error');
        }
      }
    }

    function updateTranslationUI() {
      const selectedLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
      const languageName = getLanguageLabel(selectedLanguage);
      if (translateButtonText) {
        if (translateButton && !translateButton.contains(translateButtonText)) {
          translateButton.innerHTML = '<i class="fa-solid fa-language"></i> ';
          translateButton.appendChild(translateButtonText);
        }
        translateButtonText.textContent = `${languageName}ã«ç¿»è¨³`;
      }
      translationSectionTitle.textContent = `${languageName}ç¿»è¨³`;
    }

    function closeImageModal() {
      imageModal.style.display = 'none';
    }

    function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) {
        showImageMessage('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
        return;
      }

      currentFile = file;
      window.__ocrCurrentFile = file;
      window.currentImageFiles = [file];

      // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewArea.style.display = 'block';
        document.getElementById('uploadArea').style.display = 'none';
        analyzeButton.disabled = false;
      };
      reader.readAsDataURL(file);

      showImageMessage('ç”»åƒãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚ã€Œè§£æã—ã¦ãƒ¬ã‚·ãƒ”ã‚’æŠ½å‡ºã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚', 'success');
    }

    function clearImage() {
      currentFile = null;
      window.__ocrCurrentFile = null;
      window.currentImageFiles = [];
      previewImage.src = '';
      previewArea.style.display = 'none';
      document.getElementById('uploadArea').style.display = 'block';
      analyzeButton.disabled = true;
      showImageMessage('', '');
    }

    function showImageMessage(message, type) {
      if (!message) {
        imageMessageArea.innerHTML = '';
        return;
      }

      const icons = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-triangle',
        info: 'fa-info-circle',
        loading: 'fa-spinner fa-spin'
      };

      const colors = {
        success: 'var(--success-color)',
        error: 'var(--error-color)',
        info: 'var(--accent-primary)',
        loading: 'var(--accent-primary)'
      };

      imageMessageArea.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; border-radius: 8px; background: ${colors[type] || colors.info}15; color: ${colors[type] || colors.info}; border: 1px solid ${colors[type] || colors.info}25;">
          <i class="fas ${icons[type] || icons.info}"></i>
          <span>${message}</span>
        </div>
      `;
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
        reader.readAsDataURL(file);
      });
    }

    function getActiveOcrFile() {
      if (currentFile instanceof File) {
        return currentFile;
      }
      if (window.__ocrCurrentFile instanceof File) {
        return window.__ocrCurrentFile;
      }
      if (Array.isArray(window.currentImageFiles) && window.currentImageFiles.length > 0) {
        const candidate = window.currentImageFiles.find(f => f instanceof File);
        if (candidate) {
          window.__ocrCurrentFile = candidate;
          currentFile = candidate;
          return candidate;
        }
      }
      return null;
    }

    async function analyzeWithAzureDocumentIntelligence(base64Payload, selectedProvider, providerInfo) {
      console.log('ğŸ›°ï¸ Azure Document Intelligenceå‘¼ã³å‡ºã—æº–å‚™', { selectedProvider });

      const { data: docResult, error: docError } = await sb.functions.invoke('call-document-intelligence', {
        body: {
          image: base64Payload,
          processorType: 'RECIPE_PROCESSOR',
          aiProvider: selectedProvider
        }
      });

      if (docError) {
        console.error('âŒ call-document-intelligence error:', docError);
        throw new Error(docError.message || docError.error || 'Azure Document Intelligenceå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      if (!docResult?.success) {
        console.error('âŒ call-document-intelligence response error:', docResult);
        throw new Error(docResult?.error || 'ç”»åƒè§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const recipeData = docResult.data;
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
      }

      recipeData.aiProvider = selectedProvider;
      recipeData.aiProviderModel = providerInfo?.model || null;

      console.log('ğŸ“„ Azure + AIè§£æçµæœ:', recipeData);
      return recipeData;
    }

    async function analyzeWithVisionFallback(base64Payload, fileType, selectedProvider, providerInfo) {
      const mimeType = fileType || 'image/png';
      console.log('ğŸ›°ï¸ Gemini Visionãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–‹å§‹', { selectedProvider, mimeType });

      const { data: visionResult, error: visionError } = await sb.functions.invoke('call-vision-api', {
        body: {
          contents: [{
            parts: [
              {
                text: 'Extract all text from this recipe image. Preserve Japanese characters, numbers, and line breaks as they appear.'
              },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Payload
                }
              }
            ]
          }]
        }
      });

      if (visionError) {
        console.error('âŒ call-vision-api error:', visionError);
        throw new Error(visionError.message || visionError.error || 'Gemini Visionå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const extractedTextParts = visionResult?.candidates?.[0]?.content?.parts || [];
      const extractedText = extractedTextParts
        .map(part => part?.text || '')
        .filter(Boolean)
        .join('\n')
        .trim();

      if (!extractedText) {
        console.error('âŒ Gemini Visionã‹ã‚‰æœ‰åŠ¹ãªãƒ†ã‚­ã‚¹ãƒˆãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ:', visionResult);
        throw new Error('Gemini Visionã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
      }

      console.log('ğŸ“ Gemini VisionæŠ½å‡ºãƒ†ã‚­ã‚¹ãƒˆ(å†’é ­):', extractedText.substring(0, 200));

      // æŠ½å‡ºã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’AIè§£æã‚·ã‚¹ãƒ†ãƒ ã«é€ã‚‹
      const selectedApi = document.querySelector('input[name="api"]:checked').value;
      const recipeData = await analyzeRecipeWithAI(extractedText, null, selectedApi);
      
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('AIè§£æçµæœãŒç„¡åŠ¹ã§ã™');
      }
      
      recipeData.aiProvider = recipeData.aiProvider || selectedProvider;
      recipeData.aiProviderModel = recipeData.aiProviderModel || providerInfo?.model || null;
      
      console.log('âœ… Gemini Vision + AIè§£ææˆåŠŸ:', {
        provider: recipeData.aiProvider,
        ingredients: recipeData.ingredients?.length || 0,
        steps: recipeData.steps?.length || 0
      });
      
      return recipeData;
    }

    async function analyzeImage() {
      console.log('ğŸ” analyzeImage function called');
      const activeFile = getActiveOcrFile();
      
      if (!activeFile) {
        console.error('âŒ No currentFile available');
        showImageMessage('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
        return;
      }

      showImageMessage('Azureã§OCRè§£æã‚’é–‹å§‹ã—ã¾ã—ãŸ...', 'loading');
      analyzeButton.disabled = true;

      try {
        const base64 = await fileToBase64(activeFile);
        console.log('âœ… Base64 conversion completed, size:', base64.length);
        const base64Payload = base64.includes(',') ? base64.split(',')[1] : base64;

        const selectedApi = document.querySelector('input[name="api"]:checked').value;
        const providerInfo = { key: selectedApi };
        console.log('ğŸ¤– Selected AI provider:', selectedApi);

        let recipeData = null;
        let analysisSource = '';

        try {
          showImageMessage(`Azureã§OCRå¾Œã€${selectedApi.toUpperCase()}ã§è§£æä¸­...`, 'loading');
          recipeData = await analyzeWithAzureDocumentIntelligence(base64Payload, selectedApi, providerInfo);
          analysisSource = `Azure Document Intelligence + ${selectedApi.toUpperCase()}`;
        } catch (azureError) {
          console.warn('âš ï¸ Azure Document Intelligenceè§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚Gemini Visionãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è©¦ã¿ã¾ã™ã€‚', azureError);
          showImageMessage('Azureè§£æã«å¤±æ•—ã—ãŸãŸã‚ã€Gemini Visionã«åˆ‡ã‚Šæ›¿ãˆã¦ã„ã¾ã™...', 'info');

          try {
            recipeData = await analyzeWithVisionFallback(base64Payload, activeFile.type, selectedApi, providerInfo);
            analysisSource = `Gemini Vision + ${selectedApi.toUpperCase()}`;
          } catch (fallbackError) {
            console.error('âŒ Gemini Visionãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚‚å¤±æ•—ã—ã¾ã—ãŸ', fallbackError);
            throw fallbackError;
          }
        }

        if (!recipeData || typeof recipeData !== 'object') {
          throw new Error('ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
        }

        console.log(`ğŸ“„ è§£æçµæœ (${analysisSource}):`, recipeData);
        
        // çµæœã‚’è¡¨ç¤º
        displayRecipeResults(recipeData, analysisSource);
        showImageMessage('ç”»åƒè§£æãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
        closeImageModal();

      } catch (error) {
        console.error('âŒ ç”»åƒè§£æã‚¨ãƒ©ãƒ¼:', error);
        showImageMessage('ç”»åƒè§£æã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (error.message || error), 'error');
      } finally {
        analyzeButton.disabled = !currentFile;
      }
    }

    // ç¿»è¨³ã«ä¸è¦ãªä¸€æ™‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–ã‚Šé™¤ãã€APIãŒæœŸå¾…ã™ã‚‹å½¢ã«æ•´ãˆã‚‹
    function sanitizeRecipeForTranslation(data) {
      const src = data || {};
      const out = {
        title: src.title || '',
        description: src.description || '',
        servings: src.servings || '',
        image_url: src.image_url || '',
        ingredients: Array.isArray(src.ingredients) ? src.ingredients
          .filter(i => i && (i.item || i.name || i.quantity || i.unit))
          .map(i => {
            const sectionScoped = i?.sectionTitle || i?.section_title;
            const normalizedSection = sectionScoped ? sectionScoped.toString().trim() : '';
            return {
              item: (i.item || i.name || '').toString().trim(),
              quantity: (i.quantity || i.amount || '').toString().trim(),
              unit: (i.unit || i.measure || '').toString().trim(),
              ...(normalizedSection ? { sectionTitle: normalizedSection } : {})
            };
          }) : [],
        steps: Array.isArray(src.steps) ? src.steps.map(s =>
          typeof s === 'string' ? s : (s.step || s.instruction || s.text || '')
        ) : []
      };
      return out;
    }

    function normalizeSectionTitleValue(value) {
      if (value === undefined || value === null) return '';
      if (typeof value === 'string') return value.trim();
      return String(value).trim();
    }

    function ensureIngredientSectionTitles(sourceIngredients, translatedIngredients) {
      if (!Array.isArray(translatedIngredients)) return [];
      const sourceSections = Array.isArray(sourceIngredients)
        ? sourceIngredients.map(src => normalizeSectionTitleValue(src?.sectionTitle))
        : [];
      return translatedIngredients.map((ing, index) => {
        let out = ing;
        if (!out || typeof out !== 'object') {
          out = { item: typeof ing === 'string' ? ing : '' };
        } else {
          out = { ...out };
        }
        const translatedSection = normalizeSectionTitleValue(out.sectionTitle || out.section_title);
        const sourceSection = sourceSections[index] || '';
        const finalSection = translatedSection || sourceSection;
        if (finalSection) {
          out.sectionTitle = finalSection;
        } else if (out.sectionTitle) {
          out.sectionTitle = normalizeSectionTitleValue(out.sectionTitle);
        }
        if ('section_title' in out) {
          delete out.section_title;
        }
        return out;
      });
    }

    function extractTranslatedIngredients() {
      const rows = document.querySelectorAll('#flexibleTranslatedIngredientsDisplay table tbody tr');
      if (rows.length === 0) {
        const sectionBlocks = document.querySelectorAll('#flexibleTranslatedIngredientsDisplay .recipe-section');
        if (sectionBlocks.length > 0) {
          const list = [];
          sectionBlocks.forEach(section => {
            const sectionTitle = (section.querySelector('.recipe-section-title')?.textContent || '').trim();
            const grids = section.querySelectorAll('.recipe-ingredients-grid');
            grids.forEach(grid => {
              const item = (grid.querySelector('.ingredient-name')?.textContent || '').trim();
              const quantity = (grid.querySelector('.ingredient-quantity')?.textContent || '').trim();
              const unit = (grid.querySelector('.ingredient-unit')?.textContent || '').trim();
              if (!item && !quantity && !unit) return;
              list.push({ item, quantity, unit, sectionTitle });
            });
          });
          return list;
        }
      }

      return Array.from(rows).map(row => {
        const tds = row.querySelectorAll('td');
        if (tds.length >= 4) {
          return {
            item: tds[1].textContent.trim(),
            quantity: tds[2].textContent.trim(),
            unit: tds[3].textContent.trim()
          };
        }
        return null;
      }).filter(v => v && v.item && v.item !== 'ç¿»è¨³ãªã—');
    }

    function extractTranslatedSteps() {
      const translatedStepsElements = document.querySelectorAll('#translatedStepsList .step-text, #translatedStepsList .step-item');
      return Array.from(translatedStepsElements)
        .map(el => el.textContent.replace(/^\d+\.?\s*/, '').trim())
        .filter(step => step && step !== 'ç¿»è¨³ãªã—' && step !== 'æ‰‹é †ãªã—');
    }

    // ç¿»è¨³ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    translateButton.addEventListener('click', async () => {
      // ç›´å‰ã®ç·¨é›†ã‚’åŒæœŸ
      try { syncCurrentRecipeFromDOM({ showAlert: false }); } catch (_) {}
      if (!currentRecipeData) {
        setStatus('ç¿»è¨³ã™ã‚‹ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error', 'fa-triangle-exclamation');
        return;
      }

      translateButton.disabled = true;
      translateButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> ç¿»è¨³ä¸­...';

      try {
        const payload = sanitizeRecipeForTranslation(currentRecipeData);
        console.log('ğŸŒ ç¿»è¨³é–‹å§‹ï¼ˆã‚µãƒ‹ã‚¿ã‚¤ã‚ºå¾Œï¼‰:', payload);
        const activeLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
        console.log('ğŸŒ é¸æŠã•ã‚ŒãŸè¨€èª:', activeLanguage);
        console.log('ğŸŒ ç¾åœ¨ã®ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿æ§‹é€ :', {
          hasTitle: !!payload?.title,
          hasDescription: !!payload?.description,
          hasIngredients: !!payload?.ingredients,
          hasSteps: !!payload?.steps,
          ingredientsCount: payload?.ingredients?.length || 0,
          stepsCount: payload?.steps?.length || 0
        });
        
        const translatedData = await translateRecipeData(payload);
        console.log('âœ… ç¿»è¨³å®Œäº†:', translatedData);
        console.log('âœ… ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã®å‹:', typeof translatedData);
        console.log('âœ… ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ¼:', Object.keys(translatedData || {}));
        
        console.log('ğŸ–¼ï¸ ç¿»è¨³çµæœè¡¨ç¤ºé–‹å§‹...');
        displayTranslatedResults(translatedData);
        console.log('ğŸ–¼ï¸ ç¿»è¨³çµæœè¡¨ç¤ºå®Œäº†');
        
        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’3ã‚«ãƒ©ãƒ ã«å¤‰æ›´
        console.log('ğŸ¨ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´é–‹å§‹...');
        resultsGrid.classList.add('with-translation');
        translationSection.style.display = 'block';
        // ç¿»è¨³å¾Œã«ä¿å­˜ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–
        try { showSaveButtons(); } catch (e) { console.debug('showSaveButtons not ready'); }
        console.log('ğŸ¨ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´å®Œäº†');
        
        const selectedLanguage = activeLanguage;
        const languageName = getLanguageLabel(selectedLanguage);
        translateButton.innerHTML = `<i class="fa-solid fa-check"></i> ${languageName}ç¿»è¨³å®Œäº†`;
        console.log('âœ… ç¿»è¨³å‡¦ç†å…¨ä½“å®Œäº†');
        
      } catch (error) {
        console.error('âŒ ç¿»è¨³ã‚¨ãƒ©ãƒ¼:', error);
        setStatus(`ç¿»è¨³ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error', 'fa-triangle-exclamation');
        updateTranslationUI();
      } finally {
        translateButton.disabled = false;
      }
    });

    // ãƒ¬ã‚·ãƒ”å–å¾—ãƒ•ã‚©ãƒ¼ãƒ ã®å‡¦ç†
    document.getElementById('importForm').addEventListener('submit', async (event) => {
      event.preventDefault();

      if (!sb) {
        if (!initSupabase()) {
          setStatus('Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆ©ç”¨ã§ãã¾ã›ã‚“', 'error', 'fa-triangle-exclamation');
          return;
        }
      }

      const url = urlInput.value.trim();
      const selectedApi = document.querySelector('input[name="api"]:checked').value;

      if (!url) {
        setStatus('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error', 'fa-circle-exclamation');
        return;
      }

      // URLã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
      try {
        new URL(url);
      } catch (urlError) {
        setStatus('æœ‰åŠ¹ãªURLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error', 'fa-circle-exclamation');
        return;
      }

      resultsGrid.hidden = true;
      setStatus('HTMLã‚’å–å¾—ä¸­ã§ã™...', 'info', 'fa-spinner fa-spin');
      importButton.disabled = true;

      try {
        const startTime = Date.now();
        console.log('ğŸš€ ãƒ¬ã‚·ãƒ”å–å¾—é–‹å§‹:', { url, selectedApi });
        
        // ã‚¹ãƒ†ãƒƒãƒ—1: HTMLã‚’å–å¾—
        setStatus('Webã‚µã‚¤ãƒˆã‹ã‚‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—ä¸­...', 'info', 'fa-spinner fa-spin');
        const htmlData = await fetchHtmlFromUrl(url);
        
        if (!htmlData || !htmlData.html) {
          throw new Error('Webã‚µã‚¤ãƒˆã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
        }
        
        console.log('âœ… HTMLå–å¾—å®Œäº†:', htmlData.html.length, 'æ–‡å­—');

        const imageUrl = extractMainImageUrl(htmlData.html, url);
        console.log('ğŸ–¼ï¸ Extracted image URL:', imageUrl);
        
        // ã‚¹ãƒ†ãƒƒãƒ—2: AIè§£æ
        setStatus(`${selectedApi.toUpperCase()} APIã§ãƒ¬ã‚·ãƒ”ã‚’è§£æä¸­...`, 'info', 'fa-spinner fa-spin');
        const recipeData = await analyzeRecipeWithAI(htmlData.html, url, selectedApi);

        if (imageUrl) {
            recipeData.image_url = imageUrl;
        }
        
        console.log('âœ… AIè§£æå®Œäº†:', recipeData);
        
        // URLã‚’è¨˜éŒ²ï¼ˆç¿»è¨³æ™‚ã«å‚ç…§ã™ã‚‹ãŸã‚ï¼‰
        window.lastProcessedUrl = url;
        
        // çµæœã‚’è¡¨ç¤º
        displayRecipeResults(recipeData, { 
          url, 
          selectedApi, 
          htmlLength: htmlData.html.length,
          processingTime: Date.now() - startTime
        });
        
        resultsGrid.hidden = false;
        setStatus('ãƒ¬ã‚·ãƒ”ã®å–å¾—ãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success', 'fa-circle-check');
        
      } catch (err) {
        console.error('âŒ ãƒ¬ã‚·ãƒ”å–å¾—ã‚¨ãƒ©ãƒ¼:', err);
        setStatus(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error', 'fa-triangle-exclamation');
        
        resultsGrid.hidden = false;
      } finally {
        importButton.disabled = false;
      }
    });

    // HTMLã‚’å–å¾—ã™ã‚‹é–¢æ•°
    async function fetchHtmlFromUrl(url) {
      const { data, error } = await sb.functions.invoke('fetch-url-content', {
        body: { url }
      });

      if (error) {
        throw new Error(`HTMLå–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || 'HTMLå–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      return data;
    }

    // AIã§ãƒ¬ã‚·ãƒ”ã‚’è§£æã™ã‚‹é–¢æ•°
    async function analyzeRecipeWithAI(html, url, apiType) {
      // ã‚µã‚¤ãƒˆã®è¨€èªã‚’åˆ¤å®š
      const siteLanguage = detectSiteLanguage(html, url);
      console.log('ğŸŒ ã‚µã‚¤ãƒˆè¨€èªåˆ¤å®š:', siteLanguage);
      
      let functionName;
      let requestBody;
      
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚ŒãŸHTMLã‚’å–å¾—
      const cleanedHtml = cleanHtml(html, url);
      
      switch (apiType) {
        case 'groq':
          functionName = 'call-groq-api';
          requestBody = {
            text: generateRecipeExtractionPrompt(cleanedHtml, url, siteLanguage),
            mode: 'recipe_extraction',
            siteLanguage: siteLanguage.code,
            isJapaneseSite: siteLanguage.isJapanese
          };
          break;
        case 'chatgpt':
          functionName = 'call-chatgpt-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        case 'gemini':
          functionName = 'call-gemini-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        default:
          throw new Error(`æœªå¯¾å¿œã®API: ${apiType}`);
      }

      console.log(`ğŸ¤– ${apiType.toUpperCase()} APIå‘¼ã³å‡ºã—é–‹å§‹:`, { functionName, bodyLength: JSON.stringify(requestBody).length });
      
      const { data, error } = await sb.functions.invoke(functionName, {
        body: requestBody
      });

      console.log(`ğŸ“¡ ${apiType.toUpperCase()} APIãƒ¬ã‚¹ãƒãƒ³ã‚¹:`, { data, error });

      if (error) {
        throw new Error(`AIè§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
      }

      // Groq APIã®å ´åˆã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†
      if (apiType === 'groq') {
        if (!data.success) {
          throw new Error(data.error || 'Groq APIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
        
        // Groq APIã®contentã‹ã‚‰JSONã‚’æŠ½å‡ºï¼ˆæ”¹è‰¯ç‰ˆï¼‰
        const content = data.content || '';
        console.log('ğŸ” Groq APIã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆå…¨ä½“ï¼‰:', content);
        console.log('ğŸ” Groq APIã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰:', content.substring(0, 500) + '...');
        
        try {
          // è¤‡æ•°ã®JSONæŠ½å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
          let recipeData = null;
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³1: å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
          try {
            const fullJsonMatch = content.match(/\{[\s\S]*\}/);
            if (fullJsonMatch) {
              console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³1: å®Œå…¨JSONæŠ½å‡ºè©¦è¡Œ');
              const jsonString = fullJsonMatch[0];
              console.log('ğŸ“ æŠ½å‡ºã•ã‚ŒãŸJSON:', jsonString.substring(0, 300) + '...');
              
              // JSONä¿®æ­£ã‚’é©ç”¨
              const fixedJson = fixMalformedJson(jsonString);
              recipeData = JSON.parse(fixedJson);
              console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1æˆåŠŸ:', recipeData.title);
            }
          } catch (e) {
            console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³1å¤±æ•—:', e.message);
          }
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ```json```ãƒ–ãƒ­ãƒƒã‚¯
          if (!recipeData) {
            try {
              const codeBlockMatch = content.match(/```json\s*([\s\S]*?)\s*```/i);
              if (codeBlockMatch) {
                console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æŠ½å‡ºè©¦è¡Œ');
                const fixedJson = fixMalformedJson(codeBlockMatch[1]);
                recipeData = JSON.parse(fixedJson);
                console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³2æˆåŠŸ:', recipeData.title);
              }
            } catch (e) {
              console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³2å¤±æ•—:', e.message);
            }
          }
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³3: è¡Œã”ã¨ã®è§£æ
          if (!recipeData) {
            try {
              console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³3: è¡Œã”ã¨è§£æè©¦è¡Œ');
              const lines = content.split('\n');
              const jsonLines = lines.filter(line => 
                line.trim().startsWith('{') || 
                line.includes('"title"') || 
                line.includes('"ingredients"') ||
                line.includes('"steps"')
              );
              
              if (jsonLines.length > 0) {
                const jsonString = jsonLines.join('\n');
                const fixedJson = fixMalformedJson(jsonString);
                recipeData = JSON.parse(fixedJson);
                console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³3æˆåŠŸ:', recipeData.title);
              }
            } catch (e) {
              console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³3å¤±æ•—:', e.message);
            }
          }
          
          if (recipeData) {
            console.log('âœ… ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿è§£ææˆåŠŸ:', recipeData);
            // Recipe Keeper.appé¢¨ã®ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–
            return normalizeRecipeData(recipeData);
          } else {
            console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è§£æã‚’é–‹å§‹');
            return fallbackAnalysis(content, url);
          }
        } catch (parseError) {
          console.error('âŒ JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError);
          console.log('ğŸ“ ç”Ÿã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆå…¨ä½“ï¼‰:', content);
          throw new Error(`ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: ${parseError.message}`);
        }
      }

      // ChatGPT/Gemini APIã®å ´åˆ
      if (data.ok && data.recipeData) {
        return data.recipeData;
      } else if (data.recipeData) {
        return data.recipeData;
      } else {
        throw new Error(data.error || 'AIè§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    }

    // ãƒ¬ã‚·ãƒ”æŠ½å‡ºç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
    function generateRecipeExtractionPrompt(cleanedText, url) {
      const isJapaneseSite = url && (
        url.includes('.jp') ||
        url.includes('japanese') ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(url) ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText.substring(0, 1000))
      );

      const prompt = isJapaneseSite ? 
        `ãƒ¬ã‚·ãƒ”æƒ…å ±ã‚’æŠ½å‡ºã€‚ãƒŠãƒ“ãƒ»åºƒå‘Šãƒ»SNSåŸ‹ã‚è¾¼ã¿ãƒ»é–¢é€£è¨˜äº‹ã‚’ç„¡è¦–ã—ã€æœ¬æ–‡ã®ã¿å‡¦ç†ã€‚

â˜…â˜…â˜…CRITICAL: titleãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯å…ƒãƒšãƒ¼ã‚¸ã®æ–™ç†åã‚’ä¸€å­—ä¸€å¥ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚çµ¶å¯¾ã«ç¿»è¨³ã€å¤‰æ›´ã€è§£é‡ˆã—ãªã„ã§ãã ã•ã„â˜…â˜…â˜…

URL: ${url || 'ä¸æ˜'}
ãƒ†ã‚­ã‚¹ãƒˆ: ${cleanedText.substring(0, 4000)}

JSONå½¢å¼ã§è¿”ã™:
{
  "title": "ã€ã“ã“ã«å…ƒãƒšãƒ¼ã‚¸ã®æ–™ç†åã‚’ãã®ã¾ã¾ã‚³ãƒ”ãƒšã€‘",
  "description": "ãƒ¬ã‚·ãƒ”èª¬æ˜",
  "servings": "äººæ•°ï¼ˆæ•°å­—ã®ã¿ï¼‰",
  "ingredients": [
    {"item": "ææ–™å", "quantity": "åˆ†é‡ï¼ˆæ•°å­—ã¾ãŸã¯é©é‡ãƒ»å°‘ã€…ãƒ»ã²ã¨ã¤ã¾ã¿ãƒ»ãŠå¥½ã¿ã§ç­‰ã®æ›–æ˜§ãªè¡¨ç¾ï¼‰", "unit": "å˜ä½ï¼ˆgã€mlã€å€‹ã€æšã€æœ¬ã€æŸã€å¤§ã•ã˜ã€å°ã•ã˜ã€ã‚«ãƒƒãƒ—ç­‰ã€æ›–æ˜§ãªè¡¨ç¾ã®å ´åˆã¯ç©ºæ–‡å­—ï¼‰"}
  ],
  "steps": [
    {"step": "è©³ç´°ãªæ‰‹é †å†…å®¹ï¼ˆå·¥ç¨‹åã ã‘ã§ãªãã€å…·ä½“çš„ãªèª¿ç†æ–¹æ³•ã€æ¸©åº¦ã€æ™‚é–“ã€æ³¨æ„ç‚¹ã‚’å«ã‚€å®Œå…¨ãªæ‰‹é †ï¼‰"}
  ],
  "notes": "ãƒ¡ãƒ¢",
  "image_url": "ã€ãƒ¬ã‚·ãƒ”ã®ãƒ¡ã‚¤ãƒ³ç”»åƒURLï¼ˆwp-content/uploadsç­‰ã®å®Ÿéš›ã®æ–™ç†ç”»åƒã‚’å„ªå…ˆã€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ç©ºæ–‡å­—ï¼‰ã€‘"
}

é‡è¦: 
1. æ—¥æœ¬èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ç¿»è¨³ã›ãšãã®ã¾ã¾æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚
2. æ‰‹é †ã¯å·¥ç¨‹åã ã‘ã§ãªãã€å…·ä½“çš„ãªèª¿ç†æ–¹æ³•ã€æ¸©åº¦ã€æ™‚é–“ã€ææ–™ã®ä½¿ç”¨é‡ã€æ³¨æ„ç‚¹ã‚’å«ã‚€å®Œå…¨ãªå†…å®¹ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚
3. è¤‡æ•°ã®å·¥ç¨‹ãŒã‚ã‚‹å ´åˆã¯ã€å„å·¥ç¨‹ã®è©³ç´°ãªæ‰‹é †ã‚’ã™ã¹ã¦å«ã‚ã¦ãã ã•ã„ã€‚
4. ã€Œâ‘ ç™½ãƒã‚®ã®ã‚³ãƒ³ãƒ•ã‚£ã‚’ä½œã‚‹ã€ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒˆãƒ«ã ã‘ã§ãªãã€ã€Œç™½ãƒã‚®ã®é’ã„éƒ¨åˆ†ã‚’åˆ‡ã‚Šè½ã¨ã—ã€ç™½ã„éƒ¨åˆ†ã‚’ã‚ˆãæ´—ã†ã€‚ã‚ªãƒªãƒ¼ãƒ–ã‚ªã‚¤ãƒ«ã€ãƒ‹ãƒ³ãƒ‹ã‚¯ã€ã‚¿ã‚¤ãƒ ã€ãƒ­ãƒ¼ãƒªã‚¨ã€å¡©2ï½‡ã¨ä¸€ç·’ã«çœŸç©ºåŒ…è£…ã—ã€15åˆ†é–“ã‚¹ãƒãƒ¼ãƒ ã‚³ãƒ³ãƒ™ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ¼ãƒ–ãƒ³ã®ãƒãƒ—ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰ã§åŠ ç†±ã™ã‚‹ã€‚ã€ã®ã‚ˆã†ãªå…·ä½“çš„ãªå†…å®¹ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚

5. ææ–™ã®åˆ†é‡å‡¦ç†:
   - æ›–æ˜§ãªè¡¨ç¾ï¼ˆã€Œé©é‡ã€ã€Œå°‘ã€…ã€ã€Œã²ã¨ã¤ã¾ã¿ã€ã€ŒãŠå¥½ã¿ã§ã€ï¼‰â†’ quantityã«å…¥ã‚Œã€unitã¯ç©ºæ–‡å­—
   - æ•°å€¤ä»˜ãå˜ä½ï¼ˆã€Œå¤§ã•ã˜3ã€ã€Œå°ã•ã˜2ã€ã€Œ1å€‹ã€ï¼‰â†’ å¤‰æ›ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ã¦æ•°å€¤ã¨å˜ä½ã‚’åˆ†é›¢
   - ä¾‹: ã€Œå¤§ã•ã˜3ã€â†’ {"quantity": "45", "unit": "ml"} (æ¶²ä½“ã®å ´åˆ) ã¾ãŸã¯ {"quantity": "45", "unit": "g"} (å›ºä½“ã®å ´åˆ)

å¤‰æ›ãƒ«ãƒ¼ãƒ«: 
- å¤§ã•ã˜1=15mlï¼ˆæ¶²ä½“ï¼‰ã¾ãŸã¯15gï¼ˆå›ºä½“ï¼‰
- å°ã•ã˜1=5mlï¼ˆæ¶²ä½“ï¼‰ã¾ãŸã¯5gï¼ˆå›ºä½“ï¼‰
- ã‚«ãƒƒãƒ—1=200ml
- æ¶²ä½“ææ–™ï¼ˆæ°´ã€æ²¹ã€é†¤æ²¹ã€é…’ã€é…¢ã€ã¿ã‚Šã‚“ã€ç‰›ä¹³ã€ã ã—ã€ã‚¹ãƒ¼ãƒ—ã€ã‚½ãƒ¼ã‚¹ã€ç”Ÿã‚¯ãƒªãƒ¼ãƒ ç­‰ï¼‰=ml
- å›ºä½“ææ–™ï¼ˆç²‰é¡ã€ç ‚ç³–ã€å¡©ã€ã‚¹ãƒ‘ã‚¤ã‚¹ç­‰ï¼‰=g
- ã€Œå¤§ã•ã˜3ã€â†’ã€Œ45ã€ã€Œmlã€ã¾ãŸã¯ã€Œ45ã€ã€Œgã€ã«å¤‰æ›
- ã€Œå°ã•ã˜2ã€â†’ã€Œ10ã€ã€Œmlã€ã¾ãŸã¯ã€Œ10ã€ã€Œgã€ã«å¤‰æ›
- æ•°å€¤ã¨å˜ä½ã‚’å¿…ãšåˆ†é›¢ã—ã¦ãã ã•ã„

JSONã®ã¿è¿”ã™ã€‚` :
        `Extract recipe information from this webpage content. Ignore navigation, ads, social media embeds, and related articles. Focus only on the main recipe content.

URL: ${url || 'Unknown'}
Text: ${cleanedText.substring(0, 4000)}

Return in JSON format:
{
  "title": "Recipe title (keep original language)",
  "description": "Recipe description",
  "servings": "Number of servings",
  "ingredients": [
    {"item": "Ingredient name", "quantity": "Amount (numbers or vague expressions like 'to taste', 'a pinch', 'as needed')", "unit": "Unit (g, ml, pieces, etc., empty string for vague expressions)"}
  ],
  "steps": [
    {"step": "Detailed cooking step (not just titles, but complete instructions including specific cooking methods, temperatures, times, ingredient amounts, and important notes)"}
  ],
  "notes": "Additional notes",
  "image_url": "Main recipe image URL"
}

Important:
1. Extract complete step instructions, not just titles or section names.
2. Include specific cooking methods, temperatures, times, ingredient amounts, and important notes for each step.
3. For complex recipes with multiple processes, include detailed instructions for each process.
4. Instead of just "â‘  Make white leek confit", extract the full content like "Cut off the green parts of the white leeks and wash the white parts well. Vacuum pack with olive oil, garlic, thyme, bay leaves, and 2g salt, then heat in steam convection oven vapor mode for 15 minutes."
5. Ingredient quantity processing:
   - Vague expressions ("to taste", "a pinch", "as needed") â†’ put in quantity field, leave unit empty
   - Numeric units ("3 tbsp", "2 tsp", "1 piece") â†’ convert according to rules and separate numbers and units
   - Example: "3 tbsp" â†’ {"quantity": "45", "unit": "ml"} (for liquids) or {"quantity": "45", "unit": "g"} (for solids)

Conversion rules:
- 1 tbsp = 15ml (liquid) or 15g (solid)
- 1 tsp = 5ml (liquid) or 5g (solid)  
- 1 cup = 200ml
- Liquid ingredients (water, oil, soy sauce, wine, vinegar, mirin, milk, broth, soup, sauce, cream, etc.) = ml
- Solid ingredients (flour, sugar, salt, spices, etc.) = g
- "3 tbsp" â†’ "45" "ml" or "45" "g"
- "2 tsp" â†’ "10" "ml" or "10" "g"
- Always separate numbers and units

Return only JSON.`;

      return prompt;
    }

    // HTMLã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã™ã‚‹é–¢æ•°ï¼ˆæ—¥æœ¬èªå¯¾å¿œå¼·åŒ–ç‰ˆï¼‰
    function cleanHtml(html, url) {
      console.log('ğŸ§¹ HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°é–‹å§‹:', {
        originalLength: html.length,
        url: url,
        hasJapanese: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(html)
      });
      
      // æ—¥æœ¬èªã‚µã‚¤ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤å®š
      const isJapaneseSite = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com') || 
        url.includes('delishkitchen.tv')
      );
      
      // HTMLã‚¿ã‚°ã‚’é™¤å»ï¼ˆæ—¥æœ¬èªæ–‡å­—ã¯ä¿è­·ï¼‰
      let text = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
      text = text.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
      text = text.replace(/<nav[^>]*>[\s\S]*?<\/nav>/gi, '');
      text = text.replace(/<header[^>]*>[\s\S]*?<\/header>/gi, '');
      text = text.replace(/<footer[^>]*>[\s\S]*?<\/footer>/gi, '');
      text = text.replace(/<aside[^>]*>[\s\S]*?<\/aside>/gi, '');
      text = text.replace(/<!--[\s\S]*?-->/g, '');
      
      // HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆæ—¥æœ¬èªæ–‡å­—åŒ–ã‘å¯¾ç­–ï¼‰
      text = text.replace(/&nbsp;/g, ' ');
      text = text.replace(/&amp;/g, '&');
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      text = text.replace(/&quot;/g, '"');
      text = text.replace(/&#39;/g, "'");
      text = text.replace(/&hellip;/g, 'â€¦');
      text = text.replace(/&yen;/g, 'Â¥');
      
      // HTMLã‚¿ã‚°ã‚’é™¤å»
      text = text.replace(/<[^>]+>/g, ' ');
      
      // æ—¥æœ¬èªã‚µã‚¤ãƒˆã®å ´åˆã®ç‰¹åˆ¥å‡¦ç†
      if (isJapaneseSite) {
        console.log('ğŸ‡¯ğŸ‡µ æ—¥æœ¬èªã‚µã‚¤ãƒˆç‰¹åˆ¥å‡¦ç†é©ç”¨');
        // æ—¥æœ¬èªãƒ¬ã‚·ãƒ”ã‚µã‚¤ãƒˆç‰¹æœ‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ•´ç†
        text = text
          .replace(/ææ–™\s*[:ï¼š]\s*/g, '\nææ–™ï¼š\n')
          .replace(/ä½œã‚Šæ–¹\s*[:ï¼š]\s*/g, '\nä½œã‚Šæ–¹ï¼š\n')
          .replace(/æ‰‹é †\s*[:ï¼š]\s*/g, '\næ‰‹é †ï¼š\n')
          .replace(/(\d+)\s*[ï¼.]\s*/g, '\n$1. ');
      }
      
      // è¤‡æ•°ã®ç©ºç™½ã‚’æ•´ç†ï¼ˆæ—¥æœ¬èªã®æ–‡å­—é–“ã¯ä¿è­·ï¼‰
      text = text.replace(/[ \t]+/g, ' ');
      text = text.replace(/\n\s*\n/g, '\n');
      
      // æ—¥æœ¬èªæ–‡å­—ã‚’å«ã‚€å ´åˆã¯æ–‡å­—ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’ç·©å’Œ
      if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)) {
        console.log('ğŸ‡¯ğŸ‡µ æ—¥æœ¬èªæ–‡å­—æ¤œå‡º - æ–‡å­—ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’ç·©å’Œ');
        // æ—¥æœ¬èªæ–‡å­—ã€è‹±æ•°å­—ã€åŸºæœ¬çš„ãªè¨˜å·ã®ã¿è¨±å¯
        text = text.replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F\u2000-\u206F\u2070-\u209F\u20A0-\u20CF\u2100-\u214F\u2150-\u218F\u2190-\u21FF\u2200-\u22FF\u2300-\u23FF\u2400-\u243F\u2440-\u245F\u2460-\u24FF\u2500-\u257F\u2580-\u259F\u25A0-\u25FF\u2600-\u26FF\u2700-\u27BF]/g, '');
      } else {
        // è‹±èªã‚µã‚¤ãƒˆã®å ´åˆã¯å¾“æ¥é€šã‚Š
        text = text.replace(/[^\w\s\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/g, '');
      }
      
      const cleanedText = text.trim();
      
      console.log('ğŸ§¹ HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°å®Œäº†:', {
        originalLength: html.length,
        cleanedLength: cleanedText.length,
        isJapaneseSite: isJapaneseSite,
        hasJapaneseAfterCleaning: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText),
        preview: cleanedText.substring(0, 200) + '...'
      });
      
      return cleanedText;
    }

    function renderSteps(container, steps, isEditable) {
      if (!container) return;
      container.innerHTML = '';
      if (steps && steps.length > 0) {
        steps.forEach((step, index) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          const stepText = typeof step === 'string' ? step : (step.step || step.instruction || step.text || '');
          item.textContent = `${index + 1}. ${stepText}`;
          if (isEditable) {
            item.setAttribute('data-step-index', String(index));
            item.contentEditable = 'true';
            item.spellcheck = false;
          }
          container.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'step-item';
        item.textContent = 'æ‰‹é †ãªã—';
        container.appendChild(item);
      }
      if (isEditable) {
        enableInlineStepsEditing(container.id);
      }
    }

    // ãƒ¬ã‚·ãƒ”çµæœã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function displayRecipeResults(recipeData, context) {
      console.log('Displaying results:', { recipeData, context });
      resultsGrid.hidden = false;
      currentRecipeData = recipeData;

      // ç”»åƒã®è¡¨ç¤º
      const imageContainer = document.getElementById('recipeImageContainer');
      const recipeImage = document.getElementById('recipeImage');
      const imageUrlInput = document.getElementById('recipeImageUrlInput');
      if (recipeData.image_url) {
        recipeImage.src = recipeData.image_url;
        imageUrlInput.value = recipeData.image_url;
        imageContainer.style.display = 'block';
      } else {
        imageContainer.style.display = 'none';
      }

      document.getElementById('recipeTitle').textContent = recipeData.title || '-';
      document.getElementById('recipeDescription').textContent = recipeData.description || '-';
      document.getElementById('recipeServings').textContent = recipeData.servings || '-';

      displayFlexibleIngredients(recipeData, 'flexibleIngredientsDisplay', context.url);
      renderSteps(document.getElementById('stepsList'), recipeData.steps || [], true);

      // ç¿»è¨³UIã®è¡¨ç¤ºåˆ¶å¾¡
      const isJapanese = containsJapanese(JSON.stringify(recipeData));
      translationControls.style.display = isJapanese ? 'none' : 'flex';
      if (!isJapanese) {
        updateTranslationUI();
      }
      
      // ç¿»è¨³æ¸ˆã¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éš ã™
      translationSection.style.display = 'none';
      resultsGrid.classList.remove('with-translation');
    }

    // æ—¥æœ¬èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã©ã†ã‹ã‚’åˆ¤å®š
    function detectJapaneseContent(recipeData, url) {
      // URLã‹ã‚‰åˆ¤å®š
      if (url && (url.includes('.jp') || url.includes('japanese') || url.includes('japan'))) {
        return true;
      }
      
      // ãƒ†ã‚­ã‚¹ãƒˆå†…å®¹ã‹ã‚‰åˆ¤å®š
      const textToCheck = [
        recipeData.title || '',
        recipeData.description || '',
        ...(recipeData.ingredients || []).map(ing => ing.item || ''),
        ...(recipeData.steps || []).map(step => typeof step === 'object' ? step.step : step || '')
      ].join(' ');
      
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      return japaneseRegex.test(textToCheck);
    }

    // å˜ä½ã‚’æ­£è¦åŒ–ã™ã‚‹é–¢æ•°
    function normalizeUnit(unit) {
      if (!unit) return '';
      
      const unitStr = unit.toString().toLowerCase().trim();
      
      // é‡è¤‡ã™ã‚‹å˜ä½ã‚’çµ±ä¸€
      const unitMappings = {
        // ã‚°ãƒ©ãƒ ç³»
        'grammes': 'g',
        'gramme': 'g',
        'gram': 'g',
        'grams': 'g',
        'ã‚°ãƒ©ãƒ ': 'g',
        
        // ãƒŸãƒªãƒªãƒƒãƒˆãƒ«ç³»
        'millilitres': 'ml',
        'millilitre': 'ml',
        'milliliter': 'ml',
        'milliliters': 'ml',
        'ãƒŸãƒªãƒªãƒƒãƒˆãƒ«': 'ml',
        
        // ã‚­ãƒ­ã‚°ãƒ©ãƒ ç³»
        'kilogrammes': 'kg',
        'kilogramme': 'kg',
        'kilogram': 'kg',
        'kilograms': 'kg',
        'ã‚­ãƒ­ã‚°ãƒ©ãƒ ': 'kg',
        
        // ãƒªãƒƒãƒˆãƒ«ç³»
        'litres': 'l',
        'litre': 'l',
        'liter': 'l',
        'liters': 'l',
        'ãƒªãƒƒãƒˆãƒ«': 'l',
        
        // ãã®ä»–ã®å˜ä½
        'cuillÃ¨res Ã  soupe': 'tbsp',
        'cuillÃ¨re Ã  soupe': 'tbsp',
        'cuillÃ¨res Ã  cafÃ©': 'tsp',
        'cuillÃ¨re Ã  cafÃ©': 'tsp',
        'grandes cuillÃ¨res': 'tbsp',
        'petites cuillÃ¨res': 'tsp',
        'å¤§ã•ã˜': 'tbsp',
        'å°ã•ã˜': 'tsp',
        'ã‚«ãƒƒãƒ—': 'cup',
        'å€‹': 'å€‹',
        'piÃ¨ce': 'å€‹',
        'piÃ¨ces': 'å€‹',
        'pinch': 'ã¤ã¾ã¿',
        'pincÃ©e': 'ã¤ã¾ã¿',
        'une pincÃ©e': 'ã¤ã¾ã¿'
      };
      
      // ãƒãƒƒãƒ”ãƒ³ã‚°ãŒã‚ã‚‹å ´åˆã¯å¤‰æ›ã€ãªã„å ´åˆã¯ãã®ã¾ã¾
      return unitMappings[unitStr] || unit;
    }

    // ä¸æ­£ãªJSONã‚’ä¿®æ­£ã™ã‚‹é–¢æ•°
    function fixMalformedJson(jsonString) {
      try {
        // åŸºæœ¬çš„ãªã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        let fixed = jsonString.trim();
        
        console.log('ğŸ”§ JSONä¿®æ­£é–‹å§‹:', {
          original: fixed.substring(0, 200) + '...',
          length: fixed.length
        });
        
        // ä¸å®Œå…¨ãªæ–‡å­—åˆ—ã‚’ä¿®æ­£
        // ä¾‹: "title": "Glissez cet ingrÃ©dient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique",+ â†’ ä¿®æ­£
        fixed = fixed.replace(/",\+/g, '"');
        fixed = fixed.replace(/",\s*\+/g, '"');
        
        // ä¸æ­£ãªæ–‡å­—åˆ—ã®çµ‚ç«¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿®æ­£
        // ä¾‹: "description":"L"... â†’ "description":"L..."
        fixed = fixed.replace(/"([^"]*)"\.\.\.([^"}]*)/g, '"$1...$2"');
        
        // ä¸å®Œå…¨ãªæ–‡å­—åˆ—ï¼ˆå¼•ç”¨ç¬¦ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ï¼‰ã‚’ä¿®æ­£
        // ä¾‹: "title":"Glissez cet ingrÃ©dient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique â†’ ä¿®æ­£
        const unclosedStringMatch = fixed.match(/"[^"]*":\s*"[^"]*$/);
        if (unclosedStringMatch) {
          fixed = fixed + '"';
          console.log('ğŸ”§ ä¸å®Œå…¨ãªæ–‡å­—åˆ—ã‚’ä¿®æ­£');
        }
        
        // é…åˆ—ã®ä¿®æ­£ã‚’å¼·åŒ–
        // ä¸å®Œå…¨ãªé…åˆ—é …ç›®ã‚’ä¿®æ­£: {"item": "name", "quantity": "123", "unit": "g â†’ å®Œå…¨ãªå½¢ã«
        fixed = fixed.replace(/\{\s*"item"\s*:\s*"[^"]*"\s*,\s*"quantity"\s*:\s*"[^"]*"\s*,\s*"unit"\s*:\s*"[^"]*$/g, (match) => {
          console.log('ğŸ”§ ä¸å®Œå…¨ãªé…åˆ—é …ç›®ã‚’ä¿®æ­£:', match);
          return match + '"}';
        });
        
        // é…åˆ—ã®çµ‚ç«¯ä¿®æ­£: [..., â†’ [...]
        fixed = fixed.replace(/,(\s*\])/g, '$1');
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çµ‚ç«¯ä¿®æ­£: {..., â†’ {...}
        fixed = fixed.replace(/,(\s*\})/g, '$1');
        
        // ä¸å®Œå…¨ãªé…åˆ—ã‚’ä¿®æ­£
        // "ingredients": [{"item": "name"}, {"item": "name2" â†’ "ingredients": [{"item": "name"}, {"item": "name2"}]
        const incompleteArrayMatch = fixed.match(/"ingredients"\s*:\s*\[[^\]]*$/);
        if (incompleteArrayMatch) {
          console.log('ğŸ”§ ä¸å®Œå…¨ãªé…åˆ—ã‚’æ¤œå‡º:', incompleteArrayMatch[0]);
          // æœ€å¾Œã®å®Œå…¨ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã¤ã‘ã¦é…åˆ—ã‚’é–‰ã˜ã‚‹
          const lastCompleteObject = fixed.match(/.*\{[^}]*\}/);
          if (lastCompleteObject) {
            fixed = lastCompleteObject[0] + ']';
            console.log('ğŸ”§ é…åˆ—ã‚’å¼·åˆ¶çµ‚äº†');
          }
        }
        
        // ä¸å®Œå…¨ãªæ‰‹é †é…åˆ—ã‚’ä¿®æ­£
        const incompleteStepsMatch = fixed.match(/"steps"\s*:\s*\[[^\]]*$/);
        if (incompleteStepsMatch) {
          console.log('ğŸ”§ ä¸å®Œå…¨ãªæ‰‹é †é…åˆ—ã‚’æ¤œå‡º');
          // æœ€å¾Œã®å®Œå…¨ãªæ–‡å­—åˆ—ã‚’è¦‹ã¤ã‘ã¦é…åˆ—ã‚’é–‰ã˜ã‚‹
          const lastCompleteStep = fixed.match(/.*"[^"]*"/);
          if (lastCompleteStep) {
            fixed = lastCompleteStep[0] + ']';
            console.log('ğŸ”§ æ‰‹é †é…åˆ—ã‚’å¼·åˆ¶çµ‚äº†');
          }
        }
        
        // ä¸å®Œå…¨ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çµ‚ç«¯ã‚’ä¿®æ­£
        if (!fixed.endsWith('}') && !fixed.endsWith(']')) {
          console.log('ğŸ”§ ä¸å®Œå…¨ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆçµ‚ç«¯ã‚’æ¤œå‡º');
          
          // æœ€å¾Œã®å®Œå…¨ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¦‹ã¤ã‘ã‚‹
          const patterns = [
            /"[^"]*":\s*"[^"]*"/, // "key": "value"
            /"[^"]*":\s*\[[^\]]*\]/, // "key": [array]
            /"[^"]*":\s*\{[^}]*\}/, // "key": {object}
            /"[^"]*":\s*\d+/, // "key": number
            /"[^"]*":\s*(true|false|null)/ // "key": boolean/null
          ];
          
          let lastCompleteMatch = null;
          for (const pattern of patterns) {
            const matches = fixed.match(new RegExp('.*' + pattern.source));
            if (matches && (!lastCompleteMatch || matches[0].length > lastCompleteMatch[0].length)) {
              lastCompleteMatch = matches;
            }
          }
          
          if (lastCompleteMatch) {
            fixed = lastCompleteMatch[0] + '}';
            console.log('ğŸ”§ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼·åˆ¶çµ‚äº†');
          } else {
            // æœ€ä½é™ã®JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
            fixed = '{"title": "JSONè§£æã‚¨ãƒ©ãƒ¼", "description": "ä¸æ­£ãªJSONã®ãŸã‚è§£æã«å¤±æ•—ã—ã¾ã—ãŸ", "ingredients": [], "steps": []}';
            console.log('ğŸ”§ æœ€ä½é™ã®JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ');
          }
        }
        
        // äºŒé‡å¼•ç”¨ç¬¦ã®å•é¡Œã‚’ä¿®æ­£
        fixed = fixed.replace(/""([^"]*)""/g, '"$1"');
        
        // ç‰¹æ®Šæ–‡å­—ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å•é¡Œã‚’ä¿®æ­£
        fixed = fixed.replace(/\\"/g, '"');
        
        // æœ€çµ‚çš„ãªæ§‹æ–‡ãƒã‚§ãƒƒã‚¯
        try {
          JSON.parse(fixed);
          console.log('âœ… JSONä¿®æ­£æˆåŠŸ');
        } catch (testError) {
          console.warn('âš ï¸ ä¿®æ­£å¾Œã‚‚JSONç„¡åŠ¹:', testError.message);
          // æœ€å¾Œã®æ‰‹æ®µï¼šåŸºæœ¬çš„ãªæ§‹é€ ã‚’å¼·åˆ¶ä½œæˆ
          fixed = '{"title": "è§£æã‚¨ãƒ©ãƒ¼", "description": "JSONã®ä¿®æ­£ã«å¤±æ•—ã—ã¾ã—ãŸ", "ingredients": [], "steps": []}';
        }
        
        console.log('ğŸ”§ JSONä¿®æ­£å®Œäº†:', {
          fixed: fixed.substring(0, 200) + '...',
          originalLength: jsonString.length,
          fixedLength: fixed.length
        });
        
        return fixed;
      } catch (error) {
        console.error('âŒ JSONä¿®æ­£å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        return '{"title": "ä¿®æ­£ã‚¨ãƒ©ãƒ¼", "description": "JSONä¿®æ­£å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", "ingredients": [], "steps": []}';
      }
    }

    // ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ã‚’ç¿»è¨³ã™ã‚‹é–¢æ•°
    async function translateRecipeData(recipeData) {
      const selectedLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
      const targetLanguageLabel = getLanguageLabel(selectedLanguage);
      const targetLanguageName = getLanguagePromptName(selectedLanguage);
      
      console.log('ğŸŒ ç¿»è¨³é–‹å§‹:', {
        selectedLanguage,
        targetLanguageLabel,
        targetLanguageName,
        recipeDataKeys: Object.keys(recipeData || {})
      });
      
      const hasIngredientSections = Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(ing => ing && ing.sectionTitle);
      const sectionInstruction = hasIngredientSections
        ? '\n- Maintain the original ingredient sections exactly as provided via the "sectionTitle" field. Include those sectionTitle values in the translated JSON.'
        : '';

      const { data, error } = await sb.functions.invoke('call-groq-api', {
        body: {
          mode: 'recipe_translation',
          recipeData: recipeData,
          targetLanguage: selectedLanguage,
          targetLanguageName: targetLanguageName,
          targetLanguageLabel,
          forceTranslate: true,
          noSummarize: true,
          keepAllItems: true,
          strictInstruction: `Translate ALL fields into ${targetLanguageName}. Do NOT summarize or omit any content.\n- Keep the number of ingredients and steps identical to the source (1:1).\n- Preserve step granularity; do not merge steps.${sectionInstruction}\n- Return JSON only.`
        }
      });

      if (error) {
        throw new Error(`ç¿»è¨³APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || 'ç¿»è¨³ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      // Groq APIã®contentã‹ã‚‰JSONã‚’æŠ½å‡º
      const content = data.content || '';
      console.log('ğŸ” ç¿»è¨³APIã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆå…¨ä½“ï¼‰:', content);
      console.log('ğŸ” ç¿»è¨³APIã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆã‚¿ã‚¤ãƒ—ï¼‰:', typeof content);
      console.log('ğŸ” ç¿»è¨³APIã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆé•·ã•ï¼‰:', content.length);
      console.log('ğŸ” ç¿»è¨³APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼ˆdataå…¨ä½“ï¼‰:', data);
      
      try {
        // è¤‡æ•°ã®JSONæŠ½å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
        let translatedData = null;

        if (data.data && typeof data.data === 'object') {
          translatedData = { ...data.data };
          if (Array.isArray(translatedData.ingredients)) {
            translatedData.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, translatedData.ingredients);
          }
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        const jsonMatch1 = content.match(/\{[\s\S]*\}/);
        if (!translatedData && jsonMatch1) {
          try {
            let jsonString = jsonMatch1[0];
            console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³1 - æŠ½å‡ºã•ã‚ŒãŸJSONæ–‡å­—åˆ—:', jsonString);
            
            // JSONä¿®æ­£å‡¦ç†
            jsonString = fixMalformedJson(jsonString);
            console.log('ğŸ”§ ãƒ‘ã‚¿ãƒ¼ãƒ³1 - ä¿®æ­£å¾Œã®JSONæ–‡å­—åˆ—:', jsonString);
            
            translatedData = JSON.parse(jsonString);
            console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1ã§JSONè§£ææˆåŠŸ:', translatedData);
          } catch (e) {
            console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³1å¤±æ•—:', e.message);
            console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³1å¤±æ•— - å•é¡Œã®JSON:', jsonMatch1[0].substring(0, 200));
          }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ```json ãƒ–ãƒ­ãƒƒã‚¯å†…ã®JSON
        if (!translatedData) {
          const jsonMatch2 = content.match(/```json\s*([\s\S]*?)\s*```/);
          if (jsonMatch2) {
            try {
              let jsonString = jsonMatch2[1].trim();
              console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³2 - æŠ½å‡ºã•ã‚ŒãŸJSONæ–‡å­—åˆ—:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³2ã§JSONè§£ææˆåŠŸ:', translatedData);
            } catch (e) {
              console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³2å¤±æ•—:', e.message);
            }
          }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: ``` ãƒ–ãƒ­ãƒƒã‚¯å†…ã®JSON
        if (!translatedData) {
          const jsonMatch3 = content.match(/```\s*([\s\S]*?)\s*```/);
          if (jsonMatch3) {
            try {
              translatedData = JSON.parse(jsonMatch3[1]);
              console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³3ã§JSONè§£ææˆåŠŸ:', translatedData);
            } catch (e) {
              console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³3å¤±æ•—:', e.message);
            }
          }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³4: æœ€åˆã¨æœ€å¾Œã®{}ã‚’æ¢ã™
        if (!translatedData) {
          const firstBrace = content.indexOf('{');
          const lastBrace = content.lastIndexOf('}');
          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            try {
              let jsonString = content.substring(firstBrace, lastBrace + 1);
              console.log('ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³4 - æŠ½å‡ºã•ã‚ŒãŸJSONæ–‡å­—åˆ—:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³4ã§JSONè§£ææˆåŠŸ:', translatedData);
            } catch (e) {
              console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³4å¤±æ•—:', e.message);
            }
          }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³5: è¡Œã”ã¨ã«{}ã‚’æ¢ã™
        if (!translatedData) {
          const lines = content.split('\n');
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
              try {
                let jsonString = fixMalformedJson(trimmed);
                translatedData = JSON.parse(jsonString);
                console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³5ã§JSONè§£ææˆåŠŸ:', translatedData);
                break;
              } catch (e) {
                console.log('âŒ ãƒ‘ã‚¿ãƒ¼ãƒ³5å¤±æ•—ï¼ˆè¡Œï¼‰:', e.message);
              }
            }
          }
        }
        
        const seemsSameLanguage = (payload) => {
          const text = [payload?.title, payload?.description, ...(payload?.ingredients||[]).map(i=>i.item), ...(payload?.steps||[])].filter(Boolean).join(' ');
          const hasJP = /[\u3040-\u30FF\u4E00-\u9FFF]/.test(text);
          if (selectedLanguage === 'en') return hasJP; // è‹±èªè¦æ±‚ãªã®ã«æ—¥æœ¬èªãŒå¤šã„
          if (selectedLanguage === 'ja') return !hasJP; // æ—¥æœ¬èªè¦æ±‚ãªã®ã«æ—¥æœ¬èªãŒå°‘ãªã„
          return false;
        };

        if (translatedData) {
          const sourceIngredientCount = recipeData.ingredients?.length || 0;
          const translatedIngredientCount = translatedData.ingredients?.length || 0;
          const sourceStepCount = recipeData.steps?.length || 0;
          const translatedStepCount = translatedData.steps?.length || 0;

          if (translatedIngredientCount !== sourceIngredientCount || translatedStepCount !== sourceStepCount) {
            console.warn('âš ï¸ ç¿»è¨³çµæœã®ä»¶æ•°ãŒåŸæ–‡ã¨ä¸€è‡´ã—ã¾ã›ã‚“', {
              sourceIngredientCount,
              translatedIngredientCount,
              sourceStepCount,
              translatedStepCount
            });
            try {
              const countFallback = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
              if (countFallback) {
                console.log('âœ… ä»¶æ•°ä¸ä¸€è‡´ã®ãŸã‚ChatGPTãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœã‚’æ¡ç”¨');
                translatedData = countFallback;
              }
            } catch (fallbackErr) {
              console.warn('ChatGPTãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•— (ä»¶æ•°ä¸ä¸€è‡´):', fallbackErr);
            }
          }

          if (Array.isArray(translatedData.ingredients)) {
            translatedData.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, translatedData.ingredients);

            if ((translatedData.ingredients?.length || 0) !== sourceIngredientCount) {
              const filledIngredients = [];
              for (let i = 0; i < sourceIngredientCount; i++) {
                const origin = recipeData.ingredients?.[i] || {};
                const translatedIng = translatedData.ingredients?.[i];
                if (translatedIng) {
                  filledIngredients.push(ensureIngredientSectionTitles([origin], [translatedIng])[0]);
                } else {
                  filledIngredients.push({
                    item: origin.item || origin.name || '',
                    quantity: origin.quantity || '',
                    unit: origin.unit || '',
                    sectionTitle: origin.sectionTitle || ''
                  });
                }
              }
              translatedData.ingredients = filledIngredients;
            }
          }
          // ç¿»è¨³è¨€èªãƒã‚§ãƒƒã‚¯ â†’ ä¸ä¸€è‡´ãªã‚‰ChatGPTã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          if (seemsSameLanguage(translatedData)) {
            console.warn('âš ï¸ æœŸå¾…è¨€èªã«ç¿»è¨³ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ã€‚ChatGPTã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™');
            try {
              const fallback = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
              if (fallback) return fallback;
            } catch (e) {
              console.warn('ChatGPTãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—:', e);
            }
          }
          console.log('âœ… ç¿»è¨³ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ:', translatedData);
          console.log('ğŸ” ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ :', {
            hasTitle: !!translatedData.title,
            hasDescription: !!translatedData.description,
            hasServings: !!translatedData.servings,
            hasIngredients: !!translatedData.ingredients,
            hasSteps: !!translatedData.steps,
            ingredientsLength: translatedData.ingredients?.length || 0,
            stepsLength: translatedData.steps?.length || 0
          });
          return translatedData;
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒè‡ªç„¶è¨€èªã®å ´åˆã€æ‰‹å‹•ã§æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
          console.warn('âš ï¸ JSONè§£æã«å¤±æ•—ã€è‡ªç„¶è¨€èªãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™');
          console.warn('âš ï¸ ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹:', content.substring(0, 500));
          
          // è‡ªç„¶è¨€èªãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰åŸºæœ¬çš„ãªæƒ…å ±ã‚’æŠ½å‡º
          const fallbackData = {
            title: currentRecipeData?.title ? `${currentRecipeData.title} (${targetLanguageLabel}ç¿»è¨³)` : `ç¿»è¨³ã•ã‚ŒãŸãƒ¬ã‚·ãƒ” (${targetLanguageLabel})`,
            description: content.length > 0 ? content.substring(0, 200) + '...' : 'ç¿»è¨³æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ',
            servings: currentRecipeData?.servings || 'ä¸æ˜',
            ingredients: currentRecipeData?.ingredients || [],
            steps: currentRecipeData?.steps || []
          };
          
          console.log('ğŸ“ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿:', fallbackData);
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚åŸæ–‡ã®å¯èƒ½æ€§ â†’ ChatGPTã¸å†è©¦è¡Œ
          try {
            const fb = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
            if (fb) return fb;
          } catch (_) {}
          return fallbackData;
        }
        
      } catch (parseError) {
        console.error('âŒ ç¿»è¨³JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError);
        throw new Error(`ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: ${parseError.message}`);
      }
    }

    // ChatGPTãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¿»è¨³
    async function translateWithChatGPT(recipeData, langKey, langName) {
      try {
        const hasSections = Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(ing => ing && ing.sectionTitle);
        const sectionNote = hasSections ? ' ææ–™ã«sectionTitleãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®å€¤ã‚’å¤‰æ›´ã›ãšã«ä¿æŒã—ã€ç¿»è¨³çµæœã§ã‚‚åŒã˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¦ãã ã•ã„ã€‚' : '';
        const prompt = `æ¬¡ã®ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ã‚’${langName}ã«ç¿»è¨³ã—ã€JSONã ã‘ã§è¿”ã—ã¦ãã ã•ã„ã€‚å¿…ãšã™ã¹ã¦ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’${langName}ã«ç¿»è¨³ã—ã€åŸæ–‡ã®ã¾ã¾æ®‹ã•ãªã„ã§ãã ã•ã„ã€‚${sectionNote}\n\n` +
          JSON.stringify({
            title: recipeData.title || '',
            description: recipeData.description || '',
            servings: recipeData.servings || '',
            ingredients: recipeData.ingredients || [],
            steps: recipeData.steps || []
          }, null, 2);
        const { data, error } = await sb.functions.invoke('call-openai-api', {
          body: {
            prompt,
            model: 'gpt-4o-mini',
            maxTokens: 4096,
            temperature: 0.2,
            responseFormat: { type: 'json_object' }
          }
        });
        if (error || !data?.success) throw new Error(error?.message || data?.error || 'API error');
        const content = typeof data.content === 'string' ? data.content : (data.raw?.choices?.[0]?.message?.content || '');
        const match = content.match(/\{[\s\S]*\}/);
        const json = match ? match[0] : content;
        const parsed = JSON.parse(json);
        if (Array.isArray(parsed.ingredients)) {
          parsed.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, parsed.ingredients);
        }
        return parsed;
      } catch (e) {
        console.warn('translateWithChatGPT error:', e.message);
        return null;
      }
    }

    // åŒ…æ‹¬çš„ãªãƒ¬ã‚·ãƒ”æ§‹é€ è§£æé–¢æ•°
    function parseComplexRecipeStructure(recipeData, url = '') {
      const r = recipeData || {};
      
      console.log('ğŸ” åŒ…æ‹¬çš„ãƒ¬ã‚·ãƒ”æ§‹é€ è§£æé–‹å§‹');
      console.log('ğŸ“Š å…¥åŠ›ãƒ‡ãƒ¼ã‚¿:', r);
      console.log('ğŸ“Š æ‰‹é †æ•°:', r.steps?.length || 0);
      console.log('ğŸ“Š ææ–™æ•°:', r.ingredients?.length || 0);
      console.log('ğŸ“Š URL:', url);
      
      // ã‚µã‚¤ãƒˆåˆ¥ç‰¹åˆ¥å‡¦ç†ã®æ¤œå‡º
      const siteDetection = {
        valrhona: url && url.includes('valrhona.com'),
        marmiton: url && url.includes('marmiton.org'),
        cookpad: url && url.includes('cookpad.com'),
        kurashiru: url && url.includes('kurashiru.com'),
        delishkitchen: url && url.includes('delishkitchen.tv'),
        gibier: url && url.includes('gibier.or.jp'),
        tsuji: url && url.includes('tsuji.ac.jp'),
        professional: url && (url.includes('chef') || url.includes('hotel') || url.includes('restaurant'))
      };
      
      console.log('ğŸ·ï¸ ã‚µã‚¤ãƒˆæ¤œå‡ºçµæœ:', siteDetection);
      
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’æ¤œå‡º
      const sections = [];
      
      // Valrhonaã‚µã‚¤ãƒˆã®å ´åˆã¯å°‚ç”¨å‡¦ç†ã‚’å„ªå…ˆ
      if (siteDetection.valrhona && r.ingredients && r.ingredients.length > 0) {
        console.log('ğŸ·ï¸ Valrhonaå°‚ç”¨å‡¦ç†ã‚’å®Ÿè¡Œ');
        console.log('ğŸ“Š å…¥åŠ›ææ–™ãƒªã‚¹ãƒˆè©³ç´°:');
        r.ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${typeof ing === 'string' ? ing : `${ing.item || ing.name || '?'} - ${ing.quantity || '?'} ${ing.unit || '?'}`}`);
        });
        
        // Valrhonaã®æ—¢çŸ¥ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’ä½¿ç”¨
        const valrhonaSections = [
          { title: 'LIQUID STARCH', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', weight: '3000g' },
          { title: 'BABA DOUGH', weight: '599g' }
        ];
        
        const valrhonaMapping = createValrhonaIngredientMapping(r.ingredients);
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = valrhonaMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            sections.push({
              title: sectionInfo.title,
              totalWeight: sectionInfo.weight,
              ingredients: sectionIngredients,
              instructions: []
            });
            
            console.log(`âœ… Valrhonaã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆ: "${sectionInfo.title}" - ææ–™æ•°: ${sectionIngredients.length}`);
          } else {
            console.log(`âŒ ç©ºã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³: "${sectionInfo.title}" - ææ–™æ•°: 0`);
          }
        });
        
        console.log('ğŸ Valrhonaå°‚ç”¨å‡¦ç†å®Œäº† - ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°:', sections.length);
        
        // ç·ææ–™æ•°ã®ç¢ºèª
        const totalMapped = Object.values(valrhonaMapping).reduce((sum, sectionItems) => sum + sectionItems.length, 0);
        console.log(`ğŸ“Š ãƒãƒƒãƒ”ãƒ³ã‚°çµ±è¨ˆ: å…ƒææ–™${r.ingredients.length}å€‹ â†’ ãƒãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿${totalMapped}å€‹`);
        
        if (totalMapped < r.ingredients.length) {
          console.warn(`âš ï¸ æœªãƒãƒƒãƒ”ãƒ³ã‚°ææ–™ã‚ã‚Š: ${r.ingredients.length - totalMapped}å€‹ãŒæŠœã‘ã¦ã„ã¾ã™`);
        }
      }
      
      // ã‚¸ãƒ“ã‚¨ãƒ»æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”ã®å ´åˆã¯å°‚ç”¨å‡¦ç†
      if (sections.length === 0 && (siteDetection.gibier || siteDetection.tsuji || siteDetection.professional)) {
        console.log('ğŸ·ï¸ æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”å°‚ç”¨å‡¦ç†ã‚’å®Ÿè¡Œ');
        const japaneseProfessionalSections = createJapaneseProfessionalSections(r, url);
        if (japaneseProfessionalSections.length > 0) {
          console.log('âœ… æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”å‡¦ç†æˆåŠŸ:', japaneseProfessionalSections.length, 'å€‹');
          sections.push(...japaneseProfessionalSections);
        }
      }
      
      // Valrhonaä»¥å¤–ã¾ãŸã¯å°‚ç”¨å‡¦ç†ãŒå¤±æ•—ã—ãŸå ´åˆã®ä¸€èˆ¬çš„ãªå‡¦ç†
      if (sections.length === 0) {
        // 1. æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºã™ã‚‹æ–¹æ³•ã‚’è©¦è¡Œ
        console.log('ğŸ” æ–¹æ³•1: æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³æŠ½å‡ºã‚’è©¦è¡Œ');
        const extractedSections = extractSectionsFromSteps(r, siteDetection);
        if (extractedSections.length > 0) {
          console.log('âœ… æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³æŠ½å‡ºæˆåŠŸ:', extractedSections.length, 'å€‹');
          sections.push(...extractedSections);
        }
        
        // 2. ææ–™åã‹ã‚‰æ–™ç†ã®å·¥ç¨‹ã‚’æ¨æ¸¬ã™ã‚‹æ–¹æ³•
        if (sections.length === 0) {
          console.log('ğŸ” æ–¹æ³•2: ææ–™ã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªæ¨æ¸¬ã‚’è©¦è¡Œ');
          const inferredSections = inferSectionsFromIngredients(r);
          if (inferredSections.length > 0) {
            console.log('âœ… ææ–™ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¨æ¸¬æˆåŠŸ:', inferredSections.length, 'å€‹');
            sections.push(...inferredSections);
          }
        }
        
        // 3. ãƒ¬ã‚·ãƒ”ã®è¤‡é›‘ã•ã«åŸºã¥ãè‡ªå‹•åˆ†å‰²
        if (sections.length === 0 && r.ingredients && r.ingredients.length > 8) {
          console.log('ğŸ” æ–¹æ³•3: è¤‡é›‘ãƒ¬ã‚·ãƒ”ã®è‡ªå‹•åˆ†å‰²ã‚’è©¦è¡Œ');
          const autoSections = createAutoSections(r);
          if (autoSections.length > 0) {
            console.log('âœ… è‡ªå‹•åˆ†å‰²æˆåŠŸ:', autoSections.length, 'å€‹');
            sections.push(...autoSections);
          }
        }
      }
      
      // æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡º
      if (r.steps && r.steps.length > 0) {
        let currentSection = null;
        
        r.steps.forEach((step, index) => {
          const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
          console.log(`\nğŸ” Step ${index + 1} è§£æé–‹å§‹:`);
          console.log(`ğŸ“ ã‚¹ãƒ†ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆï¼ˆå…¨ä½“ï¼‰:`, stepText);
          console.log(`ğŸ“ ã‚¹ãƒ†ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆï¼ˆæœ€åˆã®200æ–‡å­—ï¼‰:`, stepText.substring(0, 200));
          
          // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¤‡æ•°è©¦è¡Œ
          let sectionMatch = null;
          let detectedTitle = null;
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³1: Valrhona Stepå½¢å¼ "Step01 LIQUID STARCH" ã¾ãŸã¯ "Step02 JIVARA 40% INTENSE WHIPPED GANACHE"
          const stepPattern = /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i;
          const stepMatch = stepText.match(stepPattern);
          if (stepMatch && stepMatch[2]) {
            detectedTitle = stepMatch[2].trim();
            sectionMatch = stepMatch;
            console.log('ğŸ¯ Stepå½¢å¼æ¤œå‡º:', detectedTitle);
          } else {
            console.log('âŒ Stepå½¢å¼ãƒãƒƒãƒãªã—');
          }
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³2: å¤§æ–‡å­—ã‚¿ã‚¤ãƒˆãƒ«è¡Œ "LIQUID STARCH" ã¾ãŸã¯ "JIVARA 40% INTENSE WHIPPED GANACHE"
          if (!sectionMatch) {
            const titlePattern = /^([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const titleMatch = stepText.match(titlePattern);
            if (titleMatch) {
              detectedTitle = titleMatch[1].trim();
              sectionMatch = titleMatch;
              console.log('ğŸ¯ å¤§æ–‡å­—ã‚¿ã‚¤ãƒˆãƒ«æ¤œå‡º:', detectedTitle);
            } else {
              console.log('âŒ å¤§æ–‡å­—ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒƒãƒãªã—');
            }
          }
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³3: ç•ªå·ä»˜ãã‚¿ã‚¤ãƒˆãƒ« "1. LIQUID STARCH"
          if (!sectionMatch) {
            const numberedPattern = /^(\d+\.?\s*)([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const numberedMatch = stepText.match(numberedPattern);
            if (numberedMatch) {
              detectedTitle = numberedMatch[2].trim();
              sectionMatch = numberedMatch;
              console.log('ğŸ¯ ç•ªå·ä»˜ãã‚¿ã‚¤ãƒˆãƒ«æ¤œå‡º:', detectedTitle);
            } else {
              console.log('âŒ ç•ªå·ä»˜ãã‚¿ã‚¤ãƒˆãƒ«ãƒãƒƒãƒãªã—');
            }
          }
          
          // ãƒ‘ã‚¿ãƒ¼ãƒ³4: è¡Œå†…ã®å¤§æ–‡å­—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ”¹è¡Œã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ãªã„å ´åˆï¼‰
          if (!sectionMatch) {
            const inlinePattern = /([A-Z][A-Z\s&%0-9]{4,})/g;
            const inlineMatches = stepText.match(inlinePattern);
            if (inlineMatches && inlineMatches.length > 0) {
              // æœ€åˆã®å¤§æ–‡å­—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨
              detectedTitle = inlineMatches[0].trim();
              sectionMatch = { 0: detectedTitle };
              console.log('ğŸ¯ è¡Œå†…å¤§æ–‡å­—ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡º:', detectedTitle);
            } else {
              console.log('âŒ è¡Œå†…å¤§æ–‡å­—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒãƒãªã—');
            }
          }
          
          console.log(`ğŸ” æœ€çµ‚æ¤œå‡ºçµæœ: ${detectedTitle ? `"${detectedTitle}"` : 'ãªã—'}`);
          
          if (sectionMatch && detectedTitle && detectedTitle.length >= 4) {
            // æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹
            if (currentSection) {
              console.log('ğŸ“ ã‚»ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†:', currentSection.title, `ææ–™æ•°: ${currentSection.ingredients.length}`);
              sections.push(currentSection);
            }
            
            currentSection = {
              title: detectedTitle,
              ingredients: [],
              instructions: [],
              totalWeight: null
            };
            
            console.log('ğŸ†• æ–°ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹:', detectedTitle);
          } else {
            console.log('âŒ ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡ºå¤±æ•— - æ—¢å­˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«è¿½åŠ ');
          }
          
          if (currentSection) {
            console.log('ğŸ” ç¾åœ¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³:', currentSection.title);
            
            // é‡é‡æƒ…å ±ã‚’æŠ½å‡ºï¼ˆè¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³å¯¾å¿œï¼‰
            const weightPatterns = [
              /(\d+g)\s*Total weight/i,
              /Total weight[:\s]*(\d+g)/i,
              /^(\d+g)$/
            ];
            
            for (const pattern of weightPatterns) {
              const weightMatch = stepText.match(pattern);
              if (weightMatch) {
                currentSection.totalWeight = weightMatch[1];
                console.log('âš–ï¸ é‡é‡æ¤œå‡º:', weightMatch[1]);
                break;
              }
            }
            
            // ææ–™ã‚’æŠ½å‡ºï¼ˆè¡Œã”ã¨ã«å‡¦ç†ï¼‰
            const lines = stepText.split('\n');
            console.log('ğŸ“‹ è¡Œæ•°:', lines.length);
            
            lines.forEach((line, lineIndex) => {
              const trimmedLine = line.trim();
              if (!trimmedLine) return;
              
              console.log(`  ğŸ“ è¡Œ ${lineIndex + 1}: "${trimmedLine}"`);
              
              // Valrhonaå½¢å¼ã®ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³: "475g Liquid starch"
              const valrhonaIngredient = trimmedLine.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/);
              if (valrhonaIngredient) {
                const quantity = valrhonaIngredient[1];
                const unit = normalizeUnit(valrhonaIngredient[2]);
                const item = valrhonaIngredient[3].trim();
                
                console.log(`    ğŸ” Valrhonaææ–™å€™è£œ: "${item}" - ${quantity} ${unit}`);
                
                // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ã‚„é‡é‡æƒ…å ±ã§ãªã„ã“ã¨ã‚’ç¢ºèª
                if (!item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i) && item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    âœ… Valrhonaææ–™è¿½åŠ :', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    âŒ Valrhonaææ–™é™¤å¤–ï¼ˆã‚¿ã‚¤ãƒˆãƒ«/é‡é‡ï¼‰:', item);
                }
                return;
              }
              
              // ä¸€èˆ¬å½¢å¼ã®ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³: "Liquid starch - 475g"
              const generalIngredient = trimmedLine.match(/^(.+?)\s*[-â€“]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
              if (generalIngredient) {
                const item = generalIngredient[1].trim();
                const quantity = generalIngredient[2];
                const unit = normalizeUnit(generalIngredient[3]);
                
                console.log(`    ğŸ” ä¸€èˆ¬ææ–™å€™è£œ: "${item}" - ${quantity} ${unit}`);
                
                if (item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    âœ… ä¸€èˆ¬ææ–™è¿½åŠ :', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    âŒ ä¸€èˆ¬ææ–™é™¤å¤–ï¼ˆçŸ­ã™ãï¼‰:', item);
                }
                return;
              }
              
              // æ–°ãƒ‘ã‚¿ãƒ¼ãƒ³: æ‰‹é †å†…ã®ææ–™æŠ½å‡º "475g liquid starch", "320g JIVARA 40%"ãªã©
              const inlineIngredients = trimmedLine.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([a-zA-Z\s%0-9]+)/g);
              if (inlineIngredients) {
                console.log(`    ğŸ” æ‰‹é †å†…ææ–™æ¤œå‡º: ${inlineIngredients.length}å€‹`);
                inlineIngredients.forEach((match, matchIndex) => {
                  const ingredientMatch = match.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)/);
                  if (ingredientMatch) {
                    const quantity = ingredientMatch[1];
                    const unit = normalizeUnit(ingredientMatch[2]);
                    const item = ingredientMatch[3].trim();
                    
                    console.log(`      ğŸ” æ‰‹é †å†…ææ–™ ${matchIndex + 1}: "${item}" - ${quantity} ${unit}`);
                    
                    // ææ–™ã¨ã—ã¦é©åˆ‡ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆä¸€èˆ¬çš„ãªææ–™åï¼‰
                    const isValidIngredient = item.match(/^(liquid starch|jivara|gelatin|water|heavy cream|sugar|beer|flour|eggs|yeast|butter|milk|potato starch|glucose|candied|nuts|pistachios|hazelnuts|kasha)/i);
                    
                    if (isValidIngredient && item.length >= 3) {
                      currentSection.ingredients.push({
                        quantity: quantity,
                        unit: unit,
                        item: item
                      });
                      console.log(`      âœ… æ‰‹é †å†…ææ–™è¿½åŠ : ${item} - ${quantity} ${unit}`);
                    } else {
                      console.log(`      âŒ æ‰‹é †å†…ææ–™é™¤å¤–: ${item} (ææ–™åã¨ã—ã¦ä¸é©åˆ‡)`);
                    }
                  }
                });
                return;
              }
              
              console.log('    âŒ ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãªã—');
            });
            
            console.log(`ğŸ¥„ ç¾åœ¨ã®ææ–™æ•°: ${currentSection.ingredients.length}`);
            
            // æ‰‹é †ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ ï¼ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ã¨ææ–™ã‚’é™¤ãï¼‰
            let cleanInstruction = stepText
              .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
              .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
              .replace(/(\d+g)\s*Total weight/i, '')
              .trim();
            
            if (cleanInstruction && cleanInstruction.length > 10) {
              currentSection.instructions.push(cleanInstruction);
              console.log('ğŸ“‹ æ‰‹é †è¿½åŠ :', cleanInstruction.substring(0, 50) + '...');
            }
          } else {
            console.log('âš ï¸ currentSectionãŒnull - ã‚»ã‚¯ã‚·ãƒ§ãƒ³æœªæ¤œå‡º');
          }
        });
        
        // æœ€å¾Œã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        if (currentSection) {
          console.log('ğŸ“ æœ€çµ‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†:', currentSection.title, `ææ–™æ•°: ${currentSection.ingredients.length}`);
          sections.push(currentSection);
        }
      } else {
        console.log('âš ï¸ æ‰‹é †ãƒ‡ãƒ¼ã‚¿ãªã—');
      }
      
      console.log('ğŸ è§£æå®Œäº† - ç·ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°:', sections.length);
      sections.forEach((section, index) => {
        console.log(`  ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ${index + 1}: "${section.title}" - ææ–™æ•°: ${section.ingredients.length}`);
      });
      
      // æœ€çµ‚çš„ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
      if (sections.length === 0) {
        console.log('âš ï¸ å…¨ã¦ã®æŠ½å‡ºæ–¹æ³•ãŒå¤±æ•— - åŸºæœ¬æ§‹é€ ã‚’ä½œæˆ');
        sections.push({
          title: 'INGREDIENTS',
          ingredients: r.ingredients ? r.ingredients.map(ingredient => normalizeIngredientObject(ingredient)) : [],
          instructions: r.steps || [],
          totalWeight: null
        });
      } else {
        // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯è¦‹ã¤ã‹ã£ãŸãŒææ–™ãŒæŠ½å‡ºã§ãã¦ã„ãªã„å ´åˆã€å…ƒã®ææ–™ãƒªã‚¹ãƒˆã‚’åˆ†é…
        const totalIngredients = sections.reduce((sum, section) => sum + (section.ingredients?.length || 0), 0);
        console.log('ğŸ” ç·ææ–™æ•°ãƒã‚§ãƒƒã‚¯:', totalIngredients);
        
        if (totalIngredients === 0 && r.ingredients && r.ingredients.length > 0) {
          console.log('âš ï¸ ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ææ–™ãªã— - æ™ºèƒ½åˆ†é…ã‚’å®Ÿè¡Œ');
          console.log('ğŸ“Š å…ƒææ–™ãƒªã‚¹ãƒˆ:', r.ingredients);
          
          // ææ–™ã®æ„å‘³ã«åŸºã¥ãæ™ºèƒ½åˆ†é…
          const smartMapping = createSmartIngredientMapping(r.ingredients, sections);
          
          sections.forEach((section, sectionIndex) => {
            if (smartMapping[section.title]) {
              section.ingredients = smartMapping[section.title];
              console.log(`ğŸ“‹ æ™ºèƒ½åˆ†é…: "${section.title}" ã«ææ–™ ${section.ingredients.length} å€‹ã‚’é…ç½®`);
            }
          });
        }
      }
      
      return sections;
    }

    // æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
    function extractSectionsFromSteps(recipeData, siteDetection) {
      const r = recipeData || {};
      const sections = [];
      
      if (!r.steps || r.steps.length === 0) return sections;
      
      let currentSection = null;
      
      r.steps.forEach((step, index) => {
        const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
        
        // åŒ…æ‹¬çš„ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
        const sectionPatterns = [
          // Valrhonaå½¢å¼: "Step01 LIQUID STARCH"
          /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i,
          // ä¸€èˆ¬çš„ãªç•ªå·ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³: "1. Preparation", "2. Dough Making"
          /^(\d+)\.?\s*([A-Z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // å¤§æ–‡å­—ã‚¿ã‚¤ãƒˆãƒ«: "LIQUID STARCH", "PREPARATION"
          /^([A-Z][A-Z\s&%0-9]{4,})(?:\n|$)/i,
          // æ‹¬å¼§ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³: "(1) Preparation", "[Step 1] Mixing"
          /^[\(\[\{]?(?:Step\s*)?(\d+)[\)\]\}]?\s*([A-Za-z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // æ—¥æœ¬èªã‚»ã‚¯ã‚·ãƒ§ãƒ³: "1. ä¸‹æº–å‚™", "2. ç”Ÿåœ°ä½œã‚Š"
          /^(\d+)\.?\s*([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]{3,})(?:\n|$)/i
        ];
        
        let detectedTitle = null;
        let sectionMatch = null;
        
        for (const pattern of sectionPatterns) {
          const match = stepText.match(pattern);
          if (match) {
            detectedTitle = (match[2] || match[1]).trim();
            sectionMatch = match;
            console.log(`ğŸ¯ ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡º (ãƒ‘ã‚¿ãƒ¼ãƒ³${sectionPatterns.indexOf(pattern) + 1}):`, detectedTitle);
            break;
          }
        }
        
        if (sectionMatch && detectedTitle && detectedTitle.length >= 3) {
          // æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹
          if (currentSection) {
            sections.push(currentSection);
          }
          
          currentSection = {
            title: detectedTitle,
            ingredients: [],
            instructions: [],
            totalWeight: null
          };
        }
        
        if (currentSection) {
          // ææ–™æŠ½å‡ºã®å¼·åŒ–
          extractIngredientsFromStep(stepText, currentSection);
          
          // é‡é‡æƒ…å ±æŠ½å‡º
          const weightMatch = stepText.match(/(\d+g)\s*Total weight|Total weight[:\s]*(\d+g)|^(\d+g)$/i);
          if (weightMatch) {
            currentSection.totalWeight = weightMatch[1] || weightMatch[2] || weightMatch[3];
          }
          
          // æ‰‹é †ãƒ†ã‚­ã‚¹ãƒˆã®è¿½åŠ 
          const cleanInstruction = cleanStepText(stepText);
          if (cleanInstruction && cleanInstruction.length > 10) {
            currentSection.instructions.push(cleanInstruction);
          }
        }
      });
      
      if (currentSection) {
        sections.push(currentSection);
      }
      
      return sections;
    }

    // ææ–™ã‹ã‚‰æ–™ç†å·¥ç¨‹ã‚’æ¨æ¸¬ã™ã‚‹é–¢æ•°
    function inferSectionsFromIngredients(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 6) return [];
      
      const sections = [];
      const ingredientCategories = categorizeIngredients(r.ingredients);
      
      // ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
      Object.entries(ingredientCategories).forEach(([category, ingredients]) => {
        if (ingredients.length > 0) {
          sections.push({
            title: category,
            ingredients: ingredients,
            instructions: [],
            totalWeight: null
          });
        }
      });
      
      return sections;
    }

    // ææ–™ã‚’ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«åˆ†é¡ã™ã‚‹é–¢æ•°ï¼ˆæ—¥æœ¬èªå¯¾å¿œå¼·åŒ–ç‰ˆï¼‰
    function categorizeIngredients(ingredients) {
      const categories = {
        'ãƒ™ãƒ¼ã‚¹ææ–™ / BASE': [],
        'ãƒ•ã‚£ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ã‚¹ / FILLING': [],
        'ãƒˆãƒƒãƒ”ãƒ³ã‚°ãƒ»é£¾ã‚Š / TOPPINGS': [],
        'èª¿å‘³æ–™ãƒ»é¦™æ–™ / SEASONINGS': [],
        'ãã®ä»– / OTHERS': []
      };
      
      console.log('ğŸ” ææ–™ã‚«ãƒ†ã‚´ãƒªåˆ†é¡é–‹å§‹:', ingredients.length, 'å€‹');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIng = normalizeIngredientObject(ingredient);
        const itemName = normalizedIng.item.toLowerCase();
        
        console.log(`ğŸ” ææ–™ ${index + 1}: "${normalizedIng.item}"`);
        
        // ç”Ÿåœ°ãƒ»ãƒ™ãƒ¼ã‚¹ææ–™ï¼ˆæ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œï¼‰
        if (itemName.match(/flour|bread|dough|starch|yeast|egg|milk|butter|oil|sugar|water|å°éº¦ç²‰|è–„åŠ›ç²‰|å¼·åŠ›ç²‰|åµ|ç‰›ä¹³|ãƒã‚¿ãƒ¼|ç ‚ç³–|æ°´|ãƒ™ãƒ¼ã‚­ãƒ³ã‚°ãƒ‘ã‚¦ãƒ€ãƒ¼|ã‚¤ãƒ¼ã‚¹ãƒˆ|ç”Ÿåœ°/)) {
          categories['ãƒ™ãƒ¼ã‚¹ææ–™ / BASE'].push(normalizedIng);
          console.log(`  â†’ ãƒ™ãƒ¼ã‚¹ææ–™ ã«åˆ†é¡`);
        }
        // ã‚½ãƒ¼ã‚¹ãƒ»ãƒ•ã‚£ãƒªãƒ³ã‚°ï¼ˆæ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œï¼‰
        else if (itemName.match(/cream|sauce|chocolate|ganache|filling|syrup|jam|paste|ã‚¯ãƒªãƒ¼ãƒ |ãƒãƒ§ã‚³|ã‚½ãƒ¼ã‚¹|ã‚¸ãƒ£ãƒ |ã‚·ãƒ­ãƒƒãƒ—|ã‚¬ãƒŠãƒƒã‚·ãƒ¥|ã‚ã‚“|é¤¡/)) {
          categories['ãƒ•ã‚£ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ã‚¹ / FILLING'].push(normalizedIng);
          console.log(`  â†’ ãƒ•ã‚£ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ã‚¹ ã«åˆ†é¡`);
        }
        // ãƒˆãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œï¼‰
        else if (itemName.match(/nuts|seeds|fruits?|berries|sprinkles|decoration|topping|ãƒŠãƒƒãƒ„|ç¨®|å®Ÿ|æœç‰©|ãƒ•ãƒ«ãƒ¼ãƒ„|é£¾ã‚Š|ãƒˆãƒƒãƒ”ãƒ³ã‚°|ç²‰ç³–|ã‚·ãƒŠãƒ¢ãƒ³|ã‚³ã‚³ã‚¢/)) {
          categories['ãƒˆãƒƒãƒ”ãƒ³ã‚°ãƒ»é£¾ã‚Š / TOPPINGS'].push(normalizedIng);
          console.log(`  â†’ ãƒˆãƒƒãƒ”ãƒ³ã‚°ãƒ»é£¾ã‚Š ã«åˆ†é¡`);
        }
        // èª¿å‘³æ–™ï¼ˆæ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œï¼‰
        else if (itemName.match(/salt|pepper|spice|herb|vanilla|extract|seasoning|å¡©|èƒ¡æ¤’|ã“ã—ã‚‡ã†|é†¤æ²¹|å‘³å™Œ|é…¢|ã¿ã‚Šã‚“|é…’|é¦™æ–™|ã‚¨ãƒƒã‚»ãƒ³ã‚¹|ãƒãƒ‹ãƒ©|ã‚¹ãƒ‘ã‚¤ã‚¹/)) {
          categories['èª¿å‘³æ–™ãƒ»é¦™æ–™ / SEASONINGS'].push(normalizedIng);
          console.log(`  â†’ èª¿å‘³æ–™ãƒ»é¦™æ–™ ã«åˆ†é¡`);
        }
        // ã‹ã¼ã¡ã‚ƒç³»ï¼ˆç‰¹åˆ¥åˆ†é¡ï¼‰
        else if (itemName.match(/pumpkin|squash|ã‹ã¼ã¡ã‚ƒ|å—ç“œ|ãƒãƒƒã‚·ãƒ¥/)) {
          categories['ãƒ™ãƒ¼ã‚¹ææ–™ / BASE'].push(normalizedIng);
          console.log(`  â†’ ãƒ™ãƒ¼ã‚¹ææ–™ ã«åˆ†é¡ (ã‹ã¼ã¡ã‚ƒç³»)`);
        }
        // ãã®ä»–
        else {
          categories['ãã®ä»– / OTHERS'].push(normalizedIng);
          console.log(`  â†’ ãã®ä»– ã«åˆ†é¡`);
        }
      });
      
      // ç©ºã®ã‚«ãƒ†ã‚´ãƒªã‚’å‰Šé™¤
      Object.keys(categories).forEach(key => {
        if (categories[key].length === 0) {
          delete categories[key];
        }
      });
      
      console.log('ğŸ“‹ åˆ†é¡çµæœ:');
      Object.entries(categories).forEach(([category, items]) => {
        console.log(`  ${category}: ${items.length}å€‹`);
      });
      
      return categories;
    }

    // è¤‡é›‘ãªãƒ¬ã‚·ãƒ”ã®è‡ªå‹•åˆ†å‰²
    function createAutoSections(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 8) return [];
      
      const sections = [];
      const sectionSize = Math.ceil(r.ingredients.length / 3); // 3åˆ†å‰²ã‚’åŸºæœ¬ã¨ã™ã‚‹
      
      const sectionNames = ['PREPARATION', 'MAIN PROCESS', 'FINISHING'];
      
      for (let i = 0; i < 3; i++) {
        const startIndex = i * sectionSize;
        const endIndex = Math.min(startIndex + sectionSize, r.ingredients.length);
        const sectionIngredients = r.ingredients.slice(startIndex, endIndex);
        
        if (sectionIngredients.length > 0) {
          sections.push({
            title: sectionNames[i],
            ingredients: sectionIngredients.map(ingredient => normalizeIngredientObject(ingredient)),
            instructions: [],
            totalWeight: null
          });
        }
      }
      
      return sections;
    }

    // æ‰‹é †ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ææ–™ã‚’æŠ½å‡ºã™ã‚‹å¼·åŒ–ç‰ˆ
    function extractIngredientsFromStep(stepText, section) {
      const lines = stepText.split('\n');
      
      lines.forEach(line => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        
        // è¤‡æ•°ã®ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
        const patterns = [
          // "475g Liquid starch"
          /^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/,
          // "Liquid starch - 475g"
          /^(.+?)\s*[-â€“]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/,
          // "2 cups flour"
          /^(\d+(?:\.\d+)?)\s+(cups?|tbsp|tsp|pieces?)\s+(.+)$/i,
          // æ—¥æœ¬èªãƒ‘ã‚¿ãƒ¼ãƒ³: "å°éº¦ç²‰ 200g"
          /^([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s*(\d+(?:\.\d+)?)\s*([a-zA-Zï½‡ï½ï½Œ%]+)$/
        ];
        
        for (const pattern of patterns) {
          const match = trimmedLine.match(pattern);
          if (match) {
            let item, quantity, unit;
            
            if (pattern === patterns[0]) { // "475g Liquid starch"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[1]) { // "Liquid starch - 475g"
              [, item, quantity, unit] = match;
            } else if (pattern === patterns[2]) { // "2 cups flour"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[3]) { // æ—¥æœ¬èª
              [, item, quantity, unit] = match;
            }
            
            // æœ‰åŠ¹ãªææ–™ã‹ãƒã‚§ãƒƒã‚¯
            if (item && item.length >= 2 && !item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i)) {
              section.ingredients.push({
                item: item.trim(),
                quantity: quantity || '',
                unit: normalizeUnit(unit || '')
              });
              break;
            }
          }
        }
      });
    }

    // æ‰‹é †ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã™ã‚‹é–¢æ•°
    function cleanStepText(stepText) {
      return stepText
        .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
        .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
        .replace(/(\d+g)\s*Total weight/i, '')
        .trim();
    }

    // æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”å°‚ç”¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆé–¢æ•°
    function createJapaneseProfessionalSections(recipeData, url = '') {
      console.log('ğŸ·ï¸ æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆé–‹å§‹');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('ğŸ“Š æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”åˆ†æ:');
      console.log(`  ã‚¿ã‚¤ãƒˆãƒ«: "${title}"`);
      console.log(`  ææ–™æ•°: ${ingredients.length}`);
      console.log(`  æ‰‹é †æ•°: ${steps.length}`);
      
      const sections = [];
      
      // ã‚¸ãƒ“ã‚¨ãƒ¬ã‚·ãƒ”ã®å ´åˆã®ç‰¹åˆ¥å‡¦ç†
      const isGibierRecipe = title.match(/é¹¿|çŒª|ã„ã®ã—ã—|ã‚¸ãƒ“ã‚¨|ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³|wellington/i) ||
                            ingredients.some(ing => {
                              const itemName = typeof ing === 'string' ? ing : (ing.item || ing.name || '');
                              return itemName.match(/é¹¿|çŒª|ã„ã®ã—ã—|ã‚¸ãƒ“ã‚¨|venison|wild.*boar/i);
                            });
      
      if (isGibierRecipe) {
        console.log('ğŸ¦Œ ã‚¸ãƒ“ã‚¨ãƒ¬ã‚·ãƒ”æ¤œå‡º - å°‚ç”¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆ');
        
        // æ‰‹é †ã‹ã‚‰å·¥ç¨‹ã‚’æ¤œå‡º
        const detectedProcesses = [];
        const allText = `${title} ${steps.join(' ')}`;
        
        // ã‚¸ãƒ“ã‚¨æ–™ç†ã®å…¸å‹çš„ãªå·¥ç¨‹ãƒ‘ã‚¿ãƒ¼ãƒ³
        const processPatterns = [
          { pattern: /ãƒãƒªãƒŠãƒ¼ãƒ‰|ãƒãƒªãƒ|æ¼¬ã‘è¾¼ã¿|ä¸‹å‘³/i, section: 'ãƒãƒªãƒŠãƒ¼ãƒ‰ãƒ»ä¸‹æº–å‚™' },
          { pattern: /ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³|ãƒ‘ã‚¤åŒ…ã¿|ãƒ‘ã‚¤ç”Ÿåœ°/i, section: 'ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³åŒ…ã¿' },
          { pattern: /ã‚³ãƒ³ãƒ•ã‚£|ä½æ¸©èª¿ç†|çœŸç©º/i, section: 'ã‚³ãƒ³ãƒ•ã‚£ãƒ»ä»˜ã‘åˆã‚ã›' },
          { pattern: /ãƒ‰ãƒ•ã‚£ãƒãƒ¯ãƒ¼ã‚º|ã‚°ãƒ©ã‚¿ãƒ³|ãƒ™ã‚·ãƒ£ãƒ¡ãƒ«/i, section: 'ãƒ‰ãƒ•ã‚£ãƒãƒ¯ãƒ¼ã‚º' },
          { pattern: /ã‚½ãƒ¼ã‚¹|ç‡»ç…™|é†¤æ²¹|æŸšå­/i, section: 'ã‚½ãƒ¼ã‚¹ãƒ»èª¿å‘³æ–™' },
          { pattern: /ãƒ•ãƒªã‚«ãƒƒã‚»|ãã®ã“|èŒ¸|ãƒãƒƒã‚·ãƒ¥ãƒ«ãƒ¼ãƒ /i, section: 'ãƒ•ãƒªã‚«ãƒƒã‚»ãƒ»ã‚¬ãƒ«ãƒ‹' },
          { pattern: /ã‚¸ã‚§ãƒãƒ™ãƒ¼ã‚¼|ãƒ¯ã‚µãƒ“|é¦™è‰/i, section: 'ãƒãƒ¼ãƒ–ãƒ»è–¬å‘³' },
          { pattern: /ç››ã‚Šä»˜ã‘|ä»•ä¸Šã’|é£¾ã‚Š/i, section: 'ç››ã‚Šä»˜ã‘ãƒ»ä»•ä¸Šã’' }
        ];
        
        processPatterns.forEach(({ pattern, section }) => {
          if (pattern.test(allText)) {
            detectedProcesses.push(section);
            console.log(`  å·¥ç¨‹æ¤œå‡º: ${section}`);
          }
        });
        
        // ææ–™ã‚’å·¥ç¨‹åˆ¥ã«åˆ†é¡
        if (detectedProcesses.length > 0) {
          detectedProcesses.forEach(processName => {
            const sectionIngredients = [];
            
            ingredients.forEach(ingredient => {
              const normalizedIngredient = normalizeIngredientObject(ingredient);
              const itemName = normalizedIngredient.item.toLowerCase();
              
              // å·¥ç¨‹åˆ¥ææ–™åˆ†é¡ãƒ«ãƒ¼ãƒ«ï¼ˆå¤§å¹…å¼·åŒ–ï¼‰
              let shouldInclude = false;
              
              switch (processName) {
                case 'ãƒãƒªãƒŠãƒ¼ãƒ‰ãƒ»ä¸‹æº–å‚™':
                  shouldInclude = itemName.match(/é¹¿|ãƒ­ãƒ¼ã‚¹|è‚‰|å‘³å™Œ|é¦™è‰|å¡©|ã‚³ã‚·ãƒ§ã‚¦|pepper|salt|miso|marinade|marinate|ä¸‹å‘³|æ¼¬ã‘è¾¼ã¿/i);
                  break;
                case 'ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³åŒ…ã¿':
                  shouldInclude = itemName.match(/ãƒ‘ã‚¤|ã‚·ãƒ¼ãƒˆ|ã‚­ãƒ£ãƒ™ãƒ„|åµé»„|pastry|puff|cabbage|egg|wellington|åŒ…ã¿|ç”Ÿåœ°|ç²’ç”Ÿé»’ã‚³ã‚·ãƒ§ã‚¦|ãƒ•ãƒ«ãƒ¼ãƒ«.*ã‚»ãƒ«/i);
                  break;
                case 'ã‚³ãƒ³ãƒ•ã‚£ãƒ»ä»˜ã‘åˆã‚ã›':
                  shouldInclude = itemName.match(/ç™½ãƒã‚®|ã­ã|ã‚ªãƒªãƒ¼ãƒ–ã‚ªã‚¤ãƒ«|ãƒ‹ãƒ³ãƒ‹ã‚¯|ã‚¿ã‚¤ãƒ |ãƒ­ãƒ¼ãƒªã‚¨|leek|olive|garlic|thyme|bay|confit|ã”ã¼ã†|ãƒ‘ãƒ³ãƒã‚§ãƒƒã‚¿|ç‰ãƒã‚®|ç„¡å¡©ãƒã‚¿ãƒ¼|ãƒã‚­ãƒ³ãƒ–ã‚¤ãƒ¨ãƒ³|ç™½ã‚³ã‚·ãƒ§ã‚¦/i);
                  break;
                case 'ãƒ‰ãƒ•ã‚£ãƒãƒ¯ãƒ¼ã‚º':
                  shouldInclude = itemName.match(/ã‚µãƒ„ãƒã‚¤ãƒ¢|ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢|ç”Ÿã‚¯ãƒªãƒ¼ãƒ |ç‰›ä¹³|ãƒ‘ãƒ«ãƒ¡ã‚¶ãƒ³|potato|cream|milk|parmesan|dauphinoise|ãƒ™ã‚·ãƒ£ãƒ¡ãƒ«|è–„åŠ›ç²‰|ãƒŠãƒ„ãƒ¡ã‚°/i);
                  break;
                case 'ã‚½ãƒ¼ã‚¹ãƒ»èª¿å‘³æ–™':
                  shouldInclude = itemName.match(/é†¤æ²¹|ç‡»ç…™|æŸšå­|ãƒã‚¿ãƒ¼|ãƒ–ã‚¤ãƒ¨ãƒ³|ã‚³ãƒ¼ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ|soy|yuzu|butter|stock|cornstarch|ç„¦ãŒã—ãƒã‚¿ãƒ¼|ç‡»ç…™é†¬æ²¹|æŸšå­æœæ±/i);
                  break;
                case 'ãƒ•ãƒªã‚«ãƒƒã‚»ãƒ»ã‚¬ãƒ«ãƒ‹':
                  shouldInclude = itemName.match(/ã‚¸ãƒ­ãƒ«|ãƒˆãƒ©ãƒ³ãƒšãƒƒãƒˆ|èŠ½ã‚­ãƒ£ãƒ™ãƒ„|ãã®ã“|èŒ¸|mushroom|brussels|fricassee|ãƒ‰ãƒ©ã‚¤ãƒˆãƒ©ãƒ³ãƒšãƒƒãƒˆ|ã‚¨ã‚·ãƒ£ãƒ­ãƒƒãƒˆ|ã‚µãƒ©ãƒ€æ²¹/i);
                  break;
                case 'ãƒãƒ¼ãƒ–ãƒ»è–¬å‘³':
                  shouldInclude = itemName.match(/ãƒ¯ã‚µãƒ“|ã‚ã•ã³|é¦™è‰|ãƒ‘ã‚»ãƒª|wasabi|herb|parsley|ã‚¸ã‚§ãƒãƒ™ãƒ¼ã‚¼|genovese|ãƒ”ãƒ¼ãƒ†ãƒ³ãƒ‰ãƒªãƒ«|ãƒã‚¤ã‚¯ãƒ­ã‚¢ãƒãƒ©ãƒ³ã‚µã‚¹/i);
                  break;
                case 'ç››ã‚Šä»˜ã‘ãƒ»ä»•ä¸Šã’':
                  shouldInclude = itemName.match(/é£¾ã‚Š|ã‚¬ãƒ«ãƒ‹|ãƒã‚¤ã‚¯ãƒ­|garnish|micro|ç››ã‚Šä»˜ã‘|ä»•ä¸Šã’|decoration/i);
                  break;
              }
              
              // ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªææ–™ãƒãƒƒãƒãƒ³ã‚°ï¼ˆéƒ¨åˆ†ä¸€è‡´ã‚‚è€ƒæ…®ï¼‰
              if (!shouldInclude) {
                // ææ–™åã«å«ã¾ã‚Œã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§å†ãƒã‚§ãƒƒã‚¯
                const keywords = itemName.split(/\s+|ãƒ»|ã€|,/);
                keywords.forEach(keyword => {
                  if (keyword.length >= 2) { // 2æ–‡å­—ä»¥ä¸Šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ã¿
                    switch (processName) {
                      case 'ãƒãƒªãƒŠãƒ¼ãƒ‰ãƒ»ä¸‹æº–å‚™':
                        if (keyword.match(/é¹¿|è‚‰|å‘³å™Œ|é¦™è‰|å¡©|èƒ¡æ¤’/i)) shouldInclude = true;
                        break;
                      case 'ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³åŒ…ã¿':
                        if (keyword.match(/ãƒ‘ã‚¤|ã‚­ãƒ£ãƒ™ãƒ„|åµ|ç”Ÿåœ°|é»’èƒ¡æ¤’|ã‚»ãƒ«/i)) shouldInclude = true;
                        break;
                      case 'ã‚³ãƒ³ãƒ•ã‚£ãƒ»ä»˜ã‘åˆã‚ã›':
                        if (keyword.match(/ãƒã‚®|ã‚ªãƒªãƒ¼ãƒ–|ãƒ‹ãƒ³ãƒ‹ã‚¯|ã”ã¼ã†|ãƒã‚¿ãƒ¼|ãƒ–ã‚¤ãƒ¨ãƒ³/i)) shouldInclude = true;
                        break;
                      case 'ãƒ‰ãƒ•ã‚£ãƒãƒ¯ãƒ¼ã‚º':
                        if (keyword.match(/ã‚¤ãƒ¢|èŠ‹|ã‚¯ãƒªãƒ¼ãƒ |ç‰›ä¹³|ãƒãƒ¼ã‚º|å°éº¦ç²‰/i)) shouldInclude = true;
                        break;
                      case 'ã‚½ãƒ¼ã‚¹ãƒ»èª¿å‘³æ–™':
                        if (keyword.match(/é†¤æ²¹|æŸšå­|ãƒã‚¿ãƒ¼|ã‚½ãƒ¼ã‚¹|èª¿å‘³/i)) shouldInclude = true;
                        break;
                      case 'ãƒ•ãƒªã‚«ãƒƒã‚»ãƒ»ã‚¬ãƒ«ãƒ‹':
                        if (keyword.match(/ãã®ã“|èŒ¸|ã‚­ãƒ£ãƒ™ãƒ„|ã‚¨ã‚·ãƒ£ãƒ­ãƒƒãƒˆ/i)) shouldInclude = true;
                        break;
                      case 'ãƒãƒ¼ãƒ–ãƒ»è–¬å‘³':
                        if (keyword.match(/ãƒ¯ã‚µãƒ“|é¦™è‰|ãƒãƒ¼ãƒ–|ãƒ‘ã‚»ãƒª/i)) shouldInclude = true;
                        break;
                    }
                  }
                });
              }
              
              if (shouldInclude) {
                sectionIngredients.push(normalizedIngredient);
                console.log(`    ææ–™åˆ†é¡: "${normalizedIngredient.item}" â†’ ${processName}`);
              }
            });
            
            if (sectionIngredients.length > 0) {
              sections.push({
                title: processName,
                ingredients: sectionIngredients,
                instructions: [],
                totalWeight: null
              });
            }
          });
        }
      }
      
      // ä¸€èˆ¬çš„ãªæ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”ã®å ´åˆ
      if (sections.length === 0) {
        console.log('ğŸ³ ä¸€èˆ¬æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”å‡¦ç†');
        
        // ææ–™ã‚’åŸºæœ¬çš„ãªã‚«ãƒ†ã‚´ãƒªã«åˆ†é¡
        const basicCategories = {
          'ä¸»ææ–™': [],
          'èª¿å‘³æ–™ãƒ»ã‚½ãƒ¼ã‚¹': [],
          'ä»˜ã‘åˆã‚ã›': [],
          'ä»•ä¸Šã’ãƒ»é£¾ã‚Š': []
        };
        
        ingredients.forEach(ingredient => {
          const normalizedIngredient = normalizeIngredientObject(ingredient);
          const itemName = normalizedIngredient.item.toLowerCase();
          
          // åŸºæœ¬åˆ†é¡ãƒ«ãƒ¼ãƒ«
          if (itemName.match(/è‚‰|é­š|é¶|è±š|ç‰›|é¹¿|çŒª|meat|fish|chicken|pork|beef|venison/i)) {
            basicCategories['ä¸»ææ–™'].push(normalizedIngredient);
          } else if (itemName.match(/é†¤æ²¹|å‘³å™Œ|å¡©|ç ‚ç³–|é…¢|æ²¹|ã‚½ãƒ¼ã‚¹|ãƒã‚¿ãƒ¼|soy|miso|salt|sugar|vinegar|oil|sauce|butter/i)) {
            basicCategories['èª¿å‘³æ–™ãƒ»ã‚½ãƒ¼ã‚¹'].push(normalizedIngredient);
          } else if (itemName.match(/é‡èœ|ãã®ã“|èŠ‹|ãƒã‚®|ã‚­ãƒ£ãƒ™ãƒ„|vegetable|mushroom|potato|leek|cabbage/i)) {
            basicCategories['ä»˜ã‘åˆã‚ã›'].push(normalizedIngredient);
          } else if (itemName.match(/é£¾ã‚Š|é¦™è‰|ã‚¹ãƒ‘ã‚¤ã‚¹|garnish|herb|spice/i)) {
            basicCategories['ä»•ä¸Šã’ãƒ»é£¾ã‚Š'].push(normalizedIngredient);
          } else {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä¸»ææ–™ã«
            basicCategories['ä¸»ææ–™'].push(normalizedIngredient);
          }
        });
        
        // ç©ºã§ãªã„ã‚«ãƒ†ã‚´ãƒªã®ã¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã—ã¦è¿½åŠ 
        Object.entries(basicCategories).forEach(([categoryName, categoryIngredients]) => {
          if (categoryIngredients.length > 0) {
            sections.push({
              title: categoryName,
              ingredients: categoryIngredients,
              instructions: [],
              totalWeight: null
            });
          }
        });
      }
      
      console.log('ğŸ æ—¥æœ¬èªãƒ—ãƒ­ãƒ¬ã‚·ãƒ”ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆå®Œäº†:', sections.length, 'å€‹');
      sections.forEach((section, index) => {
        console.log(`  ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ${index + 1}: "${section.title}" - ææ–™æ•°: ${section.ingredients.length}`);
      });
      
      return sections;
    }

    // Valrhonaå°‚ç”¨ã®ææ–™ãƒãƒƒãƒ”ãƒ³ã‚°é–¢æ•°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    function createValrhonaIngredientMapping(ingredients) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('ğŸ” Valrhonaææ–™ãƒãƒƒãƒ”ãƒ³ã‚°é–‹å§‹:', ingredients.length, 'å€‹ã®ææ–™');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        const quantity = parseInt(normalizedIngredient.quantity) || 0;
        
        console.log(`ğŸ” ææ–™ ${index + 1}: "${normalizedIngredient.item}" - ${normalizedIngredient.quantity} ${normalizedIngredient.unit}`);
        
        // ã‚ˆã‚ŠåŒ…æ‹¬çš„ã§ç²¾å¯†ãªåˆ†é¡ãƒ«ãƒ¼ãƒ«
        let classified = false;
        
        // LIQUID STARCH ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        if (itemName.match(/liquid\s*starch/) || itemName.includes('starch')) {
          mapping['LIQUID STARCH'].push(normalizedIngredient);
          console.log(`  â†’ LIQUID STARCH ã«åˆ†é¡ (starché–¢é€£)`);
          classified = true;
        }
        
        // JIVARA GANACHE ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        if (itemName.match(/jivara/) || 
            itemName.match(/chocolate|ganache/) ||
            (itemName.includes('heavy cream') && quantity >= 190) ||
            itemName.match(/gelatin|gelatine/)) {
          mapping['JIVARA 40% INTENSE WHIPPED GANACHE'].push(normalizedIngredient);
          console.log(`  â†’ JIVARA GANACHE ã«åˆ†é¡ (${itemName.includes('jivara') ? 'jivara' : itemName.includes('cream') ? 'heavy cream' : itemName.includes('gelatin') ? 'gelatin' : 'chocolateé–¢é€£'})`);
          classified = true;
        }
        
        // CANDIED NUT MIX ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        if (itemName.match(/hazelnut|pistachio|kasha|nuts|candied|roasted.*piedmont|blanched.*sicilian/)) {
          mapping['SWEET & SAVORY CANDIED NUT MIX'].push(normalizedIngredient);
          console.log(`  â†’ CANDIED NUT MIX ã«åˆ†é¡ (ãƒŠãƒƒãƒ„é–¢é€£: ${itemName})`);
          classified = true;
        }
        
        // BEER SYRUP ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        if (itemName.includes('beer') ||
           (itemName.includes('sugar') && quantity >= 755) ||
           (itemName.includes('water') && quantity >= 605) ||
           itemName.includes('glucose') ||
           itemName.includes('milk') && quantity > 100) {
          mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
          console.log(`  â†’ BEER SYRUP ã«åˆ†é¡ (${itemName.includes('beer') ? 'beer' : itemName.includes('glucose') ? 'glucose' : itemName.includes('milk') ? 'milk' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water ${quantity}g`})`);
          classified = true;
        }
        
        // BABA DOUGH ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        if (itemName.match(/flour|strong.*flour/) ||
           itemName.match(/egg|whole.*egg/) ||
           itemName.match(/yeast|live.*yeast/) ||
           itemName.match(/butter|european.*style.*butter/) ||
           itemName.match(/lemon|candied.*lemon|diced.*candied/) ||
           itemName.includes('fleur de sel') ||
           itemName.includes('sel') ||
           (itemName.includes('sugar') && quantity <= 55) ||
           (itemName.includes('water') && quantity <= 320 && itemName.includes('gelatin'))) {
          mapping['BABA DOUGH'].push(normalizedIngredient);
          console.log(`  â†’ BABA DOUGH ã«åˆ†é¡ (${itemName.includes('flour') ? 'flour' : itemName.includes('egg') ? 'egg' : itemName.includes('yeast') ? 'yeast' : itemName.includes('butter') ? 'butter' : itemName.includes('lemon') ? 'lemon' : itemName.includes('sel') ? 'sel' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water for gelatin`})`);
          classified = true;
        }
        
        // æœªåˆ†é¡ã®å‡¦ç†
        if (!classified) {
          console.warn(`âš ï¸ æœªåˆ†é¡ææ–™: "${normalizedIngredient.item}" - ${quantity}${normalizedIngredient.unit}`);
          
          // æ•°é‡ã«åŸºã¥ãæ¨æ¸¬
          if (itemName.includes('water')) {
            if (quantity <= 320) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  â†’ BABA DOUGH ã«åˆ†é¡ (å°‘é‡æ°´: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  â†’ BEER SYRUP ã«åˆ†é¡ (å¤§é‡æ°´: ${quantity}g)`);
            }
          } else if (itemName.includes('sugar')) {
            if (quantity <= 100) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  â†’ BABA DOUGH ã«åˆ†é¡ (å°‘é‡ç ‚ç³–: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  â†’ BEER SYRUP ã«åˆ†é¡ (å¤§é‡ç ‚ç³–: ${quantity}g)`);
            }
          } else {
            // æœ€å¾Œã®æ‰‹æ®µ: LIQUID STARCHã«åˆ†é¡
            mapping['LIQUID STARCH'].push(normalizedIngredient);
            console.log(`  â†’ LIQUID STARCH ã«åˆ†é¡ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ${itemName})`);
          }
        }
      });
      
      // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ææ–™æ•°ã‚’ãƒ­ã‚°å‡ºåŠ›
      Object.entries(mapping).forEach(([section, ingredients]) => {
        console.log(`ğŸ“‹ ${section}: ${ingredients.length}å€‹ã®ææ–™`);
        ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${ing.item} - ${ing.quantity} ${ing.unit}`);
        });
      });
      
      return mapping;
    }

    // ä¸€èˆ¬çš„ãªãƒ¬ã‚·ãƒ”ç”¨ã®æ™ºèƒ½ææ–™åˆ†é…é–¢æ•°
    function createSmartIngredientMapping(ingredients, sections) {
      const mapping = {};
      
      // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–
      sections.forEach(section => {
        mapping[section.title] = [];
      });
      
      console.log('ğŸ§  æ™ºèƒ½ææ–™åˆ†é…é–‹å§‹:', ingredients.length, 'å€‹ã®ææ–™ã‚’', sections.length, 'å€‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†é…');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        
        let assigned = false;
        
        // ã‚»ã‚¯ã‚·ãƒ§ãƒ³åã«åŸºã¥ãåˆ†é…
        sections.forEach(section => {
          const sectionName = section.title.toLowerCase();
          
          // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°
          const keywords = extractKeywords(sectionName);
          const ingredientKeywords = extractKeywords(itemName);
          
          // å…±é€šã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯å„ªå…ˆçš„ã«åˆ†é…
          const commonKeywords = keywords.filter(k => 
            ingredientKeywords.some(ik => ik.includes(k) || k.includes(ik))
          );
          
          if (commonKeywords.length > 0 && !assigned) {
            mapping[section.title].push(normalizedIngredient);
            console.log(`ğŸ¯ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ: "${normalizedIngredient.item}" â†’ "${section.title}" (å…±é€š: ${commonKeywords.join(', ')})`);
            assigned = true;
          }
        });
        
        // ãƒãƒƒãƒã—ãªã‹ã£ãŸå ´åˆã¯æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†é…
        if (!assigned && sections.length > 0) {
          mapping[sections[0].title].push(normalizedIngredient);
          console.log(`ğŸ“ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåˆ†é…: "${normalizedIngredient.item}" â†’ "${sections[0].title}"`);
        }
      });
      
      return mapping;
    }

    // ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
    function extractKeywords(text) {
      return text.toLowerCase()
        .split(/[\s\-_&%]+/)
        .filter(word => word.length > 2)
        .map(word => word.replace(/[^a-z0-9]/g, ''));
    }

    // ææ–™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ­£è¦åŒ–ã™ã‚‹é–¢æ•°
    function normalizeIngredientObject(ingredient) {
      if (typeof ingredient === 'string') {
        const match = ingredient.match(/^(.+?)\s*[-â€“]\s*(.+)$/);
        if (match) {
          const item = match[1].trim();
          const quantityUnit = match[2].trim();
          // æ—¥æœ¬èªã®å®šæ€§çš„ãªåˆ†é‡ï¼ˆé©é‡ãƒ»å°‘ã€…ãƒ»ã²ã¨ã¤ã¾ã¿ãƒ»ãŠå¥½ã¿ã§ï¼‰ã‚’ç‰¹åˆ¥æ‰±ã„
          const qualitativeMatch = quantityUnit.match(/^(é©é‡|å°‘ã€…|ã²ã¨ã¤ã¾ã¿|ãŠå¥½ã¿ã§)$/);
          if (qualitativeMatch) {
            return {
              item: item,
              quantity: '',
              unit: qualitativeMatch[1]
            };
          }
          const quantityMatch = quantityUnit.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
          if (quantityMatch) {
            return {
              item: item,
              quantity: quantityMatch[1],
              unit: normalizeUnit(quantityMatch[2])
            };
          }
        }
        return { item: ingredient, quantity: '', unit: '' };
      } else {
        return {
          item: ingredient.item || ingredient.name || '',
          quantity: ingredient.quantity || ingredient.amount || '',
          unit: normalizeUnit(ingredient.unit || '')
        };
      }
    }

    // ãƒ¬ã‚·ãƒ”ã®è¤‡é›‘ã•ã‚’è§£æã—ã¦ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤ºãŒé©åˆ‡ã‹ã‚’åˆ¤æ–­
    function analyzeRecipeComplexity(recipeData, url = '') {
      console.log('ğŸ” ãƒ¬ã‚·ãƒ”è¤‡é›‘åº¦è§£æé–‹å§‹');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('ğŸ“Š åŸºæœ¬çµ±è¨ˆ:');
      console.log(`  ææ–™æ•°: ${ingredients.length}`);
      console.log(`  æ‰‹é †æ•°: ${steps.length}`);
      console.log(`  ã‚¿ã‚¤ãƒˆãƒ«: "${title}"`);
      
      // 1. ææ–™æ•°ãŒå°‘ãªã„å ´åˆã¯ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤ºï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
      if (ingredients.length < 5) {
        console.log('âŒ ææ–™æ•°ãŒå°‘ãªã„ (< 5) - ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤º');
        return false;
      }
      
      // 2. æ‰‹é †ã‹ã‚‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’æ¤œå‡ºï¼ˆæ—¥æœ¬èªãƒ‘ã‚¿ãƒ¼ãƒ³å¼·åŒ–ï¼‰
      const stepsText = steps.join(' ').toLowerCase();
      const sectionIndicators = [
        // è‹±èªãƒ‘ã‚¿ãƒ¼ãƒ³
        /for\s+the\s+\w+/g,
        /\b(dough|batter|cream|sauce|filling|ganache|syrup|mixture|wellington|confit|fricassee|duxelles)\b/g,
        /step\s+\d+:/g,
        /part\s+\d+/g,
        // æ—¥æœ¬èªãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¼·åŒ–ï¼‰
        /ã€.*?ã€‘/g,
        /â– .*?â– /g,
        /\d+\.\s*ã€/g,
        /å·¥ç¨‹\s*\d+/g,
        /æ‰‹é †\s*\d+/g,
        /â‘ |â‘¡|â‘¢|â‘£|â‘¤|â‘¥|â‘¦|â‘§|â‘¨|â‘©/g,
        /ã‚’ä½œã‚‹|ã‚’æº–å‚™|ä¸‹æº–å‚™|ä»•ä¸Šã’|ç››ã‚Šä»˜ã‘/g,
        /ã‚½ãƒ¼ã‚¹|ç”Ÿåœ°|ãƒ•ã‚£ãƒªãƒ³ã‚°|ãƒˆãƒƒãƒ”ãƒ³ã‚°|ã‚¬ãƒ«ãƒ‹/g
      ];
      
      let sectionCount = 0;
      sectionIndicators.forEach(pattern => {
        const matches = stepsText.match(pattern);
        if (matches) {
          sectionCount += matches.length;
          console.log(`  ã‚»ã‚¯ã‚·ãƒ§ãƒ³æŒ‡æ¨™ç™ºè¦‹: ${pattern} - ${matches.length}å€‹`);
        }
      });
      
      // 3. ææ–™åã‹ã‚‰è¤‡é›‘åº¦ã‚’åˆ¤å®šï¼ˆæ—¥æœ¬èªãƒ»ã‚¸ãƒ“ã‚¨æ–™ç†å¯¾å¿œå¼·åŒ–ï¼‰
      const complexIngredientPatterns = [
        // å°‚é–€çš„ãªææ–™ï¼ˆè¥¿æ´‹ï¼‰
        /ganache|couverture|valrhona|callebaut/i,
        /glucose|invert\s+sugar|isomalt/i,
        /gellan|agar|pectin|xanthan/i,
        // è¤‡æ•°ã®èª¿ç†å·¥ç¨‹ã‚’ç¤ºå”†ã™ã‚‹ææ–™
        /tempered|melted|whipped|clarified/i,
        /reduction|infusion|extract/i,
        // æ—¥æœ¬èªã®å°‚é–€ææ–™ï¼ˆå¼·åŒ–ï¼‰
        /ã‚¬ãƒŠãƒƒã‚·ãƒ¥|ã‚¯ãƒ¼ãƒ™ãƒ«ãƒãƒ¥ãƒ¼ãƒ«|è»¢åŒ–ç³–|ã‚¢ã‚¬ãƒ¼|ã‚¼ãƒ©ãƒãƒ³/i,
        /ç”Ÿã‚¯ãƒªãƒ¼ãƒ .*?æ³¡ç«‹ã¦|ãƒã‚¿ãƒ¼.*?æº¶ã‹ã—/i,
        // ã‚¸ãƒ“ã‚¨ãƒ»é«˜ç´šé£Ÿæ
        /é¹¿|çŒª|ã„ã®ã—ã—|ã‚¸ãƒ“ã‚¨|venison|wild\s+boar/i,
        /ãƒ•ã‚©ã‚¢ã‚°ãƒ©|ãƒˆãƒªãƒ¥ãƒ•|ã‚­ãƒ£ãƒ“ã‚¢|foie\s+gras|truffle|caviar/i,
        // ãƒ•ãƒ©ãƒ³ã‚¹æ–™ç†æŠ€æ³•
        /ã‚¦ã‚§ãƒªãƒ³ãƒˆãƒ³|wellington|ã‚³ãƒ³ãƒ•ã‚£|confit|ãƒ•ãƒªã‚«ãƒƒã‚»|fricassee/i,
        /ãƒ‰ãƒ•ã‚£ãƒãƒ¯ãƒ¼ã‚º|dauphinoise|ãƒ™ã‚·ãƒ£ãƒ¡ãƒ«|bechamel|ãƒ‡ãƒ¥ã‚¯ã‚»ãƒ«|duxelles/i,
        /ã‚¸ãƒ¥ãƒãƒ™ãƒ¼ã‚¼|genovese|ãƒ•ãƒ«ãƒ¼ãƒ«.*?ã‚»ãƒ«|fleur.*?sel/i,
        // é«˜ç´šèª¿å‘³æ–™ãƒ»ææ–™
        /ãƒ‘ãƒ«ãƒ¡ã‚¶ãƒ³|parmesan|ã‚°ãƒªãƒ¥ã‚¤ã‚¨ãƒ¼ãƒ«|gruyere/i,
        /ã‚¨ã‚·ãƒ£ãƒ­ãƒƒãƒˆ|shallot|ãƒãƒ‡ãƒ©|madeira|ãƒãƒ«ãƒˆ|port/i,
        /ç‡»è£½|ã‚¹ãƒ¢ãƒ¼ã‚¯|smoke|ç‡»ç…™/i,
        // å°‚é–€å™¨å…·ãƒ»æŠ€æ³•ã‚’ç¤ºå”†
        /çœŸç©º|vacuum|ä½æ¸©|sous\s+vide/i,
        /ã‚³ãƒ³ãƒ™ã‚¯ã‚·ãƒ§ãƒ³|convection|ã‚¹ãƒãƒ¼ãƒ |steam/i
      ];
      
      let complexIngredientCount = 0;
      const allText = `${title} ${ingredients.map(ing => 
        typeof ing === 'string' ? ing : (ing.item || ing.name || '')
      ).join(' ')} ${steps.join(' ')}`;
      
      complexIngredientPatterns.forEach(pattern => {
        const matches = allText.match(pattern);
        if (matches) {
          complexIngredientCount += matches.length;
          console.log(`  è¤‡é›‘ææ–™/æŠ€æ³•ç™ºè¦‹: ${matches.join(', ')}`);
        }
      });
      
      // 4. ãƒ—ãƒ­ãƒ¬ã‚·ãƒ”ãƒ»ã‚³ãƒ³ãƒ†ã‚¹ãƒˆå…¥è³ä½œå“ã®æ¤œå‡º
      const professionalIndicators = [
        /ã‚³ãƒ³ãƒ†ã‚¹ãƒˆ|contest|competition|å…¥è³|å—è³|award/i,
        /ã‚·ã‚§ãƒ•|chef|æ–™ç†é•·|ãƒ‘ãƒ†ã‚£ã‚·ã‚¨|patissier/i,
        /ãƒ›ãƒ†ãƒ«|hotel|ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³|restaurant/i,
        /ãƒ—ãƒ­éƒ¨é–€|professional|ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«/i,
        /ãƒŸã‚·ãƒ¥ãƒ©ãƒ³|michelin|æ˜Ÿä»˜ã/i
      ];
      
      let professionalScore = 0;
      professionalIndicators.forEach(pattern => {
        if (pattern.test(allText)) {
          professionalScore += 2;
          console.log(`  ãƒ—ãƒ­æŒ‡æ¨™ç™ºè¦‹: ${pattern}`);
        }
      });
      
      // 5. ç·åˆåˆ¤å®šï¼ˆåŸºæº–ã‚’ç·©å’Œï¼‰
      const complexityScore = sectionCount * 1.5 + complexIngredientCount + professionalScore;
      console.log('ğŸ“Š è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢è¨ˆç®—:');
      console.log(`  ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${sectionCount} Ã— 1.5 = ${sectionCount * 1.5}`);
      console.log(`  è¤‡é›‘ææ–™æ•°: ${complexIngredientCount}`);
      console.log(`  ãƒ—ãƒ­æŒ‡æ¨™: ${professionalScore}`);
      console.log(`  ç·åˆã‚¹ã‚³ã‚¢: ${complexityScore}`);
      
      // 6. ç‰¹å®šã‚µã‚¤ãƒˆã¯å„ªå…ˆçš„ã«ã‚«ãƒ†ã‚´ãƒªè¡¨ç¤ºï¼ˆæ—¥æœ¬èªã‚µã‚¤ãƒˆè¿½åŠ ï¼‰
      const isComplexSite = url && (
        url.includes('valrhona.com') ||
        url.includes('marmiton.org') ||
        url.includes('chef') ||
        url.includes('professional') ||
        url.includes('patisserie') ||
        url.includes('gibier.or.jp') ||
        url.includes('tsuji.ac.jp') ||
        url.includes('cordonbleu') ||
        url.includes('hotel') ||
        url.includes('restaurant')
      );
      
      if (isComplexSite) {
        console.log('âœ… è¤‡é›‘ã‚µã‚¤ãƒˆæ¤œå‡º - ã‚«ãƒ†ã‚´ãƒªè¡¨ç¤ºé©ç”¨');
        return true;
      }
      
      // 7. ææ–™æ•°ã«ã‚ˆã‚‹åˆ¤å®šï¼ˆåŸºæº–ç·©å’Œï¼‰
      const hasManyIngredients = ingredients.length >= 8;
      const hasProfessionalElements = professionalScore > 0 || complexIngredientCount > 0;
      
      // 8. æœ€çµ‚åˆ¤å®šï¼ˆåŸºæº–ã‚’å¤§å¹…ã«ç·©å’Œï¼‰
      const shouldCategorize = 
        complexityScore >= 2 || 
        (ingredients.length >= 8 && sectionCount > 0) ||
        (ingredients.length >= 12) ||
        (hasProfessionalElements && ingredients.length >= 6);
        
      console.log(`${shouldCategorize ? 'âœ…' : 'âŒ'} æœ€çµ‚åˆ¤å®š: ${shouldCategorize ? 'ã‚«ãƒ†ã‚´ãƒªè¡¨ç¤º' : 'ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤º'}`);
      console.log('ğŸ“‹ åˆ¤å®šç†ç”±:');
      console.log(`  è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢ >= 2: ${complexityScore >= 2} (${complexityScore})`);
      console.log(`  ææ–™8å€‹ä»¥ä¸Š + ã‚»ã‚¯ã‚·ãƒ§ãƒ³: ${ingredients.length >= 8 && sectionCount > 0} (ææ–™:${ingredients.length}, ã‚»ã‚¯ã‚·ãƒ§ãƒ³:${sectionCount})`);
      console.log(`  ææ–™12å€‹ä»¥ä¸Š: ${ingredients.length >= 12} (${ingredients.length})`);
      console.log(`  ãƒ—ãƒ­è¦ç´  + ææ–™6å€‹ä»¥ä¸Š: ${hasProfessionalElements && ingredients.length >= 6} (ãƒ—ãƒ­:${hasProfessionalElements}, ææ–™:${ingredients.length})`);
      
      return shouldCategorize;
    }

    // ææ–™å°‚ç”¨ã®ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«è¡¨ç¤ºé–¢æ•°
    function displayFlexibleIngredients(recipeData, containerId, url = '') {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('âŒ ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', containerId);
        return;
      }

      if (Array.isArray(recipeData?.ingredients)) {
        recipeData.ingredients = recipeData.ingredients.map(ing => {
          if (ing && typeof ing === 'object' && ing.section_title && !ing.sectionTitle) {
            return { ...ing, sectionTitle: ing.section_title };
          }
          return ing;
        });
      }
      
      console.log('ğŸ¯ ææ–™è¡¨ç¤ºé–‹å§‹:', containerId);
      console.log('ğŸ“Š URL:', url);
      
      // äº‹å‰ã« sectionTitle ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’å„ªå…ˆã—ã¦ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°
      if (Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(i => i && typeof i === 'object' && 'sectionTitle' in i)) {
        container.innerHTML = '';
        const groups = {};
        (recipeData.ingredients || []).forEach(ing => {
          const key = (ing.sectionTitle || '').trim() || 'ãã®ä»–';
          if (!groups[key]) groups[key] = [];
          groups[key].push(ing);
        });
        Object.entries(groups).forEach(([title, list]) => {
          const sectionDiv = document.createElement('div');
          sectionDiv.className = 'recipe-section';
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = title;
          sectionDiv.appendChild(titleDiv);
          list.forEach(ingredient => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
          });
          const sectionActions = document.createElement('div');
          sectionActions.className = 'inline-actions';
          sectionActions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn secondary';
          addBtn.textContent = 'ææ–™ã‚’è¿½åŠ ';
          addBtn.addEventListener('click', () => { addIngredientRowToSection(sectionDiv); });
          sectionActions.appendChild(addBtn);
          sectionDiv.appendChild(sectionActions);
          container.appendChild(sectionDiv);
        });
        return;
      }

      // ãƒ¬ã‚·ãƒ”æ§‹é€ ã‚’è§£æã—ã¦ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤ºãŒé©åˆ‡ã‹ã‚’åˆ¤æ–­
      const shouldUseCategorization = analyzeRecipeComplexity(recipeData, url);
      
      console.log('ğŸ·ï¸ ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤ºé©ç”¨åˆ¤å®š:', shouldUseCategorization);
      
      if (!shouldUseCategorization) {
        console.log('ğŸ“ ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤ºã‚’ä½¿ç”¨');
        displaySimpleIngredients(recipeData, containerId);
        return;
      }
      
      console.log('ğŸ”§ ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤ºã‚’è©¦è¡Œ');
      console.log('ğŸ“Š ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿:', recipeData);
      console.log('ğŸ“Š ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ :', {
        hasTitle: !!recipeData?.title,
        hasIngredients: !!recipeData?.ingredients,
        hasSteps: !!recipeData?.steps,
        ingredientsLength: recipeData?.ingredients?.length || 0,
        stepsLength: recipeData?.steps?.length || 0
      });
      
      const sections = parseComplexRecipeStructure(recipeData, url);
      console.log('ğŸ“‹ è§£æã•ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°:', sections.length);
      console.log('ğŸ“‹ å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è©³ç´°:');
      let flatIndex = 0;
      sections.forEach((section, index) => {
        console.log(`  ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ${index + 1}: "${section.title}" - ææ–™æ•°: ${section.ingredients?.length || 0}`);
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach((ing, ingIndex) => {
            console.log(`    ææ–™ ${ingIndex + 1}: ${ing.item} - ${ing.quantity} ${ing.unit}`);
          });
        }
      });
      
      container.innerHTML = '';
      let displayedSections = 0;
      
      // ææ–™ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã¿ã‚’è¡¨ç¤º
      sections.forEach((section, index) => {
        console.log(`ğŸ” ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ${index + 1} å‡¦ç†ä¸­:`, section.title, `ææ–™æ•°: ${section.ingredients?.length || 0}`);
        
        if (section.ingredients && section.ingredients.length > 0) {
          const sectionDiv = document.createElement('div');
          sectionDiv.className = 'recipe-section';
          sectionDiv.setAttribute('data-section-title', section.title || '');
          
          // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = section.title;
          sectionDiv.appendChild(titleDiv);
          console.log('ğŸ“ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š:', section.title);
          
          // ç·é‡é‡
          if (section.totalWeight) {
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${section.totalWeight}`;
            sectionDiv.appendChild(weightDiv);
            console.log('âš–ï¸ é‡é‡è¡¨ç¤º:', section.totalWeight);
          }
          
          // ææ–™ã‚°ãƒªãƒƒãƒ‰
          section.ingredients.forEach((ingredient, ingredientIndex) => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            gridDiv.setAttribute('data-ing-index', String(flatIndex++));
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.contentEditable = 'true';
            nameDiv.spellcheck = false;
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.contentEditable = 'true';
            quantityDiv.spellcheck = false;
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.contentEditable = 'true';
            unitDiv.spellcheck = false;
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
            
            console.log(`ğŸ¥„ ææ–™ ${ingredientIndex + 1} è¿½åŠ :`, `${ingredient.item} - ${ingredient.quantity} ${ingredient.unit}`);
          });
          // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å°‚ç”¨ã€Œææ–™ã‚’è¿½åŠ ã€ãƒœã‚¿ãƒ³
          const sectionActions = document.createElement('div');
          sectionActions.className = 'inline-actions';
          sectionActions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn secondary';
          addBtn.textContent = 'ææ–™ã‚’è¿½åŠ ';
          addBtn.addEventListener('click', () => {
            addIngredientRowToSection(sectionDiv);
          });
          sectionActions.appendChild(addBtn);
          sectionDiv.appendChild(sectionActions);
          
          container.appendChild(sectionDiv);
          displayedSections++;
          console.log('âœ… ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºå®Œäº†:', section.title);
        } else {
          console.log('âš ï¸ ææ–™ãªã—ã‚»ã‚¯ã‚·ãƒ§ãƒ³:', section.title);
        }
      });
      
      if (displayedSections > 0) {
        const flattened = [];
        sections.forEach(section => {
          (section.ingredients || []).forEach(ingredient => {
            const cloned = { ...(ingredient || {}) };
            cloned.sectionTitle = section.title || '';
            flattened.push(cloned);
          });
        });
        recipeData.ingredients = flattened;
        if (containerId === 'flexibleIngredientsDisplay') {
          window.currentRecipeData = window.currentRecipeData || {};
          window.currentRecipeData.ingredients = flattened.map(ing => ({
            item: ing.item || ing.name || '',
            quantity: ing.quantity || '',
            unit: ing.unit || '',
            sectionTitle: ing.sectionTitle || ''
          }));
        }
      }

      console.log(`ğŸ ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«è¡¨ç¤ºå®Œäº† - è¡¨ç¤ºã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${displayedSections}`);
      
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³åŒ–ã•ã‚ŒãŸææ–™ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å¾“æ¥ã®è¡¨ç¤º
      if (displayedSections === 0) {
        console.log('âš ï¸ ã‚«ãƒ†ã‚´ãƒªåŒ–ææ–™ãªã— - ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤ºã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
        console.log('ğŸ“Š ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±èª¿æŸ»:');
        console.log('  - ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°:', sections.length);
        sections.forEach((section, index) => {
          console.log(`  - ã‚»ã‚¯ã‚·ãƒ§ãƒ³ ${index + 1}: "${section.title}" ææ–™æ•°: ${section.ingredients?.length || 0}`);
        });
        displaySimpleIngredients(recipeData, containerId);
      } else {
        console.log('âœ… ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤ºæˆåŠŸï¼');
      }
    }
    
    // ã‚·ãƒ³ãƒ—ãƒ«ãªææ–™è¡¨ç¤ºé–¢æ•°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
    function displaySimpleIngredients(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const r = recipeData || {};
      container.innerHTML = '';
      
      if (r.ingredients && r.ingredients.length > 0) {
        r.ingredients.forEach(ingredient => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          
          // ææ–™ã®è¡¨ç¤ºå½¢å¼ã‚’æ”¹å–„ï¼ˆåˆ†é‡ã®ãƒ€ãƒ–ã‚Šã‚’é˜²ãï¼‰
          let ingredientText = '';
          if (typeof ingredient === 'string') {
            ingredientText = ingredient;
          } else if (ingredient && typeof ingredient === 'object') {
            const itemName = ingredient.item || ingredient.name || '';
            const quantity = ingredient.quantity || ingredient.amount || '';
            const rawUnit = ingredient.unit || '';
            
            // å˜ä½ã‚’æ­£è¦åŒ–
            const unit = normalizeUnit(rawUnit);
            
            // åˆ†é‡ãªã—/å®šæ€§çš„ãªåˆ†é‡ã®æ‰±ã„ã‚’æœ€é©åŒ–
            const qualitativeUnits = ['é©é‡', 'å°‘ã€…', 'ã²ã¨ã¤ã¾ã¿', 'ãŠå¥½ã¿ã§'];
            const hasQuantity = quantity !== '' && quantity !== null && typeof quantity !== 'undefined';
            let quantityUnit = '';
            if (hasQuantity) {
              quantityUnit = [quantity, unit].filter(Boolean).join(' ');
            } else if (qualitativeUnits.includes(unit)) {
              quantityUnit = unit;
            } else {
              quantityUnit = '';
            }
            
            // ææ–™åã¨åˆ†é‡ã‚’çµ„ã¿åˆã‚ã›ï¼ˆåˆ†é‡ãŒç©ºãªã‚‰ãƒã‚¤ãƒ•ãƒ³ã‚’å‡ºã•ãªã„ï¼‰
            ingredientText = quantityUnit ? [itemName, quantityUnit].join(' - ') : itemName;
          }
          
          item.textContent = ingredientText || 'ææ–™æƒ…å ±ãªã—';
          container.appendChild(item);
        });
      } else if (r.ingredientLines && r.ingredientLines.length > 0) {
        r.ingredientLines.forEach(line => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          item.textContent = line;
          container.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'ingredient-item';
        item.textContent = 'ææ–™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ';
        container.appendChild(item);
      }
    }

    // ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«ãªãƒ¬ã‚·ãƒ”è¡¨ç¤ºé–¢æ•°
    function displayFlexibleRecipe(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const sections = parseComplexRecipeStructure(recipeData);
      
      container.innerHTML = '';
      
      sections.forEach(section => {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'recipe-section';
        
        // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«
        const titleDiv = document.createElement('div');
        titleDiv.className = 'recipe-section-title';
        titleDiv.textContent = section.title;
        sectionDiv.appendChild(titleDiv);
        
        // ç·é‡é‡
        if (section.totalWeight) {
          const weightDiv = document.createElement('div');
          weightDiv.className = 'recipe-section-weight';
          weightDiv.textContent = `Total weight: ${section.totalWeight}`;
          sectionDiv.appendChild(weightDiv);
        }
        
        // ææ–™ã‚°ãƒªãƒƒãƒ‰
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach(ingredient => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
          });
        }
        
        // æ‰‹é †
        if (section.instructions && section.instructions.length > 0) {
          const instructionsDiv = document.createElement('div');
          instructionsDiv.className = 'recipe-instructions';
          
          section.instructions.forEach(instruction => {
            const p = document.createElement('p');
            p.textContent = instruction;
            instructionsDiv.appendChild(p);
          });
          
          sectionDiv.appendChild(instructionsDiv);
        }
        
        container.appendChild(sectionDiv);
      });
    }

    // ç¿»è¨³çµæœã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function displayTranslatedResults(translatedData) {
      if (!translatedData) return;

      // ç”»åƒã®è¡¨ç¤º
      const imageContainer = document.getElementById('translatedRecipeImageContainer');
      const recipeImage = document.getElementById('translatedRecipeImage');
      if (currentRecipeData && currentRecipeData.image_url) {
        recipeImage.src = currentRecipeData.image_url;
        imageContainer.style.display = 'block';
      } else {
        imageContainer.style.display = 'none';
      }

      document.getElementById('translatedRecipeTitle').textContent = translatedData.title || '-';
      document.getElementById('translatedRecipeDescription').textContent = translatedData.description || '-';
      document.getElementById('translatedRecipeServings').textContent = translatedData.servings || '-';

      const finalIngredients = ensureIngredientSectionTitles(
        currentRecipeData.ingredients,
        translatedData.ingredients
      );

      translatedData.ingredients = finalIngredients;
      displayFlexibleIngredients(translatedData, 'flexibleTranslatedIngredientsDisplay', window.lastProcessedUrl);
      renderSteps(document.getElementById('translatedStepsList'), translatedData.steps || [], false);
    }

    // ç¿»è¨³ææ–™ã‚’ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function displayTranslatedIngredientsAsTable(translatedData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('âŒ ç¿»è¨³ç”¨ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', containerId);
        return;
      }
      
      container.innerHTML = '';
      const ingredients = translatedData.ingredients || [];
      
      if (ingredients.length === 0) {
        container.innerHTML = '<div class="ingredient-item">ç¿»è¨³ã•ã‚ŒãŸææ–™ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }
      
      console.log('ğŸŒ ç¿»è¨³ææ–™ã‚’ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¡¨ç¤º:', ingredients.length, 'å€‹');
      
      // ææ–™ã‚’4ã¤ã®ã‚«ãƒ†ã‚´ãƒªã«åˆ†é¡
      const categories = {
        base: { title: 'ãƒ™ãƒ¼ã‚¹ææ–™ / BASE', items: [] },
        filling: { title: 'ãƒ•ã‚£ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ã‚¹ / FILLING', items: [] },
        seasoning: { title: 'èª¿å‘³æ–™ãƒ»é¦™æ–™ / SEASONINGS', items: [] },
        others: { title: 'ãã®ä»– / OTHERS', items: [] }
      };
      
      // å„ææ–™ã‚’ã‚«ãƒ†ã‚´ãƒªã«åˆ†é¡
      ingredients.forEach(ing => {
        const itemName = (ing.item || '').toLowerCase();
        const unit = (ing.unit || '').toLowerCase();
        
        // ãƒ™ãƒ¼ã‚¹ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³
        if (itemName.match(/flour|farine|ç”Ÿåœ°|dough|pÃ¢te|ç²‰|è–„åŠ›ç²‰|å¼·åŠ›ç²‰|ãƒã‚¿ãƒ¼|butter|beurre|åµ|egg|Å“uf|ç‰›ä¹³|milk|lait/i)) {
          categories.base.items.push(ing);
        }
        // ãƒ•ã‚£ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³
        else if (itemName.match(/cream|crÃ¨me|ã‚¯ãƒªãƒ¼ãƒ |sauce|ã‚½ãƒ¼ã‚¹|ganache|ã‚¬ãƒŠãƒƒã‚·ãƒ¥|filling|ãƒ•ã‚£ãƒªãƒ³ã‚°|ç”Ÿã‚¯ãƒªãƒ¼ãƒ |ãƒ›ã‚¤ãƒƒãƒ—/i)) {
          categories.filling.items.push(ing);
        }
        // èª¿å‘³æ–™ãƒ»é¦™æ–™ãƒ‘ã‚¿ãƒ¼ãƒ³
        else if (itemName.match(/salt|sel|å¡©|sugar|sucre|ç ‚ç³–|pepper|poivre|ã“ã—ã‚‡ã†|èƒ¡æ¤’|spice|Ã©pice|é¦™è¾›æ–™|vanilla|vanille|ãƒãƒ‹ãƒ©|ã‚·ãƒŠãƒ¢ãƒ³|cinnamon|cannelle/i)) {
          categories.seasoning.items.push(ing);
        }
        // ãã®ä»–
        else {
          categories.others.items.push(ing);
        }
      });
      
      // ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆ
      let categoryCount = 0;
      Object.values(categories).forEach(category => {
        if (category.items.length > 0) {
          categoryCount++;
          
          // ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚¿ã‚¤ãƒˆãƒ«
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = category.title;
          titleDiv.style.cssText = 'font-weight: bold; color: #4a90e2; margin: 1.5rem 0 0.5rem 0; padding: 0.5rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px;';
          container.appendChild(titleDiv);
          
          // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ãªã—ï¼‰
          const table = document.createElement('table');
          table.className = 'table';
          
          // ãƒ†ãƒ¼ãƒ–ãƒ«ãƒœãƒ‡ã‚£
          const tbody = document.createElement('tbody');
          category.items.forEach((ingredient, index) => {
            const row = document.createElement('tr');
            
            // ç•ªå·
            const tdNum = document.createElement('td');
            tdNum.textContent = index + 1;
            tdNum.style.textAlign = 'center';
            row.appendChild(tdNum);
            
            // ææ–™å
            const tdItem = document.createElement('td');
            tdItem.textContent = ingredient.item || '';
            row.appendChild(tdItem);
            
            // æ•°é‡
            const tdQty = document.createElement('td');
            tdQty.textContent = ingredient.quantity || '';
            tdQty.style.textAlign = 'right';
            row.appendChild(tdQty);
            
            // å˜ä½
            const tdUnit = document.createElement('td');
            tdUnit.textContent = ingredient.unit || '';
            tdUnit.style.textAlign = 'center';
            row.appendChild(tdUnit);
            
            tbody.appendChild(row);
          });
          table.appendChild(tbody);
          container.appendChild(table);
          
          console.log(`âœ… ã‚«ãƒ†ã‚´ãƒªãƒ¼ "${category.title}": ${category.items.length}å€‹ã®ææ–™ã‚’è¡¨ç¤º`);
        }
      });
      
      if (categoryCount === 0) {
        // ã‚«ãƒ†ã‚´ãƒªåˆ†ã‘ã§ããªã„å ´åˆã¯å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¡¨ç¤ºï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ãªã—ï¼‰
        const table = document.createElement('table');
        table.className = 'table';
        
        const tbody = document.createElement('tbody');
        ingredients.forEach((ingredient, index) => {
          const row = document.createElement('tr');
          
          const tdNum = document.createElement('td');
          tdNum.textContent = index + 1;
          tdNum.style.textAlign = 'center';
          row.appendChild(tdNum);
          
          const tdItem = document.createElement('td');
          tdItem.textContent = ingredient.item || '';
          row.appendChild(tdItem);
          
          const tdQty = document.createElement('td');
          tdQty.textContent = ingredient.quantity || '';
          tdQty.style.textAlign = 'right';
          row.appendChild(tdQty);
          
          const tdUnit = document.createElement('td');
          tdUnit.textContent = ingredient.unit || '';
          tdUnit.style.textAlign = 'center';
          row.appendChild(tdUnit);
          
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        container.appendChild(table);
        
        console.log(`âœ… å…¨ææ–™ã‚’å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¡¨ç¤º: ${ingredients.length}å€‹`);
      }
      
      console.log('ğŸ‰ ç¿»è¨³ææ–™ã®ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºå®Œäº†');
    }

    // ç¿»è¨³ææ–™ã®æ§‹é€ ç¶­æŒè¡¨ç¤ºé–¢æ•°ï¼ˆæ—§ç‰ˆ - äº’æ›æ€§ã®ãŸã‚ä¿æŒï¼‰
    function displayTranslatedIngredientsWithStructure(translatedData, originalData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('âŒ ç¿»è¨³ç”¨ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', containerId);
        return;
      }
      
      console.log('ğŸŒ ç¿»è¨³æ§‹é€ ç¶­æŒè¡¨ç¤ºé–‹å§‹');
      console.log('ğŸ“Š ç¿»è¨³ãƒ‡ãƒ¼ã‚¿:', translatedData);
      console.log('ğŸ“Š å…ƒãƒ‡ãƒ¼ã‚¿:', originalData);
      
      // å…ƒã®ãƒ¬ã‚·ãƒ”æ§‹é€ ã‚’å–å¾—ï¼ˆæ—¢ã«è§£ææ¸ˆã¿ã®æ§‹é€ ã‚’å†åˆ©ç”¨ï¼‰
      const url = window.lastProcessedUrl || '';
      const isValrhonaSite = url.includes('valrhona.com');
      
      if (isValrhonaSite && originalData && originalData.ingredients) {
        console.log('ğŸ·ï¸ Valrhonaç¿»è¨³: å…ƒæ§‹é€ ã‚’ç¶­æŒã—ã¦ç¿»è¨³ææ–™ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°');
        
        // å…ƒã®Valrhonaãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å†å®Ÿè¡Œ
        const originalMapping = createValrhonaIngredientMapping(originalData.ingredients);
        console.log('ğŸ“‹ å…ƒã®ãƒãƒƒãƒ”ãƒ³ã‚°:', originalMapping);
        
        // ç¿»è¨³ææ–™ã‚’å…ƒã®æ§‹é€ ã«ãƒãƒƒãƒ”ãƒ³ã‚°
        const translatedMapping = mapTranslatedIngredientsToOriginalStructure(
          translatedData.ingredients || [],
          originalData.ingredients || [],
          originalMapping
        );
        
        // Valrhonaã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è¡¨ç¤º
        const valrhonaSections = [
          { title: 'LIQUID STARCH', titleJa: 'æ¶²ä½“æ¾±ç²‰', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', titleJa: 'ã‚¸ãƒ´ã‚¡ãƒ©40% ã‚¤ãƒ³ãƒ†ãƒ³ã‚¹ ãƒ›ã‚¤ãƒƒãƒ—ã‚¬ãƒŠãƒƒã‚·ãƒ¥', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', titleJa: 'ã‚¹ã‚¤ãƒ¼ãƒˆ&ã‚»ã‚¤ãƒœãƒªãƒ¼ ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ãƒ¼ãƒ‰ãƒŠãƒƒãƒ„ãƒŸãƒƒã‚¯ã‚¹', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', titleJa: 'ãƒãƒç”¨ãƒ“ãƒ¼ãƒ«ã‚·ãƒ­ãƒƒãƒ—', weight: '3000g' },
          { title: 'BABA DOUGH', titleJa: 'ãƒãƒç”Ÿåœ°', weight: '599g' }
        ];
        
        container.innerHTML = '';
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = translatedMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'recipe-section';
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆæ—¥æœ¬èªï¼‰
            const titleDiv = document.createElement('div');
            titleDiv.className = 'recipe-section-title';
            titleDiv.textContent = sectionInfo.titleJa;
            sectionDiv.appendChild(titleDiv);
            
            // ç·é‡é‡
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${sectionInfo.weight}`;
            sectionDiv.appendChild(weightDiv);
            
            // ææ–™ã‚°ãƒªãƒƒãƒ‰
            sectionIngredients.forEach((ingredient) => {
              const gridDiv = document.createElement('div');
              gridDiv.className = 'recipe-ingredients-grid';
              
              const nameDiv = document.createElement('div');
              nameDiv.className = 'ingredient-name';
              nameDiv.textContent = ingredient.item || '';
              
              const quantityDiv = document.createElement('div');
              quantityDiv.className = 'ingredient-quantity';
              quantityDiv.textContent = ingredient.quantity || '';
              
              const unitDiv = document.createElement('div');
              unitDiv.className = 'ingredient-unit';
              unitDiv.textContent = ingredient.unit || '';
              
              gridDiv.appendChild(nameDiv);
              gridDiv.appendChild(quantityDiv);
              gridDiv.appendChild(unitDiv);
              sectionDiv.appendChild(gridDiv);
            });
            
            container.appendChild(sectionDiv);
            console.log(`âœ… ç¿»è¨³ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º: "${sectionInfo.titleJa}" - ææ–™æ•°: ${sectionIngredients.length}`);
          }
        });
        
        console.log('ğŸŒ Valrhonaç¿»è¨³æ§‹é€ è¡¨ç¤ºå®Œäº†');
      } else {
        console.log('âš ï¸ éValrhonaã‚µã‚¤ãƒˆ: é€šå¸¸ã®ç¿»è¨³è¡¨ç¤º');
        displayFlexibleIngredients(translatedData, containerId, '');
      }
    }

    // ç¿»è¨³ææ–™ã‚’å…ƒã®æ§‹é€ ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹é–¢æ•°
    function mapTranslatedIngredientsToOriginalStructure(translatedIngredients, originalIngredients, originalMapping) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('ğŸ”— ç¿»è¨³ææ–™ãƒãƒƒãƒ”ãƒ³ã‚°é–‹å§‹');
      console.log('ğŸ“Š ç¿»è¨³ææ–™æ•°:', translatedIngredients.length);
      console.log('ğŸ“Š å…ƒææ–™æ•°:', originalIngredients.length);
      
      // ç¿»è¨³ææ–™ã‚’é †ç•ªã«å…ƒã®æ§‹é€ ã«å¯¾å¿œä»˜ã‘
      translatedIngredients.forEach((translatedIng, index) => {
        const normalizedTranslated = normalizeIngredientObject(translatedIng);
        
        // å¯¾å¿œã™ã‚‹å…ƒã®ææ–™ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ™ãƒ¼ã‚¹ï¼‰
        if (index < originalIngredients.length) {
          const originalIng = originalIngredients[index];
          
          // å…ƒã®ææ–™ãŒã©ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†é¡ã•ã‚Œã¦ã„ãŸã‹ã‚’èª¿ã¹ã‚‹
          let foundSection = null;
          Object.entries(originalMapping).forEach(([sectionName, sectionIngredients]) => {
            if (sectionIngredients.some(ing => 
              ing.item === (typeof originalIng === 'string' ? originalIng : originalIng.item))) {
              foundSection = sectionName;
            }
          });
          
          if (foundSection) {
            mapping[foundSection].push(normalizedTranslated);
            console.log(`ğŸ”— ãƒãƒƒãƒ”ãƒ³ã‚°: "${normalizedTranslated.item}" â†’ ${foundSection}`);
          } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«è¿½åŠ 
            mapping['LIQUID STARCH'].push(normalizedTranslated);
            console.log(`ğŸ”— ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: "${normalizedTranslated.item}" â†’ LIQUID STARCH`);
          }
        }
      });
      
      return mapping;
    }

    // ã‚µã‚¤ãƒˆã®è¨€èªã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
    function detectSiteLanguage(html, url) {
      console.log('ğŸ” ã‚µã‚¤ãƒˆè¨€èªåˆ¤å®šé–‹å§‹:', url);
      
      // URLãƒ™ãƒ¼ã‚¹ã®åˆ¤å®š
      const urlIndicators = {
        ja: ['.jp', 'cookpad.com', 'kurashiru.com', 'delishkitchen.tv', 'japanese', 'japan', 'rakuten-recipe.jp'],
        en: ['.com', '.org', '.net', '.edu', '.gov', '.uk', '.au', '.ca'],
        fr: ['.fr', 'marmiton.org', 'cuisine.fr', 'elle.fr/cuisine'],
        it: ['.it', 'giallozafferano.it', 'ricette.it'],
        de: ['.de', 'chefkoch.de', 'essen-und-trinken.de'],
        es: ['.es', 'recetasgratis.net', 'directoalpaladar.com']
      };
      
      let detectedLanguage = { code: 'en', name: 'English', isJapanese: false };
      
      // URLã‹ã‚‰è¨€èªã‚’åˆ¤å®š
      for (const [langCode, indicators] of Object.entries(urlIndicators)) {
        if (indicators.some(indicator => url && url.toLowerCase().includes(indicator))) {
          detectedLanguage = {
            code: langCode,
            name: getLanguagePromptName(langCode),
            isJapanese: langCode === 'ja'
          };
          console.log('ğŸŒ URLåˆ¤å®šçµæœ:', langCode, 'â†’', detectedLanguage);
          break;
        }
      }
      
      // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰è¨€èªã‚’åˆ¤å®šï¼ˆURLãƒ™ãƒ¼ã‚¹åˆ¤å®šã‚’è£œå¼·ï¼‰
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      const frenchRegex = /\b(recette|ingrÃ©dients|prÃ©paration|cuisson|pour|avec|dans|une|des|les|temps|min)\b/i;
      const italianRegex = /\b(ricetta|ingredienti|preparazione|cottura|per|con|in|una|dei|gli|tempo|min)\b/i;
      const germanRegex = /\b(rezept|zutaten|zubereitung|kochen|fÃ¼r|mit|in|eine|der|die|zeit|min)\b/i;
      const spanishRegex = /\b(receta|ingredientes|preparaciÃ³n|cocciÃ³n|para|con|en|una|los|las|tiempo|min)\b/i;
      
      if (japaneseRegex.test(html)) {
        detectedLanguage = { code: 'ja', name: getLanguagePromptName('ja'), isJapanese: true };
        console.log('ğŸ‡¯ğŸ‡µ æ—¥æœ¬èªæ–‡å­—æ¤œå‡º â†’ Japanese');
      } else if (frenchRegex.test(html)) {
        detectedLanguage = { code: 'fr', name: getLanguagePromptName('fr'), isJapanese: false };
        console.log('ğŸ‡«ğŸ‡· ãƒ•ãƒ©ãƒ³ã‚¹èªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º â†’ French');
      } else if (italianRegex.test(html)) {
        detectedLanguage = { code: 'it', name: getLanguagePromptName('it'), isJapanese: false };
        console.log('ğŸ‡®ğŸ‡¹ ã‚¤ã‚¿ãƒªã‚¢èªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º â†’ Italian');
      } else if (germanRegex.test(html)) {
        detectedLanguage = { code: 'de', name: getLanguagePromptName('de'), isJapanese: false };
        console.log('ğŸ‡©ğŸ‡ª ãƒ‰ã‚¤ãƒ„èªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º â†’ German');
      } else if (spanishRegex.test(html)) {
        detectedLanguage = { code: 'es', name: getLanguagePromptName('es'), isJapanese: false };
        console.log('ğŸ‡ªğŸ‡¸ ã‚¹ãƒšã‚¤ãƒ³èªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º â†’ Spanish');
      }
      
      console.log('ğŸ æœ€çµ‚è¨€èªåˆ¤å®š:', detectedLanguage);
      return detectedLanguage;
    }

    // ãƒ¬ã‚·ãƒ”æŠ½å‡ºãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    function generateRecipeExtractionPrompt(htmlContent, url, siteLanguage = { code: 'en', name: 'English', isJapanese: false }) {
      console.log('ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆé–‹å§‹:', {
        url: url,
        siteLanguage: siteLanguage,
        contentLength: htmlContent.length
      });
      
      // è¨€èªåˆ¥ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
      if (siteLanguage.isJapanese) {
        // æ—¥æœ¬èªã‚µã‚¤ãƒˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆRecipe Keeper.appæœ€é©åŒ–ç‰ˆï¼‰
        return `ä»¥ä¸‹ã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰æ—¥æœ¬èªãƒ¬ã‚·ãƒ”ã‚’è§£æã—ã€JSONå½¢å¼ã§æ§‹é€ åŒ–ã—ã¦ãã ã•ã„ã€‚

ã€Recipe Keeperæœ€é©åŒ–æŒ‡ç¤ºã€‘
- é«˜é€Ÿå‡¦ç†ã«ç‰¹åŒ–ã—ãŸç°¡æ½”ãªè§£æ
- ææ–™ãƒªã‚¹ãƒˆã®æ­£ç¢ºãªæŠ½å‡ºã‚’å„ªå…ˆ
- åˆ†é‡ãƒ»å˜ä½ã®åˆ†é›¢ã«é‡ç‚¹
- æ—¥æœ¬èªæ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ä¿è­·
- ä¸è¦ãªèª¬æ˜æ–‡ã¯æœ€å°é™ã«

ã€æ—¥æœ¬èªå‡¦ç†è¦ä»¶ã€‘
1. ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ã‚’æ­£ç¢ºã«æŠ½å‡º
2. UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç¶­æŒ
3. æ—¥æœ¬èªç‰¹æœ‰ã®åˆ†é‡è¡¨è¨˜ã‚’èªè­˜ï¼ˆå¤§ã•ã˜ã€å°ã•ã˜ã€ã‚«ãƒƒãƒ—ã€ã¤ã¾ã¿ç­‰ï¼‰
4. æ–‡å­—åŒ–ã‘ã‚’é˜²æ­¢

ã€å…¥åŠ›HTMLã€‘
${htmlContent.substring(0, 8000)}

ã€å‡ºåŠ›å½¢å¼ã€‘
{
  "title": "ãƒ¬ã‚·ãƒ”å",
  "description": "ç°¡æ½”ãªèª¬æ˜",
  "servings": "äººæ•°",
  "ingredients": [
    {"item": "ææ–™å", "quantity": "åˆ†é‡", "unit": "å˜ä½"}
  ],
  "steps": ["æ‰‹é †1", "æ‰‹é †2"],
  "notes": "ãƒ¡ãƒ¢"
}

ã€ææ–™æŠ½å‡ºä¾‹ã€‘
- å°éº¦ç²‰ 100g â†’ {"item": "å°éº¦ç²‰", "quantity": "100", "unit": "g"}
- åµ 1å€‹ â†’ {"item": "åµ", "quantity": "1", "unit": "å€‹"}
- å¤§ã•ã˜2ã®é†¤æ²¹ â†’ {"item": "é†¤æ²¹", "quantity": "2", "unit": "å¤§ã•ã˜"}
- é©é‡ã®å¡© â†’ {"item": "å¡©", "quantity": "é©é‡", "unit": ""}
- ãƒã‚¿ãƒ¼ 15g â†’ {"item": "ãƒã‚¿ãƒ¼", "quantity": "15", "unit": "g"}
- ç‰›ä¹³ 200ml â†’ {"item": "ç‰›ä¹³", "quantity": "200", "unit": "ml"}
- ç ‚ç³– 30g â†’ {"item": "ç ‚ç³–", "quantity": "30", "unit": "g"}

ã€åˆ†é‡ãƒ»å˜ä½æŠ½å‡ºã®é‡è¦ãƒ«ãƒ¼ãƒ«ã€‘
1. ææ–™åã€åˆ†é‡ã€å˜ä½ã‚’å¿…ãšåˆ†é›¢ã—ã¦ãã ã•ã„
2. åˆ†é‡ã¯æ•°å€¤ã®ã¿ï¼ˆ"100"ï¼‰ã€å˜ä½ã¯æ–‡å­—ã®ã¿ï¼ˆ"g"ï¼‰
3. å…¨è§’æ•°å­—ã¯åŠè§’ã«å¤‰æ›ã—ã¦ãã ã•ã„
4. æ—¥æœ¬èªå˜ä½ã‚‚æ­£ç¢ºã«æŠ½å‡ºï¼ˆå¤§ã•ã˜ã€å°ã•ã˜ã€ã‚«ãƒƒãƒ—ã€å€‹ã€æšã€æœ¬ï¼‰
5. é©é‡ã€å°‘ã€…ã€ãŠå¥½ã¿ãªã©ã¯åˆ†é‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å…¥ã‚Œã¦ãã ã•ã„
6. ä¾¡æ ¼æƒ…å ±ï¼ˆå††ï¼‰ãŒã‚ã‚Œã°åˆ¥é€”æŠ½å‡ºã—ã¦ãã ã•ã„

ã€é‡è¦ã€‘
- ææ–™ã¯å¿…ãšingredientsé…åˆ—ã«å«ã‚ã‚‹
- åˆ†é‡ã¨å˜ä½ã¯æ­£ç¢ºã«åˆ†é›¢ï¼ˆæœ€é‡è¦ï¼‰
- æ—¥æœ¬èªæ–‡å­—ã‚’ä¿è­·
- JSONã®ã¿å‡ºåŠ›ï¼ˆèª¬æ˜æ–‡ãªã—ï¼‰`;
      } else {
        // æµ·å¤–ã‚µã‚¤ãƒˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆè¨€èªåˆ¥å¯¾å¿œï¼‰
        const languageInstructions = {
          'fr': {
            language: 'French',
            keywords: 'recette, ingrÃ©dients, prÃ©paration',
            example: 'Exemple: "250g de farine" â†’ {"item": "farine", "quantity": "250", "unit": "g"}'
          },
          'it': {
            language: 'Italian', 
            keywords: 'ricetta, ingredienti, preparazione',
            example: 'Esempio: "250g di farina" â†’ {"item": "farina", "quantity": "250", "unit": "g"}'
          },
          'de': {
            language: 'German',
            keywords: 'rezept, zutaten, zubereitung', 
            example: 'Beispiel: "250g Mehl" â†’ {"item": "Mehl", "quantity": "250", "unit": "g"}'
          },
          'es': {
            language: 'Spanish',
            keywords: 'receta, ingredientes, preparaciÃ³n',
            example: 'Ejemplo: "250g de harina" â†’ {"item": "harina", "quantity": "250", "unit": "g"}'
          },
          'en': {
            language: 'English',
            keywords: 'recipe, ingredients, instructions',
            example: 'Example: "250g flour" â†’ {"item": "flour", "quantity": "250", "unit": "g"}'
          }
        };
        
        const langInfo = languageInstructions[siteLanguage.code] || languageInstructions['en'];
        
        return `You are a professional recipe extraction system specialized in ${langInfo.language} content. Extract recipe information from the following HTML content.

LANGUAGE SPECIFIC REQUIREMENTS:
- Detect and preserve ${langInfo.language} text accurately
- Look for keywords like: ${langInfo.keywords}
- Maintain original language in the extracted content
- Handle character encoding properly for ${langInfo.language}

Extract the following recipe information:
- Title (recipe name in original language)
- Description (recipe overview in original language)
- Servings (number of people)
- Ingredients list (separate name, quantity, unit)
- Instructions/steps (in original language)

Output format must be JSON with this structure:
{
  "title": "Recipe title in ${langInfo.language}",
  "description": "Recipe description in ${langInfo.language}",
  "servings": "Number of servings",
  "ingredients": [
    {
      "item": "ingredient name in ${langInfo.language}",
      "quantity": "amount",
      "unit": "unit in ${langInfo.language}"
    }
  ],
  "steps": [
    "Step 1 content in ${langInfo.language}",
    "Step 2 content in ${langInfo.language}"
  ]
}

INGREDIENT EXTRACTION EXAMPLES:
${langInfo.example}
- "250g flour" â†’ {"item": "flour", "quantity": "250", "unit": "g"}
- "2 tbsp olive oil" â†’ {"item": "olive oil", "quantity": "2", "unit": "tbsp"}
- "1 large onion" â†’ {"item": "onion", "quantity": "1", "unit": "large"}
- "Salt to taste" â†’ {"item": "salt", "quantity": "to taste", "unit": ""}

CRITICAL INGREDIENT PARSING RULES:
1. ALWAYS separate ingredient name, quantity, and unit into different fields
2. Quantity should be numbers only ("250", "2", "1")
3. Unit should be text only ("g", "tbsp", "large", "cup")
4. Handle fractions properly ("1/2" â†’ "0.5" or keep as "1/2")
5. Extract "to taste", "as needed" as quantity values
6. Preserve original ${langInfo.language} units and measurements

HTML Content:
${htmlContent.substring(0, 8000)}

IMPORTANT: 
- Return only valid JSON (no explanatory text)
- Preserve original ${langInfo.language} text
- Ensure proper character encoding
- Separate ingredients into item, quantity, and unit fields accurately (MOST IMPORTANT)`;
      }
    }

    // Recipe Keeper.appé¢¨ã®ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–é–¢æ•°
    function normalizeRecipeData(recipeData) {
      console.log('ğŸ”§ ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–é–‹å§‹');
      
      const normalized = {
        title: recipeData.title || 'ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜',
        description: recipeData.description || '',
        servings: recipeData.servings || '',
        ingredients: [],
        steps: [],
        notes: recipeData.notes || ''
      };
      
      // ææ–™ã®æ­£è¦åŒ–
      if (recipeData.ingredients && Array.isArray(recipeData.ingredients)) {
        normalized.ingredients = recipeData.ingredients.map(ingredient => {
          return normalizeIngredientObject(ingredient);
        });
      }
      
      // æ‰‹é †ã®æ­£è¦åŒ–
      if (recipeData.steps && Array.isArray(recipeData.steps)) {
        normalized.steps = recipeData.steps.map((step, index) => {
          if (typeof step === 'string') {
            return step;
          } else if (step && typeof step === 'object') {
            return step.instruction || step.step || step.text || `æ‰‹é †${index + 1}`;
          }
          return `æ‰‹é †${index + 1}`;
        });
      }
      
      console.log('âœ… ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–å®Œäº†:', normalized);
      return normalized;
    }

    // Recipe Keeper.appé¢¨ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è§£æé–¢æ•°
    function fallbackAnalysis(content, url) {
      console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è§£æã‚’é–‹å§‹');
      
      const lines = content.split('\n').filter(line => line.trim());
      const ingredients = [];
      const steps = [];
      let title = 'ãƒ¬ã‚·ãƒ”';
      let description = '';
      
      // ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¨æ¸¬
      for (const line of lines.slice(0, 10)) {
        if (line.length > 5 && line.length < 100 && !line.includes('{') && !line.includes('"')) {
          title = line.trim();
          break;
        }
      }
      
      // æ—¥æœ¬èªã‚µã‚¤ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤å®š
      const isJapanese = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com')
      ) || /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(content);
      
      // ææ–™ã‚‰ã—ã„è¡Œã‚’æ¤œå‡º
      for (const line of lines) {
        if (isIngredientLine(line, isJapanese)) {
          const ingredient = parseIngredientLine(line, isJapanese);
          if (ingredient) {
            ingredients.push(ingredient);
          }
        }
      }
      
      // æ‰‹é †ã‚‰ã—ã„è¡Œã‚’æ¤œå‡º
      for (const line of lines) {
        if (isStepLine(line, isJapanese)) {
          const step = cleanStepText(line);
          if (step) {
            steps.push(step);
          }
        }
      }
      
      const fallbackData = {
        title: title,
        description: description,
        servings: '',
        ingredients: ingredients,
        steps: steps,
        notes: 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è§£æã«ã‚ˆã‚Šç”Ÿæˆ'
      };
      
      console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è§£æå®Œäº†:', fallbackData);
      return fallbackData;
    }

    // ææ–™è¡Œã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆRecipe Keeper.appæº–æ‹ ï¼‰
    function isIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      // åŸºæœ¬çš„ãªé™¤å¤–æ¡ä»¶
      if (!trimmed || 
          trimmed.length < 2 || 
          trimmed.length > 150 ||
          trimmed.includes('ä½œã‚Šæ–¹') || 
          trimmed.includes('æ‰‹é †') ||
          trimmed.includes('Instructions') ||
          trimmed.includes('Method') ||
          trimmed.includes('Steps')) {
        return false;
      }
      
      if (isJapanese) {
        // æ—¥æœ¬èªã®ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆRecipe Keeper.appæº–æ‹ ï¼‰
        return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(trimmed) && 
               (
                 // æ•°å­—+æ—¥æœ¬èªå˜ä½
                 /\d+[gmlã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…]/.test(trimmed) ||
                 // å…¨è§’æ•°å­—+æ—¥æœ¬èªå˜ä½
                 /[ï¼-ï¼™]+[ï½‡ï½ï½Œã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…]/.test(trimmed) ||
                 // ã‚³ãƒ­ãƒ³åŒºåˆ‡ã‚Š
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[ï¼š:]\s*\d/.test(trimmed) ||
                 // ç‰¹æ®Šåˆ†é‡
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[ï¼š:]\s*(é©é‡|å°‘ã€…|ãŠå¥½ã¿|ã²ã¨ã¤ã¾ã¿|ã²ã¨æŒ¯ã‚Š)/.test(trimmed) ||
                 // ä¾¡æ ¼æƒ…å ±
                 /\d+å††/.test(trimmed)
               );
      } else {
        // è‹±èªã®ææ–™ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆRecipe Keeper.appæº–æ‹ ï¼‰
        return (
          // æ¨™æº–çš„ãªå˜ä½
          /\d+\s*(g|ml|cup|tbsp|tsp|oz|lb|kg|l|dl|cl)/.test(trimmed) ||
          // åˆ†æ•°
          /\d+\/\d+/.test(trimmed) ||
          // ã‚µã‚¤ã‚ºè¡¨ç¾
          /\d+\s+(large|medium|small|whole|piece|slice)/.test(trimmed) ||
          // ãƒ€ãƒƒã‚·ãƒ¥åŒºåˆ‡ã‚Š
          /\w+\s*[-â€“â€”]\s*\d+/.test(trimmed) ||
          // ã‚³ãƒ­ãƒ³åŒºåˆ‡ã‚Š
          /\w+\s*:\s*\d+/.test(trimmed) ||
          // ç‰¹æ®Šè¡¨ç¾
          /(to taste|as needed|pinch|dash)/.test(trimmed.toLowerCase())
        );
      }
    }

    // ææ–™è¡Œã‚’è§£æï¼ˆRecipe Keeper.appæœ€é©åŒ–ç‰ˆï¼‰
    function parseIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      console.log('ğŸ” ææ–™è¡Œè§£æ:', trimmed);
      
      if (isJapanese) {
        // æ—¥æœ¬èªææ–™ã®é«˜ç²¾åº¦è§£æï¼ˆRecipe Keeper.appæº–æ‹ ï¼‰
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: "ææ–™å åˆ†é‡å˜ä½ ä¾¡æ ¼å††"
        const pattern1 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s+(\d+)å††$/);
        if (pattern1) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1é©ç”¨: ææ–™å+åˆ†é‡å˜ä½+ä¾¡æ ¼');
          return {
            item: pattern1[1].trim(),
            quantity: pattern1[2].trim(),
            unit: pattern1[3].trim(),
            price: pattern1[4].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: "ææ–™å ä¾¡æ ¼å††"
        const pattern2 = trimmed.match(/^(.+?)\s+(\d+)å††$/);
        if (pattern2) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³2é©ç”¨: ææ–™å+ä¾¡æ ¼');
          return {
            item: pattern2[1].trim(),
            quantity: '',
            unit: '',
            price: pattern2[2].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: "ææ–™å åˆ†é‡å˜ä½"
        const pattern3 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/);
        if (pattern3) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³3é©ç”¨: ææ–™å+åˆ†é‡å˜ä½');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³4: "ææ–™å åˆ†é‡"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern4) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³4é©ç”¨: ææ–™å+åˆ†é‡');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: ''
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³5: "ææ–™åï¼šåˆ†é‡å˜ä½" (ã‚³ãƒ­ãƒ³åŒºåˆ‡ã‚Š)
        const pattern5 = trimmed.match(/^(.+?)\s*[ï¼š:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern5) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³5é©ç”¨: ææ–™åï¼šåˆ†é‡å˜ä½');
          return {
            item: pattern5[1].trim(),
            quantity: pattern5[2].trim(),
            unit: pattern5[3].trim() || ''
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³6: "ææ–™åï¼šåˆ†é‡" (ã‚³ãƒ­ãƒ³åŒºåˆ‡ã‚Šã€å˜ä½ãªã—)
        const pattern6 = trimmed.match(/^(.+?)\s*[ï¼š:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern6) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³6é©ç”¨: ææ–™åï¼šåˆ†é‡');
          return {
            item: pattern6[1].trim(),
            quantity: pattern6[2].trim(),
            unit: ''
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³7: "ææ–™åï¼šé©é‡ãƒ»å°‘ã€…" (ç‰¹æ®Šåˆ†é‡)
        const pattern7 = trimmed.match(/^(.+?)\s*[ï¼š:]\s*(é©é‡|å°‘ã€…|ãŠå¥½ã¿|ã²ã¨ã¤ã¾ã¿|ã²ã¨æŒ¯ã‚Š)$/);
        if (pattern7) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³7é©ç”¨: ææ–™åï¼šç‰¹æ®Šåˆ†é‡');
          return {
            item: pattern7[1].trim(),
            quantity: pattern7[2].trim(),
            unit: ''
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³8: å…¨è§’æ•°å­—å¯¾å¿œ
        const pattern8 = trimmed.match(/^(.+?)\s+([ï¼-ï¼™]+(?:\.[ï¼-ï¼™]+)?)\s*([a-zA-Zgmlã‚«ãƒƒãƒ—å¤§ã•ã˜å°ã•ã˜å€‹æšæœ¬è¢‹ç¼¶é©é‡å°‘ã€…\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern8) {
          console.log('âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³8é©ç”¨: å…¨è§’æ•°å­—');
          // å…¨è§’æ•°å­—ã‚’åŠè§’ã«å¤‰æ›
          const quantity = pattern8[2].replace(/[ï¼-ï¼™]/g, (match) => String.fromCharCode(match.charCodeAt(0) - 0xFEE0));
          return {
            item: pattern8[1].trim(),
            quantity: quantity,
            unit: pattern8[3].trim() || ''
          };
        }

      } else {
        // è‹±èªææ–™ã®é«˜ç²¾åº¦è§£æ
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: "quantity unit ingredient"
        const pattern1 = trimmed.match(/^(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)\s+(.+)$/);
        if (pattern1) {
          console.log('âœ… è‹±èªãƒ‘ã‚¿ãƒ¼ãƒ³1: quantity unit ingredient');
          return {
            item: pattern1[3].trim(),
            quantity: pattern1[1].trim(),
            unit: pattern1[2].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: "ingredient - quantity unit"
        const pattern2 = trimmed.match(/^(.+?)\s*[-â€“â€”]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern2) {
          console.log('âœ… è‹±èªãƒ‘ã‚¿ãƒ¼ãƒ³2: ingredient - quantity unit');
          return {
            item: pattern2[1].trim(),
            quantity: pattern2[2].trim(),
            unit: pattern2[3].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: "ingredient: quantity unit"
        const pattern3 = trimmed.match(/^(.+?)\s*:\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern3) {
          console.log('âœ… è‹±èªãƒ‘ã‚¿ãƒ¼ãƒ³3: ingredient: quantity unit');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³4: "ingredient quantity unit"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern4) {
          console.log('âœ… è‹±èªãƒ‘ã‚¿ãƒ¼ãƒ³4: ingredient quantity unit');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: pattern4[3].trim()
          };
        }
      }
      
      console.log('âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒå¤±æ•—');
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ææ–™åã®ã¿
      return {
        item: trimmed,
        quantity: '',
        unit: ''
      };
    }

    // æ‰‹é †è¡Œã‹ã©ã†ã‹ã‚’åˆ¤å®š
    function isStepLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      if (isJapanese) {
        return /^\d+[ï¼.]/.test(trimmed) ||
               /^[ï¼-ï¼™]+[ï¼.]/.test(trimmed) ||
               /^æ‰‹é †\s*\d+/.test(trimmed) ||
               /ä½œã‚Šæ–¹|æ‰‹é †|æ–¹æ³•/.test(trimmed);
      } else {
        return /^\d+\./.test(trimmed) ||
               /^step\s+\d+/i.test(trimmed) ||
               /^instruction/i.test(trimmed);
      }
    }

    // ä¿å­˜ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ¶å¾¡
    function showSaveButtons() {
      const saveSection = document.getElementById('saveSection');
      const translationSection = document.getElementById('translationSection');
      const saveModeBothLabel = document.getElementById('saveModeBothLabel');
      const saveModeTranslatedLabel = document.getElementById('saveModeTranslatedLabel');
      const saveModeHint = document.getElementById('saveModeHint');
      
      if (saveSection) {
        saveSection.style.display = 'block';
      }
      
      const hasTranslation = translationSection && translationSection.style.display !== 'none';
      if (saveModeBothLabel && saveModeTranslatedLabel) {
        // æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        const bothRadio = saveModeBothLabel.querySelector('input[type="radio"]');
        const transRadio = saveModeTranslatedLabel.querySelector('input[type="radio"]');
        if (hasTranslation) {
          saveModeBothLabel.style.opacity = '1';
          saveModeTranslatedLabel.style.opacity = '1';
          bothRadio.disabled = false;
          transRadio.disabled = false;
          if (saveModeHint) saveModeHint.textContent = 'ä¿å­˜ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ã€Œé¸æŠã—ã¦ä¿å­˜ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚';
        } else {
          saveModeBothLabel.style.opacity = '0.7';
          saveModeTranslatedLabel.style.opacity = '0.7';
          bothRadio.disabled = true;
          transRadio.disabled = true;
          if (saveModeHint) saveModeHint.textContent = 'ç¿»è¨³å¾Œã«ã€Œç¿»è¨³ã®ã¿ã€ã€ŒåŸèªï¼‹ç¿»è¨³ã€ãŒé¸ã¹ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚';
        }
      }
    }

    // ãƒ¬ã‚·ãƒ”ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹é–¢æ•°
    async function saveRecipeToDatabase(recipeData, isTranslated = false) {
      if (!sb) {
        alert('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        return;
      }

      try {
        console.log('ä¿å­˜ã™ã‚‹ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿:', recipeData);
        
        // ãƒ¬ã‚·ãƒ”æœ¬ä½“ã‚’ä¿å­˜
        // servingsã‚’é©åˆ‡ãªæ•°å€¤ã«å¤‰æ›
        let servingsValue = null;
        if (recipeData.servings) {
          const parsed = parseInt(recipeData.servings);
          if (!isNaN(parsed)) {
            servingsValue = parsed;
          }
        }
        
        const { data: savedRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: recipeData.title || 'ç„¡é¡Œã®ãƒ¬ã‚·ãƒ”',
            description: recipeData.description || null,
            servings: servingsValue,
            category: recipeData.category || 'ãã®ä»–',
            tags: recipeData.tags || ['URLå–ã‚Šè¾¼ã¿'],
            notes: recipeData.notes || null,
            source_url: recipeData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('ãƒ¬ã‚·ãƒ”ä¿å­˜ã‚¨ãƒ©ãƒ¼:', recipeError);
          throw new Error(`ãƒ¬ã‚·ãƒ”ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${recipeError.message}`);
        }

        const recipeId = savedRecipe.id;
        console.log('ä¿å­˜ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ID:', recipeId, 'ã‚¿ã‚¤ãƒ—:', typeof recipeId);
        console.log('ãƒ¬ã‚·ãƒ”ä¿å­˜æˆåŠŸ:', recipeId);

        // ææ–™ã‚’ä¿å­˜
        if (recipeData.ingredients && recipeData.ingredients.length > 0) {
          const ingredientsToSave = recipeData.ingredients.map((ing, index) => {
            console.log(`ææ–™ ${index + 1}:`, {
              item: ing.item || ing.name,
              quantity: ing.quantity,
              unit: ing.unit,
              original: ing
            });
            
            return {
              recipe_id: recipeId,
              position: index + 1,
              item: ing.item || ing.name || '',
              quantity: ing.quantity || null,
              unit: ing.unit || null,
              price: null
            };
          });

          console.log('ä¿å­˜ã™ã‚‹ææ–™ãƒ‡ãƒ¼ã‚¿:', ingredientsToSave);

          const { error: ingredientsError } = await sb
            .from('recipe_ingredients')
            .insert(ingredientsToSave);

          if (ingredientsError) {
            console.error('ææ–™ä¿å­˜ã‚¨ãƒ©ãƒ¼:', ingredientsError);
          } else {
            console.log('âœ… ææ–™ä¿å­˜æˆåŠŸ');
          }
        }

        // æ‰‹é †ã‚’ä¿å­˜
        if (recipeData.steps && recipeData.steps.length > 0) {
          const stepsToSave = recipeData.steps.map((step, index) => ({
            recipe_id: recipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));

          const { error: stepsError } = await sb
            .from('recipe_steps')
            .insert(stepsToSave);

          if (stepsError) {
            console.error('æ‰‹é †ä¿å­˜ã‚¨ãƒ©ãƒ¼:', stepsError);
          }
        }

        alert('âœ… ãƒ¬ã‚·ãƒ”ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸï¼\n\nãƒ¬ã‚·ãƒ”è©³ç´°ãƒšãƒ¼ã‚¸ã§ç¢ºèªã§ãã¾ã™ã€‚');
        
        // ãƒ¬ã‚·ãƒ”è©³ç´°ãƒšãƒ¼ã‚¸ã¸ã®ãƒªãƒ³ã‚¯ã‚’è¡¨ç¤º
        if (confirm('ä¿å­˜ã—ãŸãƒ¬ã‚·ãƒ”ã‚’è¦‹ã¾ã™ã‹ï¼Ÿ')) {
          window.location.href = `recipe_detail.html?id=${recipeId}`;
        } else if (confirm('ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ')) {
          window.location.href = '../index.html';
        }

      } catch (error) {
        console.error('ä¿å­˜å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        alert('âŒ ãƒ¬ã‚·ãƒ”ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
      }
    }

    // ä¿å­˜ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    document.getElementById('saveByModeButton')?.addEventListener('click', async () => {
      const mode = (document.querySelector('input[name="saveMode"]:checked')?.value) || 'original';
      const urlInput = document.getElementById('urlInput');
      
      if (mode === 'original') {
        if (!currentRecipeData) {
          alert('ä¿å­˜ã™ã‚‹ãƒ¬ã‚·ãƒ”ãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        const saveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URLå–ã‚Šè¾¼ã¿']
        };
        await saveRecipeToDatabase(saveData, false);
        return;
      }

      // ç¿»è¨³ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
      const translatedTitle = document.getElementById('translatedRecipeTitle')?.textContent;
      const translatedDescription = document.getElementById('translatedRecipeDescription')?.textContent;
      const translatedServings = document.getElementById('translatedRecipeServings')?.textContent;
      
      if (!translatedTitle || translatedTitle === '-') {
        alert('ç¿»è¨³çµæœãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }
      
      // ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã®ç¿»è¨³ææ–™ã‚’æŠ½å‡º
      const translatedIngredientsRaw = extractTranslatedIngredients();
      const translatedIngredients = ensureIngredientSectionTitles(currentRecipeData?.ingredients, translatedIngredientsRaw);
      const translatedSteps = extractTranslatedSteps();

      const translatedSaveData = {
        title: translatedTitle,
        description: translatedDescription !== '-' ? translatedDescription : '',
        servings: translatedServings !== '-' ? translatedServings : '',
        ingredients: translatedIngredients,
        steps: translatedSteps,
        source_url: urlInput ? urlInput.value : '',
        tags: ['ç¿»è¨³', 'URLå–ã‚Šè¾¼ã¿'],
        category: 'ç¿»è¨³'
      };

      if (mode === 'translated') {
        await saveRecipeToDatabase(translatedSaveData, true);
        return;
      }

      if (mode === 'both') {
        // 1) å…ƒã®ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜ï¼ˆæ‰‹å‹•ã§IDã‚’å–å¾—ï¼‰
        const originalSaveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URLå–ã‚Šè¾¼ã¿', 'ç¿»è¨³å…ƒ']
        };

        // servingsã‚’æ•°å€¤åŒ–
        let servingsValue = null;
        if (originalSaveData.servings) {
          const parsed = parseInt(originalSaveData.servings);
          if (!isNaN(parsed)) servingsValue = parsed;
        }

        const { data: savedOriginalRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: originalSaveData.title || 'ç„¡é¡Œã®ãƒ¬ã‚·ãƒ”',
            description: originalSaveData.description || null,
            servings: servingsValue,
            category: originalSaveData.category || 'ãã®ä»–',
            tags: originalSaveData.tags || ['URLå–ã‚Šè¾¼ã¿'],
            notes: originalSaveData.notes || null,
            source_url: originalSaveData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('å…ƒã®ãƒ¬ã‚·ãƒ”ä¿å­˜ã‚¨ãƒ©ãƒ¼:', recipeError);
          throw new Error(`å…ƒã®ãƒ¬ã‚·ãƒ”ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${recipeError.message}`);
        }

        const originalRecipeId = savedOriginalRecipe.id;

        // ææ–™
        if (originalSaveData.ingredients && originalSaveData.ingredients.length > 0) {
          const ingredientsToSave = originalSaveData.ingredients.map((ing, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            item: ing.item || ing.name || '',
            quantity: ing.quantity || null,
            unit: ing.unit || null,
            price: null
          }));
          const { error: ingredientsError } = await sb.from('recipe_ingredients').insert(ingredientsToSave);
          if (ingredientsError) console.error('ææ–™ä¿å­˜ã‚¨ãƒ©ãƒ¼:', ingredientsError);
        }

        // æ‰‹é †
        if (originalSaveData.steps && originalSaveData.steps.length > 0) {
          const stepsToSave = originalSaveData.steps.map((step, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));
          const { error: stepsError } = await sb.from('recipe_steps').insert(stepsToSave);
          if (stepsError) console.error('æ‰‹é †ä¿å­˜ã‚¨ãƒ©ãƒ¼:', stepsError);
        }

        // 2) ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’translation_*ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const languageCode = targetLanguageSelect ? targetLanguageSelect.value : DEFAULT_TRANSLATION_LANGUAGE;
        const translationRecipeId = await saveTranslationRecipe(
          originalRecipeId,
          originalSaveData,
          {
            ...translatedSaveData,
            ingredients: ensureIngredientSectionTitles(originalSaveData.ingredients, translatedSaveData.ingredients)
          },
          languageCode
        );

        alert('âœ… å…ƒã®ãƒ¬ã‚·ãƒ”ã¨ç¿»è¨³ãƒ¬ã‚·ãƒ”ã®ä¸¡æ–¹ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸ');
        if (confirm('å…ƒã®ãƒ¬ã‚·ãƒ”ã‚’è¡¨ç¤ºã—ã¾ã™ã‹ï¼Ÿ')) {
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
        }
        return;
      }
    });

    // ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’translation_recipesãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜ã™ã‚‹é–¢æ•°
    async function saveTranslationRecipe(originalRecipeId, originalData, translatedData, languageCode) {
      if (!sb) {
        alert('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        return null;
      }

      try {
        console.log('ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜ä¸­...', { originalRecipeId, languageCode });

        // ç¿»è¨³ãƒ¬ã‚·ãƒ”æœ¬ä½“ã‚’ä¿å­˜
        const { data: savedTranslation, error: translationError } = await sb
          .from('translation_recipes')
          .insert({
            original_recipe_id: originalRecipeId,
            original_title: originalData.title || 'ç„¡é¡Œã®ãƒ¬ã‚·ãƒ”',
            translated_title: translatedData.title || 'ç„¡é¡Œã®ãƒ¬ã‚·ãƒ”',
            original_description: originalData.description || null,
            translated_description: translatedData.description || null,
            servings: translatedData.servings ? parseInt(translatedData.servings) : null,
            language_code: languageCode,
            category: 'ç¿»è¨³ãƒ¬ã‚·ãƒ”',
            tags: ['ç¿»è¨³', 'å¤šè¨€èª', 'URLå–ã‚Šè¾¼ã¿']
          })
          .select()
          .single();

        if (translationError) {
          console.error('ç¿»è¨³ãƒ¬ã‚·ãƒ”ä¿å­˜ã‚¨ãƒ©ãƒ¼:', translationError);
          throw new Error(`ç¿»è¨³ãƒ¬ã‚·ãƒ”ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${translationError.message}`);
        }

        const translationRecipeId = savedTranslation.id;
        console.log('ç¿»è¨³ãƒ¬ã‚·ãƒ”ä¿å­˜æˆåŠŸ:', translationRecipeId);

        // ç¿»è¨³ã•ã‚ŒãŸææ–™ã‚’ä¿å­˜
        if (translatedData.ingredients && translatedData.ingredients.length > 0) {
          const translatedIngredientsToSave = translatedData.ingredients.map((ing, index) => {
            const originalIng = originalData.ingredients?.[index] || {};
            return {
              translation_recipe_id: translationRecipeId,
              position: index + 1,
              original_item: originalIng.item || originalIng.name || null,
              translated_item: ing.item || ing.name || null,
              quantity: ing.quantity || null,
              unit: ing.unit || null,
              price: null
            };
          });

          const { error: ingredientsError } = await sb
            .from('translation_recipe_ingredients')
            .insert(translatedIngredientsToSave);

          if (ingredientsError) {
            console.error('ç¿»è¨³ææ–™ä¿å­˜ã‚¨ãƒ©ãƒ¼:', ingredientsError);
          } else {
            console.log('âœ… ç¿»è¨³ææ–™ä¿å­˜æˆåŠŸ');
          }
        }

        // ç¿»è¨³ã•ã‚ŒãŸæ‰‹é †ã‚’ä¿å­˜
        if (translatedData.steps && translatedData.steps.length > 0) {
          const translatedStepsToSave = translatedData.steps.map((step, index) => {
            const originalStep = originalData.steps?.[index] || '';
            const translatedInstruction = typeof step === 'string' ? step : step.instruction || step.text || '';
            const originalInstruction = typeof originalStep === 'string' ? originalStep : originalStep.instruction || originalStep.text || '';

            return {
              translation_recipe_id: translationRecipeId,
              position: index + 1,
              original_instruction: originalInstruction || null,
              translated_instruction: translatedInstruction || null
            };
          });

          const { error: stepsError } = await sb
            .from('translation_recipe_steps')
            .insert(translatedStepsToSave);

          if (stepsError) {
            console.error('ç¿»è¨³æ‰‹é †ä¿å­˜ã‚¨ãƒ©ãƒ¼:', stepsError);
          } else {
            console.log('âœ… ç¿»è¨³æ‰‹é †ä¿å­˜æˆåŠŸ');
          }
        }

        return translationRecipeId;

      } catch (error) {
        console.error('ç¿»è¨³ãƒ¬ã‚·ãƒ”ä¿å­˜å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        throw error;
      }
    }

    // ã€Œä¸¡æ–¹ã‚’ä¿å­˜ã€ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    document.getElementById('saveBothButton')?.addEventListener('click', async () => {
      if (!currentRecipeData) {
        alert('ä¿å­˜ã™ã‚‹ãƒ¬ã‚·ãƒ”ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }

      try {
        // 1. ã¾ãšå…ƒã®ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜
        const urlInput = document.getElementById('urlInput');
        const originalSaveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URLå–ã‚Šè¾¼ã¿', 'ç¿»è¨³å…ƒ']
        };

        console.log('ã‚¹ãƒ†ãƒƒãƒ—1: å…ƒã®ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜ä¸­...');
        
        // servingsã‚’é©åˆ‡ãªæ•°å€¤ã«å¤‰æ›
        let servingsValue = null;
        if (originalSaveData.servings) {
          const parsed = parseInt(originalSaveData.servings);
          if (!isNaN(parsed)) {
            servingsValue = parsed;
          }
        }
        
        const { data: savedOriginalRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: originalSaveData.title || 'ç„¡é¡Œã®ãƒ¬ã‚·ãƒ”',
            description: originalSaveData.description || null,
            servings: servingsValue,
            category: originalSaveData.category || 'ãã®ä»–',
            tags: originalSaveData.tags || ['URLå–ã‚Šè¾¼ã¿'],
            notes: originalSaveData.notes || null,
            source_url: originalSaveData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('å…ƒã®ãƒ¬ã‚·ãƒ”ä¿å­˜ã‚¨ãƒ©ãƒ¼:', recipeError);
          throw new Error(`å…ƒã®ãƒ¬ã‚·ãƒ”ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${recipeError.message}`);
        }

        const originalRecipeId = savedOriginalRecipe.id;
        console.log('âœ… å…ƒã®ãƒ¬ã‚·ãƒ”ä¿å­˜æˆåŠŸ:', originalRecipeId);

        // ææ–™ã‚’ä¿å­˜
        if (originalSaveData.ingredients && originalSaveData.ingredients.length > 0) {
          const ingredientsToSave = originalSaveData.ingredients.map((ing, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            item: ing.item || ing.name || '',
            quantity: ing.quantity || null,
            unit: ing.unit || null,
            price: null
          }));

          const { error: ingredientsError } = await sb
            .from('recipe_ingredients')
            .insert(ingredientsToSave);

          if (ingredientsError) {
            console.error('ææ–™ä¿å­˜ã‚¨ãƒ©ãƒ¼:', ingredientsError);
          }
        }

        // æ‰‹é †ã‚’ä¿å­˜
        if (originalSaveData.steps && originalSaveData.steps.length > 0) {
          const stepsToSave = originalSaveData.steps.map((step, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));

          const { error: stepsError } = await sb
            .from('recipe_steps')
            .insert(stepsToSave);

          if (stepsError) {
            console.error('æ‰‹é †ä¿å­˜ã‚¨ãƒ©ãƒ¼:', stepsError);
          }
        }

        // 2. ç¿»è¨³ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ã‚’å–å¾—
        console.log('ã‚¹ãƒ†ãƒƒãƒ—2: ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’å–å¾—ä¸­...');
        
        const translatedTitle = document.getElementById('translatedRecipeTitle')?.textContent;
        const translatedDescription = document.getElementById('translatedRecipeDescription')?.textContent;
        const translatedServings = document.getElementById('translatedRecipeServings')?.textContent;
        
        if (!translatedTitle || translatedTitle === '-') {
          alert('ç¿»è¨³ãƒ¬ã‚·ãƒ”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å…ƒã®ãƒ¬ã‚·ãƒ”ã®ã¿ä¿å­˜ã—ã¾ã—ãŸã€‚');
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
          return;
        }

        // ç¿»è¨³ã•ã‚ŒãŸææ–™ã‚’å–å¾—
        // ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã®ç¿»è¨³ææ–™ã‚’æŠ½å‡º
        const translatedIngredients = extractTranslatedIngredients();
        const translatedSteps = extractTranslatedSteps();

        const translatedSaveData = {
          title: translatedTitle,
          description: translatedDescription !== '-' ? translatedDescription : '',
          servings: translatedServings !== '-' ? translatedServings : '',
          ingredients: translatedIngredients,
          steps: translatedSteps
        };

        // 3. ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜
        console.log('ã‚¹ãƒ†ãƒƒãƒ—3: ç¿»è¨³ãƒ¬ã‚·ãƒ”ã‚’ä¿å­˜ä¸­...');
        
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const languageCode = targetLanguageSelect ? targetLanguageSelect.value : DEFAULT_TRANSLATION_LANGUAGE;
        
        const translationRecipeId = await saveTranslationRecipe(
          originalRecipeId,
          originalSaveData,
          {
            ...translatedSaveData,
            ingredients: ensureIngredientSectionTitles(originalSaveData.ingredients, translatedSaveData.ingredients)
          },
          languageCode
        );

        console.log('âœ… ç¿»è¨³ãƒ¬ã‚·ãƒ”ä¿å­˜æˆåŠŸ:', translationRecipeId);

        // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        alert('âœ… å…ƒã®ãƒ¬ã‚·ãƒ”ã¨ç¿»è¨³ãƒ¬ã‚·ãƒ”ã®ä¸¡æ–¹ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸï¼\n\nå…ƒã®ãƒ¬ã‚·ãƒ”ID: ' + originalRecipeId + '\nç¿»è¨³ãƒ¬ã‚·ãƒ”ID: ' + translationRecipeId);
        
        // å…ƒã®ãƒ¬ã‚·ãƒ”è©³ç´°ãƒšãƒ¼ã‚¸ã¸ç§»å‹•
        if (confirm('å…ƒã®ãƒ¬ã‚·ãƒ”ã‚’è¦‹ã¾ã™ã‹ï¼Ÿ')) {
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
        } else if (confirm('ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ')) {
          window.location.href = '../index.html';
        }

      } catch (error) {
        console.error('ä¸¡æ–¹ä¿å­˜å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        alert('âŒ ãƒ¬ã‚·ãƒ”ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
      }
    });

  </script>
  <script>
    // å…ƒãƒšãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ¶å¾¡
    (function() {
      const urlInput = document.getElementById('urlInput');
      const previewUrl = document.getElementById('sourcePreviewUrl');
      const btn = document.getElementById('loadSourcePreviewBtn');
      const pane = document.getElementById('sourcePreviewPane');
      const frame = document.getElementById('sourcePreviewFrame');
      const info = document.getElementById('sourcePreviewInfo');
      const dockRight = document.getElementById('dockPreviewRight');
      const split = document.getElementById('sourcePreviewSplit');

      if (!btn || !frame) return;

      // URLãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰é€£å‹•
      if (urlInput && previewUrl) {
        previewUrl.value = urlInput.value || '';
        urlInput.addEventListener('change', () => { previewUrl.value = urlInput.value; });
      }

      btn.addEventListener('click', async () => {
        try {
          const url = (previewUrl.value || urlInput.value || '').trim();
          if (!url) { alert('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
          pane.style.display = 'block';
          info.textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';

          // ç›´æ¥åŸ‹ã‚è¾¼ã¿ã‚’ã¾ãšè©¦ã™ï¼ˆå¤±æ•—ã—ã¦ã‚‚catchã—ãªã„ï¼‰
          try {
            frame.removeAttribute('srcdoc');
            frame.src = url;
            // 2ç§’å¾Œã«è¦‹ãˆãªã‘ã‚Œã°ãƒ—ãƒ­ã‚­ã‚·ã¸åˆ‡æ›¿
            setTimeout(async () => {
              const blankLike = !frame.contentWindow || !frame.contentDocument || frame.contentDocument.body.children.length === 0;
              if (blankLike) {
                const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
                // å®‰å…¨ã®ãŸã‚ <script> ã‚’é™¤å»ã—ã€<base> ã‚’ä»˜ä¸ã—ã¦ç›¸å¯¾ãƒ‘ã‚¹ã‚’è§£æ±º
                const sanitized = String(raw)
                  .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                  .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
                  .replace(/on\w+\s*=\s*'[^']*'/gi, '')
                  .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
                const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
                const adCss = `<style>
                  [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
                  header nav, footer { display:none !important; }
                  body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
                </style>`;
                const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
                const blob = new Blob([wrapped], { type: 'text/html' });
                const objectUrl = URL.createObjectURL(blob);
                frame.src = objectUrl;
                info.textContent = 'ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§è¡¨ç¤ºï¼ˆblobï¼‰';
              } else {
                info.textContent = 'ç›´æ¥è¡¨ç¤º';
              }
            }, 2000);
          } catch (_) {
            const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
            const sanitized = String(raw)
              .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
              .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
              .replace(/on\w+\s*=\s*'[^']*'/gi, '')
              .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
            const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
            const adCss = `<style>
              [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
              header nav, footer { display:none !important; }
              body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
            </style>`;
            const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
            const blob = new Blob([wrapped], { type: 'text/html' });
            const objectUrl = URL.createObjectURL(blob);
            frame.src = objectUrl;
            info.textContent = 'ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§è¡¨ç¤ºï¼ˆblobï¼‰';
          }
        } catch (e) {
          console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
          alert('å…ƒãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
          info.textContent = 'èª­ã¿è¾¼ã¿å¤±æ•—';
        }
      });

      dockRight.addEventListener('change', () => {
        // å³ã«ãƒ‰ãƒƒã‚¯: iframe 50% + å³å´ã«ç·¨é›†ï¼ˆæ—¢å­˜UIï¼‰ã‚’æƒ³å®š â†’ ã“ã“ã§ã¯å·¦å³åˆ†å‰²ã®æ–¹å‘ã ã‘å¤‰æ›´
        split.style.flexDirection = dockRight.checked ? 'row' : 'column';
        frame.style.width = dockRight.checked ? '50%' : '100%';
      });

      // åˆ†é›¢ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºæ©Ÿèƒ½ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã«ã‚ˆã‚Šç„¡åŠ¹åŒ–ï¼ˆå¾“æ¥è¡¨ç¤ºï¼‰
    })();
  </script>
  <script>
    // å…ƒè¨€èªã®ææ–™ãƒªã‚¹ãƒˆã‚’ãã®å ´ç·¨é›†ï¼ˆãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†ï¼‰
    function enableInlineIngredientEditing(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      if (container.__inlineEditBound) return; // é‡è¤‡ãƒã‚¤ãƒ³ãƒ‰é˜²æ­¢
      container.__inlineEditBound = true;
      const commit = (grid, newName, newQty, newUnit, writeDom = false) => {
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        if (writeDom) {
          nameDiv.textContent = newName;
          qtyDiv.textContent = newQty;
          unitDiv.textContent = newUnit;
        }
        if (window.currentRecipeData?.ingredients) {
          // data-ing-index ãŒã‚ã‚Œã°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§æ›´æ–°ã€ãªã‘ã‚Œã°åå‰ä¸€è‡´
          const idxAttr = grid.getAttribute('data-ing-index');
          let target = null;
          if (idxAttr && window.currentRecipeData.ingredients[parseInt(idxAttr)]) {
            target = window.currentRecipeData.ingredients[parseInt(idxAttr)];
          } else {
            const currentName = (newName || '').trim();
            const idx = window.currentRecipeData.ingredients.findIndex(ing => (ing.item || ing.name || '').trim() === currentName);
            target = idx >= 0 ? window.currentRecipeData.ingredients[idx] : null;
          }
          if (target) {
            target.item = newName; target.name = newName; target.quantity = newQty; target.unit = newUnit;
          }
        }
      };

      // contentEditableã®å¤‰æ›´ã‚’ãƒ–ãƒ©ãƒ¼æ™‚ã«åæ˜ 
      container.addEventListener('focusout', (e) => {
        const grid = e.target.closest('.recipe-ingredients-grid');
        if (!grid) return;
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        commit(grid, nameDiv.textContent.trim(), qtyDiv.textContent.trim(), unitDiv.textContent.trim(), true);
      });

      // å…¥åŠ›ä¸­ã‚‚ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆè»½é‡ï¼‰
      container.addEventListener('input', (e) => {
        const grid = e.target.closest('.recipe-ingredients-grid');
        if (!grid) return;
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        // å…¥åŠ›ä¸­ã¯DOMã‚’æ›¸ãæ›ãˆãšã€ãƒ‡ãƒ¼ã‚¿ã®ã¿æ›´æ–°ï¼ˆIMEã®ç¢ºå®šä¸­ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒé£›ã¶ã®ã‚’é˜²æ­¢ï¼‰
        commit(grid, nameDiv.textContent.trim(), qtyDiv.textContent.trim(), unitDiv.textContent.trim(), false);
      });
    }

    // å…ƒè¨€èªã®æ‰‹é †ãƒªã‚¹ãƒˆã‚’ãã®å ´ç·¨é›†
    function enableInlineStepsEditing(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      if (container.__inlineStepBound) return;
      container.__inlineStepBound = true;

      const sync = (el, writeDom = false) => {
        const idxAttr = el.getAttribute('data-step-index');
        if (!idxAttr) return;
        const idx = parseInt(idxAttr);
        let text = (el.textContent || '').trim();
        // å…ˆé ­ã®é€£ç•ªã€ŒN. ã€ã‚’å–ã‚Šé™¤ã„ã¦ä¸­èº«ã ã‘ä¿å­˜
        text = text.replace(/^\d+\.?\s*/, '');
        if (!Array.isArray(window.currentRecipeData?.steps)) return;
        const original = window.currentRecipeData.steps[idx];
        if (typeof original === 'object') {
          window.currentRecipeData.steps[idx].step = text;
          window.currentRecipeData.steps[idx].instruction = text;
          window.currentRecipeData.steps[idx].text = text;
        } else {
          window.currentRecipeData.steps[idx] = text;
        }
        if (writeDom) {
          // è¡¨ç¤ºã®é€£ç•ªã¯ç¶­æŒï¼ˆå†æ•´å½¢ï¼‰
          el.textContent = `${idx + 1}. ${text}`;
        }
      };

      container.addEventListener('input', (e) => {
        const el = e.target.closest('.step-item');
        if (!el) return;
        // å…¥åŠ›ä¸­ã¯DOMã‚’æ›¸ãæ›ãˆãšãƒ‡ãƒ¼ã‚¿ã®ã¿æ›´æ–°
        sync(el, false);
      });

      container.addEventListener('focusout', (e) => {
        const el = e.target.closest('.step-item');
        if (!el) return;
        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆã§è¡¨ç¤ºã‚’æ•´å½¢
        sync(el, true);
      });
    }

    // åŸèªï¼šã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†ã®è¿½åŠ /é©ç”¨
    function addInlineIngredientRow() {
      const container = document.getElementById('flexibleIngredientsDisplay');
      if (!container) return;
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      gridDiv.setAttribute('data-ing-index', String(window.currentRecipeData?.ingredients?.length || 0));
      const nameDiv = document.createElement('div');
      nameDiv.className = 'ingredient-name';
      nameDiv.contentEditable = 'true';
      nameDiv.spellcheck = false;
      nameDiv.textContent = '';
      const qtyDiv = document.createElement('div');
      qtyDiv.className = 'ingredient-quantity';
      qtyDiv.contentEditable = 'true';
      qtyDiv.spellcheck = false;
      qtyDiv.textContent = '';
      const unitDiv = document.createElement('div');
      unitDiv.className = 'ingredient-unit';
      unitDiv.contentEditable = 'true';
      unitDiv.spellcheck = false;
      unitDiv.textContent = '';
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      container.appendChild(gridDiv);
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      window.currentRecipeData.ingredients.push({ item: '', quantity: '', unit: '' });
    }

    // æŒ‡å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ææ–™è¡Œã‚’è¿½åŠ 
    function addIngredientRowToSection(sectionDiv) {
      if (!sectionDiv) return;
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      const nameDiv = document.createElement('div');
      nameDiv.className = 'ingredient-name';
      nameDiv.contentEditable = 'true';
      nameDiv.spellcheck = false;
      const qtyDiv = document.createElement('div');
      qtyDiv.className = 'ingredient-quantity';
      qtyDiv.contentEditable = 'true';
      qtyDiv.spellcheck = false;
      const unitDiv = document.createElement('div');
      unitDiv.className = 'ingredient-unit';
      unitDiv.contentEditable = 'true';
      unitDiv.spellcheck = false;
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®è¿½åŠ ãƒœã‚¿ãƒ³ã®ç›´å‰ã«æŒ¿å…¥
      const actions = sectionDiv.querySelector('.inline-actions:last-of-type');
      if (actions) {
        sectionDiv.insertBefore(gridDiv, actions);
      } else {
        sectionDiv.appendChild(gridDiv);
      }
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      // sectionTitleã‚’ä»˜ä¸ã—ã¦ä¿å­˜ï¼ˆç¿»è¨³/å†æç”»ã§ã‚«ãƒ†ã‚´ãƒªç¶­æŒï¼‰
      const sectionTitle = sectionDiv.getAttribute('data-section-title') || sectionDiv.querySelector('.recipe-section-title')?.textContent || '';
      window.currentRecipeData.ingredients.push({ item: '', quantity: '', unit: '', sectionTitle });
    }

    function addInlineStepRow() {
      const stepsList = document.getElementById('stepsList');
      if (!stepsList) return;
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.steps)) window.currentRecipeData.steps = [];
      const idx = window.currentRecipeData.steps.length;
      window.currentRecipeData.steps.push('');
      const item = document.createElement('div');
      item.className = 'step-item';
      item.setAttribute('data-step-index', String(idx));
      item.contentEditable = 'true';
      item.spellcheck = false;
      item.textContent = `${idx + 1}. `;
      stepsList.appendChild(item);
    }

    function addInlineCategoryBlock() {
      const container = document.getElementById('flexibleIngredientsDisplay');
      if (!container) return;
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒˆãƒ«
      const sectionDiv = document.createElement('div');
      sectionDiv.className = 'recipe-section';
      const titleDiv = document.createElement('div');
      titleDiv.className = 'recipe-section-title';
      titleDiv.contentEditable = 'true';
      titleDiv.spellcheck = false;
      titleDiv.textContent = 'æ–°ã—ã„ã‚«ãƒ†ã‚´ãƒª';
      sectionDiv.setAttribute('data-section-title', titleDiv.textContent.trim());
      titleDiv.addEventListener('input', () => {
        sectionDiv.setAttribute('data-section-title', titleDiv.textContent.trim());
      });
      sectionDiv.appendChild(titleDiv);
      // ç©ºã®ææ–™1è¡Œ
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      const nameDiv = document.createElement('div'); nameDiv.className = 'ingredient-name'; nameDiv.contentEditable = 'true';
      const qtyDiv = document.createElement('div'); qtyDiv.className = 'ingredient-quantity'; qtyDiv.contentEditable = 'true';
      const unitDiv = document.createElement('div'); unitDiv.className = 'ingredient-unit'; unitDiv.contentEditable = 'true';
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      sectionDiv.appendChild(gridDiv);
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å°‚ç”¨ è¿½åŠ ãƒœã‚¿ãƒ³
      const actions = document.createElement('div');
      actions.className = 'inline-actions';
      actions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'btn secondary';
      addBtn.textContent = 'ææ–™ã‚’è¿½åŠ ';
      addBtn.addEventListener('click', () => addIngredientRowToSection(sectionDiv));
      actions.appendChild(addBtn);
      sectionDiv.appendChild(actions);
      container.appendChild(sectionDiv);

      // ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã«åæ˜ ï¼ˆã‚«ãƒ†ã‚´ãƒªæ¦‚å¿µãŒãªã„ãŸã‚ã€ãƒ•ãƒ©ãƒƒãƒˆé…åˆ—æœ«å°¾ã«ç©ºè¡Œã‚’è¿½åŠ ã™ã‚‹ã®ã¿ï¼‰
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      window.currentRecipeData.ingredients.push({
        item: '',
        quantity: '',
        unit: '',
        sectionTitle: titleDiv.textContent.trim()
      });
    }

    function syncCurrentRecipeFromDOM(options = {}) {
      const { showAlert = true } = options;
      if (!currentRecipeData) {
        if (showAlert) alert('å…ƒã¨ãªã‚‹ãƒ¬ã‚·ãƒ”ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }

      // DOMã‹ã‚‰ç¾åœ¨ã®å€¤ã‚’èª­ã¿å–ã‚‹
      currentRecipeData.title = document.getElementById('recipeTitle')?.textContent?.trim() || currentRecipeData.title;
      currentRecipeData.description = document.getElementById('recipeDescription')?.textContent?.trim() || currentRecipeData.description;
      currentRecipeData.servings = document.getElementById('recipeServings')?.textContent?.trim() || currentRecipeData.servings;

      const imageUrlInput = document.getElementById('recipeImageUrlInput');
      if (imageUrlInput) {
          const imageUrl = imageUrlInput.value.trim();
          if (imageUrl) {
              currentRecipeData.image_url = imageUrl;
          } else {
              delete currentRecipeData.image_url;
          }
      }

      // ææ–™ã®åŒæœŸ
      const ingredientsContainer = document.getElementById('flexibleIngredientsDisplay');
      const newIngredients = [];
      
      // æ–°ã—ã„ã‚«ãƒ†ã‚´ãƒªå½¢å¼ (.recipe-section) ã‹ã‚‰ææ–™ã‚’æŠ½å‡º
      const sections = ingredientsContainer.querySelectorAll('.recipe-section');
      if (sections.length > 0) {
        sections.forEach(section => {
          const sectionTitleEl = section.querySelector('.recipe-section-title');
          const sectionTitle = sectionTitleEl ? sectionTitleEl.textContent.trim() : '';
          
          const ingredientGrids = section.querySelectorAll('.recipe-ingredients-grid');
          ingredientGrids.forEach(grid => {
            const nameEl = grid.querySelector('.ingredient-name');
            const quantityEl = grid.querySelector('.ingredient-quantity');
            const unitEl = grid.querySelector('.ingredient-unit');
            
            if (nameEl) {
              newIngredients.push({
                item: nameEl.textContent.trim(),
                quantity: quantityEl ? quantityEl.textContent.trim() : '',
                unit: unitEl ? unitEl.textContent.trim() : '',
                sectionTitle: sectionTitle
              });
            }
          });
        });
      } else {
        // å¤ã„ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã‹ã‚‰ææ–™ã‚’æŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        const ingredientRows = ingredientsContainer.querySelectorAll('table tbody tr');
        if (ingredientRows.length > 0) {
          Array.from(ingredientRows).map(row => {
            const nameEl = row.querySelector('[data-key="item"]');
            const quantityEl = row.querySelector('[data-key="quantity"]');
            const unitEl = row.querySelector('[data-key="unit"]');
            
            if (nameEl && nameEl.textContent.trim()) {
              newIngredients.push({
                item: nameEl.textContent.trim(),
                quantity: quantityEl ? quantityEl.textContent.trim() : '',
                unit: unitEl ? unitEl.textContent.trim() : '',
                // ã‚«ãƒ†ã‚´ãƒªåã¯å¤ã„å½¢å¼ã§ã¯å–å¾—ãŒé›£ã—ã„
              });
            }
          });
        }
      }

      if (newIngredients.length > 0) {
        currentRecipeData.ingredients = newIngredients;
      }

      // æ‰‹é †ã®åŒæœŸ
      const stepsContainer = document.getElementById('stepsList');
      const stepItems = stepsContainer.querySelectorAll('.step-item, .step-text');
      if (stepItems.length > 0) {
        const newSteps = Array.from(stepItems)
          .map(el => el.innerHTML.replace(/^<b>\d+\.?<\/b>\s*/, '').trim())
          .filter(step => step && step !== 'æ‰‹é †ãªã—');
        currentRecipeData.steps = newSteps;
      }
      
      if (showAlert) {
        alert('ç¾åœ¨ã®ç·¨é›†å†…å®¹ã‚’å†…éƒ¨ãƒ‡ãƒ¼ã‚¿ã«åŒæœŸã—ã¾ã—ãŸã€‚');
      }
      console.log('ğŸ”„ Synced from DOM:', currentRecipeData);
    }

    // ãƒœã‚¿ãƒ³åˆæœŸåŒ–
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('btnAddIngredientInline')?.addEventListener('click', addInlineIngredientRow);
      document.getElementById('btnAddStepInline')?.addEventListener('click', addInlineStepRow);
      document.getElementById('btnAddCategoryInline')?.addEventListener('click', addInlineCategoryBlock);
      document.getElementById('btnApplyOriginalEdits')?.addEventListener('click', () => syncCurrentRecipeFromDOM({ showAlert: true }));
    });

    // ä¿å­˜ãƒ‘ãƒãƒ«å†…ã®ç°¡æ˜“ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆåŒã˜ãƒ—ãƒ­ã‚­ã‚·å›é¿ãƒ­ã‚¸ãƒƒã‚¯ã‚’æµç”¨ï¼‰
    (function() {
      const urlInput = document.getElementById('urlInput');
      const urlBox = document.getElementById('savePaneUrl');
      const btn = document.getElementById('savePaneLoadBtn');
      const frame = document.getElementById('savePaneFrame');
      const originalPreview = document.getElementById('recipePreview');
      const quickTitle = document.getElementById('quickTitle');
      const quickServings = document.getElementById('quickServings');
      const quickNotes = document.getElementById('quickNotes');
      const quickIngName = document.getElementById('quickIngName');
      const quickIngQty = document.getElementById('quickIngQty');
      const quickIngUnit = document.getElementById('quickIngUnit');
      const quickAddIng = document.getElementById('quickAddIng');
      const quickIngTable = document.getElementById('quickIngTable');
      if (!btn || !frame) return;

      btn.addEventListener('click', async () => {
        const url = (urlBox.value || urlInput?.value || '').trim();
        if (!url) { alert('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
        try {
          frame.removeAttribute('srcdoc');
          frame.src = url;
          setTimeout(async () => {
            const blankLike = !frame.contentWindow || !frame.contentDocument || frame.contentDocument.body.children.length === 0;
            if (blankLike) {
              const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
              const sanitized = String(raw)
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
                .replace(/on\w+\s*=\s*'[^']*'/gi, '')
                .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
              const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
              const adCss = `<style>
                [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
                header nav, footer { display:none !important; }
                body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
              </style>`;
              const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
              const blob = new Blob([wrapped], { type: 'text/html' });
              const objectUrl = URL.createObjectURL(blob);
              frame.src = objectUrl;
            }
            // é«˜ã•ã‚’å…ƒãƒ¬ã‚·ãƒ”ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«åˆã‚ã›ã¦å°‘ã—å°ã•ã
            try {
              const baseHeight = originalPreview ? originalPreview.getBoundingClientRect().height : 420;
              const desired = Math.max(240, Math.floor(baseHeight - 40));
              frame.style.height = desired + 'px';
            } catch (_) {}
          }, 1500);
        } catch (e) {
          alert('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
        }
      });

      // ã‚¯ã‚¤ãƒƒã‚¯ä¿®æ­£: ã‚¿ã‚¤ãƒˆãƒ«/äººæ•°/ãƒ¡ãƒ¢
      const applyQuickFields = () => {
        if (quickTitle) document.getElementById('recipeTitle').textContent = quickTitle.value || document.getElementById('recipeTitle').textContent;
        if (quickServings) document.getElementById('recipeServings').textContent = quickServings.value || document.getElementById('recipeServings').textContent;
      };
      quickTitle?.addEventListener('change', applyQuickFields);
      quickServings?.addEventListener('change', applyQuickFields);

      // ã‚¯ã‚¤ãƒƒã‚¯ææ–™è¿½åŠ : åŸèªã®ææ–™è¡¨ç¤ºæœ«å°¾ã«1è¡Œè¿½åŠ ï¼ˆä¿å­˜æ™‚ã«ã‚‚åæ˜ ã•ã‚Œã‚‹ã‚ˆã†currentRecipeDataã«ã‚‚pushï¼‰
      function syncQuickTableFromData() {
        if (!quickIngTable) return;
        const tbody = quickIngTable.querySelector('tbody');
        tbody.innerHTML = '';
        const list = (window.currentRecipeData?.ingredients || []);
        list.forEach((ing, idx) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="item" type="text" value="${ing.item || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="quantity" type="text" value="${ing.quantity || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="unit" type="text" value="${ing.unit || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color); text-align:right;"><button data-del="${idx}" type="button" class="btn secondary" style="padding:.25rem .5rem;">å‰Šé™¤</button></td>`;
          tbody.appendChild(tr);
        });
        // å…¥åŠ›å¤‰æ›´ â†’ ãƒ‡ãƒ¼ã‚¿åæ˜ 
        tbody.querySelectorAll('input').forEach(inp => {
          inp.addEventListener('change', (e) => {
            const el = e.target;
            const i = parseInt(el.getAttribute('data-idx'));
            const key = el.getAttribute('data-key');
            if (!window.currentRecipeData?.ingredients?.[i]) return;
            window.currentRecipeData.ingredients[i][key] = el.value;
          });
        });
        // å‰Šé™¤
        tbody.querySelectorAll('button[data-del]').forEach(btnDel => {
          btnDel.addEventListener('click', (e) => {
            const i = parseInt(e.target.getAttribute('data-del'));
            if (window.currentRecipeData?.ingredients) {
              window.currentRecipeData.ingredients.splice(i, 1);
              syncQuickTableFromData();
              // å·¦å´ã®è¡¨ç¤ºã‚‚åŒæœŸï¼ˆç°¡æ˜“: ã‚¯ãƒªã‚¢ã—ã¦å†æç”»ï¼‰
              const container = document.getElementById('flexibleIngredientsDisplay');
              container.innerHTML = '';
              window.currentRecipeData.ingredients.forEach(ing => {
                const row = document.createElement('div');
                row.className = 'ingredient-item';
                row.textContent = [ing.item || '', [ing.quantity || '', ing.unit || ''].filter(Boolean).join(' ')].filter(Boolean).join(' - ');
                container.appendChild(row);
              });
            }
          });
        });
      }

      quickAddIng?.addEventListener('click', () => {
        const name = (quickIngName?.value || '').trim();
        const qty = (quickIngQty?.value || '').trim();
        const unit = (quickIngUnit?.value || '').trim();
        if (!name) { alert('ææ–™åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
        const container = document.getElementById('flexibleIngredientsDisplay');
        const row = document.createElement('div');
        row.className = 'ingredient-item';
        const text = [name, [qty, unit].filter(Boolean).join(' ')].filter(Boolean).join(' - ');
        row.textContent = text;
        container?.appendChild(row);
        // ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚‚æ›´æ–°
        if (!window.currentRecipeData) window.currentRecipeData = { ingredients: [] };
        if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
        window.currentRecipeData.ingredients.push({ item: name, quantity: qty, unit: unit });
        // å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
        if (quickIngName) quickIngName.value = '';
        if (quickIngQty) quickIngQty.value = '';
        if (quickIngUnit) quickIngUnit.value = '';
        syncQuickTableFromData();
      });

      // åˆæœŸåŒæœŸï¼ˆæŠ½å‡ºæ¸ˆã¿ãŒã‚ã‚‹å ´åˆï¼‰
      if (window.currentRecipeData?.ingredients?.length) {
        syncQuickTableFromData();
      }
    })();
  </script>
</body>
</html>
